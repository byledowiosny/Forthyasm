 When the extended features are not used, Forthx 64 conforms largely to the 2012 ANSI Standard for 64-bit Forth. 

Forthx64 is extended in the following way:

 The sizes of multiprecision integers, real numbers, rational numbers, and floating point numbers are determined on input by the system variable, quadsize (qsz). The minimum quadsize is 1; there is no maximum except limited by available memory. Multiprecision integers are qsz quads long. Other number types are 2*qsz quads in extent. Real numbers consist of a qsz integer part and a qsz fractional part; rational numbers of a qsz numerator and a qsz denominator; floating point numbers, a 64-bit exponent and a 2*qsz-1 mantissa.
 Stack operators are available for the two basic types of multiprecision numbers - ndup, nswap, nover, etc, for multiprecision integers; 2ndup, 2nswap, 2nover, etc, for double qsz numbers - reals, rationals, and floats.

 It is important to understand that number sizes are determined on input. Once a number has been entered, it is placed on the stack in the current quadsize, and subsequently changing the quadsize does not change the number. After changing the quadsize, manipulating the number with stack operators or outputting it will not produce correct results.

 Basic arithmetic is defined on the 64-integers, multiquad integers, rational numbers, real numbers, and floating point numbers. Since numbers on the stack in Forth are not identified as to their type, each number type has its own set of operators. For standard 64-bit integers, the arithmetic operators are the usual +, -, * and /. For multiquad numbers they are identified by "in", for multiquad integers, "re" for real numbers, "ra" for rational numbers, and "fl" for floating point numbers. For example +in, -in, *in, /in, +re, -re, *re, /re, +ra, -ra, *ra, /ra, +fl, -fl, *fl, and /fl. There are also relational operators, constants, variables, literals, and number output operators associated with each number type.
 The lack of number type identifiers for stack entries means that the programmer must be aware of what types of operands are on the stack at any given time. In practice, this is not really a great burden, and is part of the versatility and simplicity of the language.

 Though they are not directly available through keyboard or file input, IEEE format floating-point numbers (single, double, extended, and quad precision) are obtained on the stack through conversion from Forthx64 format reals and floats by operators such as, `re>dp` (real to IEEE double-precision) and `fl>qp` (float to IEEE quad-precision) , etc.
 Both floating point single and double precision occupy 1 quad on the stack, since the minimum size for any object on the stack is 1 quad. They are manipulated by the standard stack operators (dup, drop, swap, etc). IEEE-Extended Precision floats require two quads, even though they are only 80 bits, since everything on the stack must be a multiple of 1 quad. They are manipulated by double-quad stack operators with names preceded by a "2" - 2dup, 2drop, 2swap, etc. Quad-precision floats use all 128 bits of two quads and are manipulated by the same double-quad stack operators.
 As with input, IEEE format floats cannot be output directly to the console. They must be converted to Forthx64 format floats or reals with operators such as, `dp>re` (IEEE double-precision to real) or `qp>fl` (IEEE quad-precision to float), and output with `.re` and `.fl`.

 Floating point math for double-precision is provided by the standard C math library, quad-precision by the libquadmath0 GCC Quad-Precision Math Library, while extended-precision math is preformed by FPU instructions in the x87 processor.
Double-precision math functions are identified by being followed with a "d" - +d, -d, *d, /d, sind, cosd, and so on. Quad-precision math functions are distinguished by a following "q" - +q, -q, *q, /q, sinq, cosq, etc. The math functions done by the x87 follow the Forth tradition of beginning with an "f" - f+, f-, f*, f/, fsin, fcos. And since the x87 uses a separate, limited stack we have, fdrop, fswap, fdup, fswap, etc.

