 Forthx64 is an implementation of 64-bit ANSI Standard Forth for with enhancements for the x86-64 CPU. It is written entirely in assembly language with Intel syntax for the yasm assembler (http://yasm.tortall.net) or the GNU assembler.

 Forthx64 is largely compliant with the Forth 2012 Standard as long as its advanced features are not used.

 Forth is a highly interactive, low-level, stack-oriented computer language. It is based on a simplified virtual CPU over which the programmer has complete control. It was originally designed as an interim language to provide access to new processors before there was time to develop high-level compilers for them. It is intimately tied to assembly language, since assemblers were typically the first programs available for new microprocessors.

 The simplified CPU consists of two stacks, a program instruction pointer, and a jump register. The data stack, as the name implies, holds data. The return stack holds return addresses for Forth subprograms, called words, and may additionally hold data on a temporary basis. Forthx64 provides an additional stack for the latter purpose, called the "auxiliary stack". In Forthx64 the stacks are autonomous and completely independent of the processor stack. The system uses only those CPU registers guaranteed to be preserved by OS calls and C library functions. These are luxuries afforded by the advanced architecture of the x86-64 with its sixteen registers and flexible addressing modes.

 In the beginning, Forth systems had to be frugal with scarce system resources, and every trick was used to make them as fast as possible, leading to such exotic developments as direct threading and subroutine threading. These days we can afford to be extravagant, and with GHz clock speeds, there is rarely a need to go out of our way to make things faster. Hence, Forthx64 is indirectly threaded, the default stack size is 1 MB, and everything is based on the 64-bit quadword*. Whether 64 bits are needed or not, chunks of memory are padded to a 64-bit boundary. The running system can occupy 50 MB or more of RAM, depending on the size of allocated buffers. But it can, of course be made smaller if need be.

 There has been a tendency for Forth to move away from particular CPU architectures and to be implemented in other languages such as C or Python to make it more portable. However this is not in the spirit of the original language, which was to provide a way to deal directly with hardware, especially with the CPU. After all, if we are to add layers of abstraction, we could just as well use C++, Haskell, Scheme, or a number of excellent modern languages. And if you consider, for example, that Python itself is written in C, implementing Forth in Python involves three layers of complexity! Nevertheless, this demonstrates the utility and flexibility of the Forth stack-oriented concept.
 While implementing Forth exclusively for the x86-64 means that it is not directly portable to other platforms at all, a large percentage of computers today are based on these processors, all of which, regardless of the host OS, can run Linux through virtualization.

 Forthx64 has new extensions that allow handling arbitrary-sized objects on the stacks as long as they are muliples of 64-bit quadwords. For this purpose, there is a system variable, quadsize (qsz), which tells how many 64-bit units on the stack to dedicate to certain types of numbers - multiprecision integer, fixed-point, rational, and floating-point - as they are received as ASCII input from the keyboard or a file. It can range from 1 to whatever available RAM will allow. This number determines how big a multi-precision stack entry is in quads (64-bit units). It is important to understand from the outset that the quadsize governs the current size of multi-precision numbers on the stack and that stack operations and arithmetic operations on these numbers require operands to be the same size. Whatever quadsize is in force when a calculation is started will be the same when it is finished. Adaptive-precision operators such as `ufactin` are a rare exception. In any case, the programmer must be aware of the quadsize at all times.

 Another way in which multi-quad data may appear on the stack is as Forthx64 objects - containers preceded by a 64-bit cell with their size in bytes. There are a limited number of operators to deal with such entities - `ob!` and `ob@` to store and fetch objects in memory, `ob>a`, `oba!`, `oba>`, and `oba@` to copy objects to and from the auxiliary stack, and `obdrop` and `obadrop` to discard objects from the data stack and auxiliary stack. This capability is not currently exploited in Forthx64, but could be used to implement object-oriented programming.

 When a number is entered without a radix point, it will be interpreted as a 64-bit signed integer. If the number is too big to be represented in 64 bits, the error message, "numeric overflow on input" will be issued. All the standard Forth operators are available for dealing with 64-bit numbers.

 The numerical engine on which Forthx64 is based is as simple as possible. It consists of algorithms for multi-precision binary integer addition, subtraction, multiplication, and division with remainder. These are entirely sufficient for multi-precision, fixed-point, binary arithmetic. It is the input and output routines that must be tailored to the processing of these numbers. Converting to and from ASCII is different for the integer and fractional portions of real numbers.

 Forthx64 allows unlimited precision arithmetic with real fixed-point binary numbers. While there may be many schemes for scaling fixed-point numbers, Forthx64 uses a simple paradigm. Equal numbers of quadwords are allocated for the integer and fractional parts. This allows real numbers to use the same algorithms as integers for addition, subtraction, multiplication and division, resulting in some very speedy calculations.

 Forthx64 also has its own format for floating-point numbers, and they can be entered directly from the keyboard. Arithmetic on these numbers, although defined, is not well developed, with operations consisting of merely converting floating-point operands to fixed point, carrying out calculations, and then converting them back. Instead, when floating-point calculations are needed, there are operators for converting Forthx64 format fixed-point and floating-point numbers to the IEEE formats, in which form they can be efficiently crunched by the x87 FPU or by the combined hardware/software libraries available through the C language (MXX, SSE).

 While most calculation programs are restricted to decimal numbers and binary, octal, or hexadecimal integers, the radix in Forthx64 can be anything from 2 to 64 for any type of number. Binary numbers on the stack can be output in any of these bases, and numbers entered from the keyboard can be interpreted in any base. So for example, if the base is set to 16, 3.FACE^B is a valid floating-point number, and if we subsequently enter `dec cr .fl` with default settings, it yields,

  7.0011725021184000000000000000000000000000000000000000000000000000^13     (with rdigs=64)

 Anything that can be typed can be pasted into a terminal input buffer. The buffers, however, contain exclusively ASCII printable text. Everything else is filtered out by replacing it with spaces. Pages pasted into the terminal input buffers will loose their formatting, but this is not important for the inner interpreter, whose job it is to parse text from space to space and execute each word or place each number on the stack. As an example of how versatile the input buffers are, try two experiments:

 1) Copy the contents of ForthFiles/Functions/functions.xfs and paste it into the terminal input buffer. The file will be loaded and interpreted just as if you had used `include ForthFiles/Functions/functions.xfs`.

 2) Issue `hg_numbers`, which gives you 4096 quads and 65536 decimal places of precision and go to http://www.piday.org/million/ in your browser. Wait until the page is completely loaded. Then position your cursor at the beginning of pi, left-click, scroll down with the scroll bar about half way, hold the Shift key and left-click again anywhere in the number, press Ctrl+C to copy, go to Forthx64, and press Shift+Ctrl+V. However many digits of pi you selected will appear in the window, and if you press Enter, the number will be put on the stack. To see numbers this large in the window you can use the scrollback buffer navigation keys, Shift+Ctrl+Up/Down for fine scroll, and Shift+Page Up/Page Down for coarse scroll. You can also use Ctrl+- to make the font smaller, and then, Ctrl+0 to restore it to full size.
 The piday website is particularly useful for this demo, since pi is presented without linefeeds. Linefeeds will be replaced by spaces when pasted into Forthx64, so the result would have to be edited to remove them.

* In Intel and AMD x86-64 literature, a quadword is 4x16 = 64 bits. The quadword is the basic unit of memory in Forthx64.

