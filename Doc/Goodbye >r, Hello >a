 There was always a problem with Forth temporarily placing data on the return stack. This could interfere with the functioning of DO...LOOPs, for example, if such data were not removed before the end of a loop. With Forthx64, this problem was made worse by allowing stack entries of arbitrary size to be put on the return stack.
 The obvious solution is to provide an auxiliary stack, independent of the return stack. This requires additional memory, but we are not concerned with memory when gigabytes are available. It is also convenient to have a dedicated processor register for the auxiliary stack pointer, and again, this is available on the x86_64 with its abundance of registers.
 Therefore, all operators that involved moving data between the data stack and return stack now bypass the return stack in favor of the auxiliary stack. For all operators that used the "r" for "return stack" in their names, the "r" has been replaced with "a". For example `>r`, `r>`, `r!`, and `r@`, are now `>a`, `a>`, `a!`, and `a@`. Of all operators using the return stack, only `>r`, `r>`, `r!`, and `r@` have been retained, and their use is deprecated. None of them is used by the system itself, and the return stack is now the sovereign domain of the inner interpreter and stack frames used by assembly language routines.
 The advent of the auxiliary stack opens a whole world of possibilities for new operators, but these have been introduced sparingly in the current edition. The new operators are centered around using the auxiliary stack to contain local variables. There are, however, a few new operators which may be considered essential. A stack display for the auxiliary stack is now needed, as is an associated `apick` function to copy individual quads to the data stack. The standard Forth way of discarding data from the return stack is to move it to the data stack first. This may be economical when it comes to single quads, but it can be expensive for larger chunks of data. Therefore there is provision to drop an arbitrary number of items directly from the auxiliary stack.
 The system is configured by default to dump the auxiliary stack along with the data stack when an error occurs, but there is a system flag (#8) to allow the auxiliary stack to be preserved across error conditions for debugging purposes. This is a toggle called `pastk`.

