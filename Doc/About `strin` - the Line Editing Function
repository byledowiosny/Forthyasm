The goal is to make a practical multi-row line editor as simple as possible.

 For the sake of simplicity the line input function is based on the standard VT-100 emulator functions available through reading and writing standard I/O, which include placing the cursor and reading its position. It does not access the gnome-terminal widget itself. This means that it is rather severely constrained in some respects - it can only deal with ASCII I/O, and it must work around the idiosyncracies of the terminal widget, including its SIGWINCH handler, which causes a race condition when the window is rapidly resized while a large line is being edited.

 The line input function provides multi-row line editing capability while preserving the integrity of the scrollback buffer, so that the buffer will always contain only the lines entered and the resulting output. Achieving this requires some trade-offs. For example, if the window size is reduced while editing a line that will not fit the resized window, the program is made to freeze until the window is restored to its former size. If this is not done, the portion of the line that can't be included in the window is written to the scrollback buffer, where it becomes inaccessible, leaving open the possibility of a line fragment forming in the buffer. Unfortunately, there is no simple way to indicate this frozen condition to the user - any alteration of the reduced window will result in fragmentation. The Ctrl+C interrupt is also disabled during the freeze. There is no escape except to close the terminal window and thereby terminate the forthx process! Unless the user remembers the rule that if the editor is frozen, maximize the window. Then if it is desired to edit the line in the smaller window, use Alt+Down Arrow to switch to an empty buffer or one with a smaller line, reduce the size, and recall the larger line with Alt+UpArrow.
 The window size can also be "virtually" increased by using Ctrl+- to reduce the size of the font. If the font is subsequently returned to normal with Ctrl+0, and the line doesn't fit, the window will be frozen and will then have to be returned to its previous state by using Ctrl+-. Then by switching buffers and pressing Ctrl+0 again, the line can then be safely recalled.
 Another problem that can arise, albeit only when the window size is rapidly changed, is due to a race condition between the terminal widget's SIGWINCH handler and that of `strin`. The cursor can become displaced as a result, causing the fragmentation that we are trying to avoid. The cursor can usually be restored by switching buffers.
 The sure way to prevent problems is to never resize the window while editing a multi-row line without first switching to an empty buffer. Of course, when editing longer lines, it is obviously best to maximize the window.

 If a line is too big for the current window, an ellipsis (...) appears in the top row. When the ellipsis appears, the line may be scrolled within the window area with Ctrl+Up/Down Arrow. As the line is scrolled up, an ellipsis will also appear at the bottom of the window. When the beginning row of the line is reached, the first row of the line replaces the top ellipsis, leaving only the one at the bottom. Note that while we can examine the entire line in this way, the line cannot be edited while being scrolled. The cursor is hidden and its coordinates saved to restore when scrolling is finished. Only the last portion of the line that can be accommodated in the window is editable. As soon as a printable ASCII character is entered or the end of the scrolled buffer is reached, the window reverts to the editable portion, with the ellipsis at the top and the cursor restored.


Miscellany:

 The `strin` terminal interface assumes the existence of at least three buffers - current, previous, and following - in a circularly-linked list. The Ctrl+Up/Down Arrow combination switches to previous and following buffers.

 Another imporant aspect of the line editor is that it strips all input of embedded control characters (carriage returns, linefeeds, EOLs, etc.) All such are replaced with blank spaces. Text input will have distinct words, separated by blanks, but no formatting, unless it happened to have been formatted with blank spaces for the current window dimensions

 All output is allowed to wrap unless explicitly programmed not to.

 The line editor is a full-screen editor (within the size of the current window), but it does not use any auxiliary buffering, so only text within the visible area can be altered.

