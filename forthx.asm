; file: forthx.asm - 1/3/19      Folder: Forthx64 3.0 yasm Source 010319
;
; Forthx64 - Extended Forth for AMD64/Intel64 Microprocessors Version 3.0
;
; Edited for yasm Assembler.
;
; (c) Copyright 2013-2018 by John F. Healy. All rights reserved.
;
; Forthx64 is distributed under the terms of the 2-clause BSD License.
; Copyright (c) 2013-2018, John F. Healy <healyjohnf@gmail.com>
; All rights reserved.
; Redistribution and use in source and binary forms, with or without modification,
; are permitted provided that the following conditions are met:
; 1. Redistributions of source code must retain the above copyright notice
;    this list of conditions and the following disclaimer.
; 2. Redistributions in binary form must reproduce the above copyright notice,
;    this list of conditions and the following disclaimer in the documentation
;    and/or other materials provided with the distribution.
; 
; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND
; ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
; WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
; DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
; ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
; (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
; ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
; OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

; This work is dedicated to my wife, Jeanne Hatok, without whose patience
; and encouragement it might never have come to be.
;
; **************************** NOTES *******************************
;
;
;
; **************************** AGENDA *******************************
;
;
;
; ******* ASSEMBLING, COMPILING, LINKING, DEBUGGING, RUNNING ********
;
; To assemble, compile with gcc*, and link, use:
;
;   yasm -f elf64 forthx.asm && gcc -no-pie -o forthx forthx.o forthx.c
;       -ludis86 -lm -lquadmath
;
; The -f option specifies the executable file format for yasm. The -o option
; tells the compiler to use the following name for the executable file.
;
; To assemble, compile with gcc*, and link for debugging, use:
;
;   yasm -f elf64 -g dwarf2 -l forthx.lst forthx.asm && gcc -no-pie -g -o
;            forthx forthx.o forthx.c -ludis86 -lm -lquadmath
;
; The -g option tells yasm to produce dwarf2 format debug output in a listing
; file specified by the -l option. The -g option for gcc tells the compiler
; to produce debugging information.
;
; To debug, use:
;
;   gdb forthx or ddd forthx
;
; To run, use:
;
;   ./forthx
;
; Note that the -no-pie option may or may not be needed. For some systems
; it is the default. However on other systems, leaving it out can result
; in compilation failure with an error message similar to:
;
;   "relocation R_X86_64_32S against `.bss' can not be used
;   when making a shared object; recompile with -fPIC"
;
; Therefore, I recommend always including it in the command line.
;
; * To use clang instead of gcc, simply substitute "clang" for "gcc"
; in the commands.
;
; **************************** CPU INTERFACE ************************
;
; Forthx64 Dedicated Registers
;
;       r15 – RSP, the Forth Return Stack Pointer
;       r14 - PSP, the Forth Parameter Stack Pointer
;       r13 - ASP, the Forth Auxiliary Stack Pointer
;       r12 – IPA, the Forth Interpreter Pointer
;       r11 – WP,  the Forth Word Pointer
;
; AMD64 Addressing in Brief: effective_address = scale * index + base + offset
;
; **************************** OS INTERFACE ************************
;
; ABI - Register Usage for System Calls and Function Calls
;
; For system calls, arguments 1-6 are passed in registers rdi, rsi, rdx,
; r10, r8, and r9. System calls are limited to six arguments; no arguments are
; passed on the stack. Values are returned in rax.
; For C-function calls, arguments 1-6 are passed in registers rdi, rsi,
; rdx, rcx, r8, and r9. Parameters above six are passed on the stack.
; Values are returned in rax and rdx.
; Registers r12, r13, r14, r15, rbx, rsp, and rbp are preserved by the callee.
; Floating-point arguments are passed and returned in registers xmm0 and xmm1,
; though others may be used for special purposes. None of the xmm registers is
; guaranteed to be preserved across function calls.
;
; **************************** LISTING ******************************
;
; Formats of Forthx64 Elements
;
; Object Format
;
; | Link | Object Size | Object Type | Object |
;
; Note that the object type number occupies the lower 32-bits of the Object
; Type field. The upper 32-bits are reserved for special purposes.
;
; Braidable Vocabulary Format
;
; | link1 | link2 | size | brvo | length | name | dovc0 | voc-link |
; | vlink | single-thread link | -1 | 63-quad table of thread links |
;
; Where voc-link links this vocabulary to all others defined in the system;
; vlink is a backward link to the previous vocabulary in the search order,
; the single-thread link is the link to the last word in this vocabulary,
; and -1 identifies this vocabulary as braidable.
; The vocabulary base address is the address of vlink.

; Non-Braidable Vocabulary Format
;
; | link1 | link2 | size | nbvo | length | name | dovc0 | voc-link |
; | vlink | single-thread link | -2 |
;
; Where voc-link links this vocabulary to all others defined in the system;
; vlink is a backward link to the previous vocabulary in the search order,
; the single-thread link is the link to the last word in this vocabulary,
; and -1 identifies this vocabulary as braidable.
; The vocabulary base address is the address of vlink.

; Dictionary Entry Format

; | link1 | link2 | object size | object type | string length | string |
; | code field |

; Byte-String Number (BSN) Format
;
; |       0       |      8      |     16      |     24      |         32
; | object length | object type | number type | number base | length of 1st string |
;
; | string | length of second string | string | length of third string | string

; The second and third string length quads may occur at odd boundaries, but the
; entire bsn will be padded to an 8-byte boundary.
; The first length quad carries the sign of the number, and the third length
; quad carries the sign of the exponent in the case of a floating-point number.

; Array Format

; | code field | number of elements | element size | elements ... |

; Buffer Format

;  size | current pointer | data | bic# |
;
; The bic# is a 2-quad random number for performing buffer integrity checks.

; File Structure Format

; name | code | link to previous file | file id | buffer address |
; file access method | file permissions | file status | file size |
; current postion pointer | path to file

; System Flags

; System flags are maintained in a dedicated quad at flgs0 and referenced
; by qword[flgs0], 0-63. These flags are global in scope.

;   bit #0  - Initialization flag. System initialized and startup file loaded
;            when set.

;   bit #1  - STATE flag, compiling when set.

;   bit #3  - :C; flag, colon definition in progress when set.

;   bit #5  - DOES flag, set by `create,`, cleared by `does>`.

;   bit #7  - Also flag. When set, prevents forthx from being replaced
;            when it is on top of the vocabulary chain. Clear by default.

;   bit #8  - Auxiliary stack flag. When set, the auxiliary stack is not
;            reset in `quit`. Clear by default.

;   bit #9  - Hide flag, no words are hidden when clear. Hidden words
;            not displayed when set (default).

;   bit #10 - Overflow flag. When set, throw overflow if sign changes
;            on input of single-precision values. Clear by default.

;   bit #11 - Digs flag, pictured numeric output in progress when set.

;   bit #12 - Input terminator flag. When set, the input terminator
;            character is the Home key (actually an escape sequence).
;            When clear (default) the ipt is the Enter key.

;   bit #17 - Fib management flag. A file has been loaded when set.
;            Cleared in `quit`.

;   bit #18 - Strin flag, set when program is in `strin`. The window height
;            and width and cursor coordinates are not updated in response
;            to the SIGWINCH interrupt unless the program is in strin.

;   bit #31 - SIGWINCH has occurred when set. Cleared in `quit` and `strin`.

;   bits #32-35 - FPU register management.

;   bit #47 - Udis86 syntax flag. Use Intel syntax when clear (default).
;            Use AT&T syntax when set.

; *********** First Assembler Statement ***********

; The riprel flag determines whether rip-relative addresses are used
; in the place of absolute addresses. The default is 0 - use absolute
; addresses. Set it to 1 to use rip-relative addressing.

riprel  equ 0

; The algncd flag determines whether code in the text section
; is aligned on 8-byte boundaries, which makes examination of the
; code section for debugging purposes easier. However this slows
; down compilation drastically. Therefore the default is 0 - do not
; align code in the text section. Align code = 1.

algncd  equ 0

; There are no explicit rip relative address references in the listing.
; Set riprel to 1 to assemble absolute addresses as rip relative.

%if riprel

 default rel

%endif

; *** Beginning of Data Area

section .data
align 16, db 0xff

; Intro

intro0: dq  intro1-$-8
        db  10,"Forthx64 v. 3.0",10
        db  "Copyright 2013-2018 by John F. Healy",10
        db  "1/3/19",10
intro1: align 8, db 0

; Licenses and Disclaimers

license0:

dq license1-$-8

db 10,"Forthx64 is distributed under the terms of the 2-clause BSD License.",10
db "Copyright (c) 2013-2018, John F. Healy <healyjohnf@gmail.com>",10
db "All rights reserved.",10

db "Redistribution and use in source and binary forms, with or without modification,",10
db "are permitted provided that the following conditions are met:",10

db "1. Redistributions of source code must retain the above copyright notice",10
db "   this list of conditions and the following disclaimer.",10
db "2. Redistributions in binary form must reproduce the above copyright notice,",10
db "   this list of conditions and the following disclaimer in the documentation",10
db "   and/or other materials provided with the distribution.",10,10

db "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND",10
db "ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",10
db "WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE",10
db "DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR",10
db "ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES",10
db "(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;",10
db "LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON",10
db "ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT",10
db "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS",10
db "SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",10

license1:
align 8, db 0

license2:

dq license3-$-8

db 10,"Udis86 is distributed under the terms of the 2-clause BSD License.",10
db "Copyright (c) 2002-2012, Vivek Thampi <vivek.mt@gmail.com>",10
db "All rights reserved.",10

db "Redistribution and use in source and binary forms, with or without modification,",10
db "are permitted provided that the following conditions are met:",10

db "1. Redistributions of source code must retain the above copyright notice",10
db "   this list of conditions and the following disclaimer.",10
db "2. Redistributions in binary form must reproduce the above copyright notice,",10
db "   this list of conditions and the following disclaimer in the documentation",10
db "   and/or other materials provided with the distribution.",10,10

db "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS' AND",10
db "ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED",10
db "WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE",10
db "DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR",10
db "ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES",10
db "(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;",10
db "LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON",10
db "ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT",10
db "(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS",10
db "SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",10

license3:
align 8, db 0

; *** Preformatted Output Strings

; sprchs - Macro to aid in formatting `.bits` and `.flags`
; tables. Preceeds each of its quoted byte arguments with the escape sequence
; to advance the cursor.

%macro  sprchs 1-*
    %rep %0
           db 27,91,67,%1
    %rotate 1
    %endrep
%endmacro

; Output Strings for `.flags`

; Note that since they don't affect the output, nulls are freely used
; to keep things aligned.

sflgs0: dq  sflgs2-$-8

; Output linefeed and save cursor and attributes.

        db  10,27,55

; Set attribute to underscore only.

        db  27,91,48,109,27,91,52,109

; Output line of underscored blanks.

        times 9 db 27,91,67,32

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line. The intent here is to
; preserve any current attributes, and to draw the vertical lines
; in the normal font with no attributes set.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 9 db  27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Output set of flag bit designations.

sprchs "C","Z","S","O","A","P","T","I","D"

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 9 db  27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Save cursor and attributes.

        db  27,55

; Set attribute to underscore.

        db  27,91,52,109

; Space for flag values and cursor advances.

sflgs1: dq  0,0,0,0,0

; Restore cursor and attributes and output linefeed.

        db  27,56,10

sflgs2:
align 8, db 0

; Output Strings for `.bits`

; Output String for Long Lines

sbtsa0: dq  sbtsb0-$-8

; Output linefeed and save cursor and attributes.

        db  10,27,55

; Set attribute to underscore only.

        db  27,91,48,109,27,91,52,109

; Output line of underscored blanks.

        times 32 db 27,91,67,32,32

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line. The intent here is to
; preserve any current attributes, and to draw the vertical lines
; in the normal font with no attributes set.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124,0,0,0,0                 ; Output 1st bar

; Write vertical lines.

times 32 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Install 1st set of bit numbers.

sprchs "63","62","61","60","59","58","57","56", \
       "55","54","53","52","51","50","49","48", \
       "47","46","45","44","43","42","41","40", \
       "39","38","37","36","35","34","33","32"

; Restore cursor and attributes, output linefeed, save cursor
; and attributes, set attributes to none, and install
; 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 32 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Save cursor and attributes.

        db  27,55

; Set attribute to underscore.

        db  27,91,52,109

; Space for 1st 32 bit-values and cursor advances.

sbtsa1: times 20 dq  0

; Since the bit data is written in 5-byte chunks using quads, 3 bytes
; of padding is needed here to avoid overwriting the next escape sequence.

        dq  0

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 32 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Install 2nd set of bit numbers.

sprchs "31","30","29","28","27","26","25","24", \
       "23","22","21","20","19","18","17","16", \
       "15","14","13","12","11","10"," 9"," 8", \
       " 7"," 6"," 5"," 4"," 3"," 2"," 1"," 0"

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 32 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Save cursor and attributes.

        db  27,55

; Set attribute to underscore.

        db  27,91,52,109

; Space for 2nd 32 bit-values and cursor advances.

sbtsa2: times 21 dq  0

; Restore cursor and attributes and output linefeed

        db  27,56,10

; Output String for Short Lines

sbtsb0: dq  sbtsb5-$-8

; Output linefeed and save cursor and attributes.

        db  10,27,55

; Set attribute to underscore only.

        db  27,91,48,109,27,91,52,109

; Install line of underscored blanks.

        times 16 db 27,91,67,32,32

; Output linefeed, restore cursor and attributes, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 16 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Output 1st set of bit numbers.

sprchs "63","62","61","60","59","58","57","56", \
       "55","54","53","52","51","50","49","48"

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 16 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Save cursor and attributes.

        db  27,55

; Set attribute to underscore.

        db  27,91,52,109

; Space for 1st 16 bit-values and cursor advances.

sbtsb1: times 11 dq  0

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 16 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Install 2nd set of bit numbers.

sprchs "47","46","45","44","43","42","41","40", \
       "39","38","37","36","35","34","33","32"

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 16 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Save cursor and attributes.

        db  27,55

; Set attribute to underscore.

        db  27,91,52,109

; Space for 2nd 16 bit-values and cursor advances.

sbtsb2: times 11 dq  0

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 16 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Install 3rd set of bit numbers.

sprchs "31","30","29","28","27","26","25","24", \
       "23","22","21","20","19","18","17","16"

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 16 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Save cursor and attributes.

        db  27,55

; Set attribute to underscore.

        db  27,91,52,109

; Space for 3rd 16 bit-values and cursor advances.

sbtsb3: times 11 dq  0

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 16 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Install 4th set of bit numbers.

sprchs "15","14","13","12","11","10"," 9"," 8", \
       " 7"," 6"," 5"," 4"," 3"," 2"," 1"," 0"

; Restore cursor and attributes, output linefeed, save cursor and attributes,
; set attributes to none, and install 1st vertical line.

        db  27,56                       ; Restore attributes
        db  10                          ; Output linefeed
        db  27,55                       ; Save attributes
        db  27,91,48,109                ; Clear attributes
        db  124                         ; Output 1st bar

; Write vertical lines.

times 16 db  27,91,67,27,91,67,124

; Restore cursor and attributes.

        db  27,56

; Save cursor and attributes.

        db  27,55

; Set attribute to underscore.

        db  27,91,52,109

; Space for 4rd 16 bit-values and cursor advances.

sbtsb4: times 11 dq  0

; Restore cursor and attributes. Output linefeed.

        db  27,56,10

sbtsb5:

align 8, db 0

; *** Escape Sequences

; Keyboard Interaction Escape Sequences

; These sequences comprise a list in which each sequence is followed by its
; offset into the action vector index table. The elements of the list are
; numbered beginning at 128 to stay above the ASCII portion of the vector table.
; The list begins at kcod0 which contains the number of entries. New entries
; can simply be added at the end and the macro takes care of the numbering.

; Escape Sequence Macros

; Macro to enumerate keyboard interaction Escape sequences. It takes
; the escape sequence as a parameter and places its number in the following
; quad. These numbers begin at 128.

%assign nseq 0
%assign actn 128

%macro  kisqm 1
        dq  %1
        dq  actn
        %assign nseq nseq+1
        %assign actn actn+1
%endmacro

; Specifying one of the following macros determines whether the Up/Down Arrow
; keys switch buffers and the Alt+Up/Down Arrow keys move the cursor up and
; down (default) or whether their roles are reversed.

; Macro for Up/Down Arrow to switch buffers and Alt+Up/Down Arrow to move
; the cursor up and down.

%macro LineRecall1 0

kcod0:  dq  nseqf

; Delete

  kisqm 0x7E335B1B                      ; Esc[3~

; Alt+Up-arrow

  kisqm 0x41333B315B1B                  ; Esc[1;3A

; Alt+Down-arrow

  kisqm 0x42333B315B1B                  ; Esc[1;3B

; Right-arrow

  kisqm 0x435B1B                        ; Esc[C

; Left-arrow

  kisqm 0x445B1B                        ; Esc[D

; Home

  kisqm 0x485B1B                        ; Esc[H

; Up-arrow

  kisqm 0x415B1B                        ; Esc[A

; Down-arrow

  kisqm 0x425B1B                        ; Esc[B

; Ctrl+Up-arrow

  kisqm 0x41353B315B1B                  ; Esc[1;5A

; Ctrl+Down-arrow

  kisqm 0x42353B315B1B                  ; Esc[1;5B

; Ctrl+PageUp

  kisqm 0x7E353B355B1B                  ; Esc[5;5~

; Ctrl+PageDown

  kisqm 0x7E353B365B1B                  ; Esc[6;5~

; Marker for end of keyboard interaction list

        dq  -1

nseqf   equ nseq

%endmacro

; Macro for Alt+Up/Down Arrow to switch buffers and Up/Down Arrow to move
; the cursor up and down.

%macro LineRecall2 0

kcod0:  dq  nseqf

; Delete

  kisqm 0x7E335B1B                      ; Esc[3~

; Up-arrow

  kisqm 0x415B1B                        ; Esc[A

; Down-arrow

  kisqm 0x425B1B                        ; Esc[B

; Right-arrow

  kisqm 0x435B1B                        ; Esc[C

; Left-arrow

  kisqm 0x445B1B                        ; Esc[D

; Home

  kisqm 0x485B1B                        ; Esc[H

; Alt+Up-arrow

  kisqm 0x41333B315B1B                  ; Esc[1;3A

; Alt+Down-arrow

  kisqm 0x42333B315B1B                  ; Esc[1;3B

; Ctrl+Up-arrow

  kisqm 0x41353B315B1B                  ; Esc[1;5A

; Ctrl+Down-arrow

  kisqm 0x42353B315B1B                  ; Esc[1;5B

; Ctrl+PageUp

  kisqm 0x7E353B355B1B                  ; Esc[5;5~

; Ctrl+PageDown

  kisqm 0x7E353B365B1B                  ; Esc[6;5~

; Marker for end of keyboard interaction list

        dq  -1

nseqf   equ nseq

%endmacro

; Invoke macro to set line recall to the default Up/Down Arrow action.

LineRecall1

; Other Escape Sequences

; Reset the terminal and move the cursor to home position.

rset:   dq  2,0x631B                    ; Escc

; Clear the screen and move cursor to home position. This version
; is not correct, although it appeared to work in the `clear`
; command.

; clscr:  dq  7,0x485B1B4A325B1B          ; Esc[2J Esc[H

; Version of `clear` that moves the cursor to home first,
; and then clears from the cursor to the bottom.

clscr:  dq  6,0x4A5B1B485B1B            ; Esc[H Esc[J

; Move cursor to home position

home:   dq  3,0x485B1B                  ; Esc[H

; Erase from cursor to end of screen.

erste:  dq  4,0x4A5B1B                  ; Esc[74

; Get cursor location.

gtcrs:  dq  4,0x6E365B1B                ; Esc[6n

; Note that both of the following pairs save and restore
; the cursor position and attributes and are apparently
; completely equivalent.

; Save cursor position

svcsr:  dq  3,0x735B1B                  ; Esc[s

; Restore cursor position

rscsr:  dq  3,0x755B1B                  ; Esc[u

; Save cursor and attributes

scrat:  dq  2,0x371B                    ; Esc7

; Restore cursor and attributes

rcrat:  dq  2,0x381B                    ; Esc8

; Hide cursor

hdcsr:  dq  6,0x6C35323F5B1B            ; Esc[?25l

; Show cursor

shcsr:  dq  6,0x6835323F5B1B            ; Esc[?25h

; Move cursor forward.

csrf:   dq  3,0x435B1B                  ; Esc[C

; Move cursor back

csrb:   dq  3,0x445B1B                  ; Esc[D

; Move cursor up

csrup:  dq  3,0x415B1B                  ; Esc[A

; Move cursor down

csrdn:  dq  3,0x425B1B                  ; Esc[B

; Scroll the display up.

scrup:  dq  2,0x4D1B                    ; EscM

; Scroll the display down.

scrdn:  dq  2,0x441B                    ; EscD

; Linefeed

linfd:  dq  1,0xA

align 8, db 0

; *** Error Messages

; Error Processing Macros

; Macro to save all general registers plus the flags register to the save
; area passed as a parameter (regs0, regs1, or regs2).
; Note that the saved program counter is set to point to the 1st
; instruction after the macro.
; Place the total byte count (144, including the count itself)
; in the quad preceding the data.
; This macro can be placed anywhere in code for debugging. Use regs0,
; regs1, or regs2 for this purpose.

%macro  saveregsm 1
        mov   qword[%1-8], 144
        mov   [%1], rax
        mov   [%1+8], rbx
        mov   [%1+16], rcx
        mov   [%1+24], rdx
        mov   [%1+32], rsi
        mov   [%1+40], rdi
        mov   [%1+48], rbp
        mov   [%1+56], rsp
        mov   [%1+64], r8
        mov   [%1+72], r9
        mov   [%1+80], r10
        mov   [%1+88], r11
        mov   [%1+96], r12
        mov   [%1+104], r13
        mov   [%1+112], r14
        mov   [%1+120], r15

; Save the instruction pointer so that it points to the next
; instruction after the macro.

        push  %%srgs1
        pop   qword[%1+128]

; Save flags register.

        pushfq
        pop   qword[%1+136]
%%srgs1:
%endmacro

; Macro to save all xmm registers. The argument is the address
; of the save area.

%macro  savexmm 1
        movdqu   [%1], xmm0
        movdqu   [%1+16], xmm1
        movdqu   [%1+32], xmm2
        movdqu   [%1+48], xmm3
        movdqu   [%1+64], xmm4
        movdqu   [%1+80], xmm5
        movdqu   [%1+96], xmm6
        movdqu   [%1+112], xmm7
        movdqu   [%1+128], xmm8
        movdqu   [%1+144], xmm9
        movdqu   [%1+160], xmm10
        movdqu   [%1+176], xmm11
        movdqu   [%1+192], xmm12
        movdqu   [%1+208], xmm13
        movdqu   [%1+224], xmm14
        movdqu   [%1+240], xmm15
%endmacro

; Macro to save all ymm registers. The argument is the address
; of the save area.

%macro  saveymm 1
        vmovdqu  [%1], ymm0
        vmovdqu  [%1+32], ymm1
        vmovdqu  [%1+64], ymm2
        vmovdqu  [%1+96], ymm3
        vmovdqu  [%1+128], ymm4
        vmovdqu  [%1+160], ymm5
        vmovdqu  [%1+192], ymm6
        vmovdqu  [%1+224], ymm7
        vmovdqu  [%1+256], ymm8
        vmovdqu  [%1+288], ymm9
        vmovdqu  [%1+320], ymm10
        vmovdqu  [%1+352], ymm11
        vmovdqu  [%1+384], ymm12
        vmovdqu  [%1+416], ymm13
        vmovdqu  [%1+448], ymm14
        vmovdqu  [%1+480], ymm15
%endmacro

; Throw Macro - places the error message number in rbp
; and jumps to the throw code.

; Parameter is the error message number.

%macro  throwm    1
        mov   rbp, %1
        jmp   [thro]
%endmacro

; Error Message Macro

; Error messages are in a linked list similar to dictionary entries.
; The emsgm macro has two parameters, the message number and the message
; text. The format is | link | object size | object type | message number
; | message size | message text |
; The 1st and 2nd messages are special and are defined in code separately.

%macro    emsgm   2                     ; All but first and last messages
          %strlen cnt %2                ; Get string length
%%elnk:   dq  elnk                      ; Install link
%define   elnk  %%elnk                  ; Define new link
          dq  %%emsge-$                 ; Object size
          dq  emgo                      ; Error message object type
          dq  %1                        ; Message number
          dq  cnt                       ; Length quad
          db  %2                        ; Message text
          %define mod cnt % 8           ; Find remainder after dividing by 8
          %if mod <> 0                  ; Pad to 64-bit boundary
            %define pad 8-mod
            times pad db 32
          %endif
%%emsge:
%endmacro

; Error Message List

; The 1st and 2nd error messages are special, the remaining error messages
; are defined with the macro, emsg.

; Message for Unknown Error

elnk0:  dq  0                           ; Last message link is zero
        dq  48                          ; Object size is 6 quads
        dq  emgo                        ; Object type is error message
        dq  -99                         ; Message number
        dq  13                          ; Message length
        db  "unknown error",32,32,32

; Abort" message

elnk1:  dq  elnk0
        dq  288                         ; Object size is 36 quads
        dq  emgo                        ; Object type is error message
        dq  -2                          ; Message number
abtq0:  dq  21                          ; Message length
        db  "default abort message"
        times 235 db 32

%define elnk  elnk1

emsgm   -1, "execution aborted"

emsgm   134, "integer cannot be exactly represented in requested format"

emsgm   133, "floating-point exception: "

emsgm   132, "not enough operands on floating-point stack"

emsgm   131, "floating-point stack is empty"

emsgm   130, "floating-point stack is full"

emsgm   126, "base must be between 2 and 64 inclusive"

emsgm   125, "string not valid opcode"

emsgm   124, "string not valid hexadecimal number"

emsgm   123, "string not valid binary number"

emsgm   121, "error in select"

emsgm   119, "argument must be positive"

emsgm   118, "argument cannot be zero"

emsgm   117, "argument cannot be negative"

emsgm   110, "no more file buffers available"

emsgm   102, "screen must be at least 49 characters wide for bit display"

emsgm   99, "input buffer too small for line"

emsgm   91, "use only between <# and #>"

emsgm   89, "buffer number out of bounds"

emsgm   86, "hold buffer corrupted or return stack overflow"

emsgm   85, "number output buffer corrupted"

emsgm   84, "number input buffer corrupted"

emsgm   83, "keyboard input pre-buffer corrupted"

emsgm   82, "user buffer corrupted"

emsgm   81, "auxiliary buffer corrupted"

emsgm   80, "file input buffer corrupted"

emsgm   79, "terminal input buffer corrupted"

emsgm   78, "vocabulary is not braided"

emsgm   77, "vocabulary is empty"

emsgm   76, "vocabulary is not braidable"

emsgm   75, "vocabulary is already braided"

emsgm   73, "no non-delimiter found"

emsgm   72, "delimiter runs together with following input"

emsgm   71, "missing delimiter"

emsgm   70, "string cannot be accomodated on a single line"

emsgm   69, "not enough data on stack"

emsgm   68, "object is not a 2value"

emsgm   67, "object is not a value"

emsgm   66, "object is not a toggle"

emsgm   65, "object is not a radio"

emsgm   64, "object is not a defer"

emsgm   63, "is not a valid address"

emsgm   62, "filename cannot end with /"

emsgm   61, "buffer is too small for data"

emsgm   60, "file input buffer is too small for file"

emsgm   59, "OS interface error: "

emsgm   58, "C function call error"

emsgm   54, "number cannot be represented in current quadsize"

emsgm   52, "number cannot be represented in the requested IEEE format" 

emsgm   50, "underflow on output"

emsgm   48, "division underflow"

emsgm   47, "input stream exhausted"

emsgm   46, "no word follows in the input stream"

emsgm   45, "no object type with that number"

emsgm   44, "object size must be a multiple of 8 bytes"

emsgm   43, "no object size specified or object size is too small"

emsgm   42, "buffer must be at least 8 bytes"

emsgm   41, "number cannot be represented in 64 bits"

emsgm   39, "`create,` must be paired with `does>`"

emsgm   38, "`create,...does>` cannot be nested"

emsgm   36, "cannot release precompiled dictionary space"

emsgm   35, "not enough room in dictionary"

emsgm   31, "demominator is negative"

emsgm   30, "denominator is zero"

emsgm   29, "both arguments are zero"

emsgm   27, "multiplication overflow"

emsgm   26, "numeric underflow on input"

emsgm   25, "numeric overflow on input"

emsgm   24, "numeric overflow during calculation"

emsgm   23, "current quadsize does not match container quadsize"

emsgm   22, "container too small for stack entry"

emsgm   21, "numeric overflow on fetch"

emsgm   20, "numeric overflow on store"

emsgm   19, "rounding overflow"

emsgm   17, "toggle not initialized"

emsgm   16, "radio not initialized"

emsgm   15, "defer not initialized"

emsgm   14, "index out of bounds"

emsgm   13, "number out of range"

emsgm   12, "zero divide exception"

emsgm   11, "junk left on auxiliary stack"

emsgm   10, "in protected dictionary"

emsgm   9, "must be used within a colon definition"

emsgm   8, "definition not finished"

emsgm   7, "conditionals not paired"

emsgm   6, "execution only"

emsgm   5, "compilation only, use in definition"

emsgm   4, "definition not unique"

emsgm   3, "stack full"

emsgm   2, "stack empty"
emsg0:
emsgm   1, "not found"

; *** Object Types

; Object Type Macro

; The object type macro uses labels instead of numbers so the numbers don't
; have to be changed when the types are reordered. The macro will
; automatically associate a number with the label. Object types are in a
; linked list, similar to error messages. The obtypm macro has two parameters,
; the object type label and the object type text.
; The format is:
; | link | object size | object number | object type number | object type
; text |.
; The first object type (last in linked list) is the generic dictionary
; entry.

%assign   tnum 1

%define   olnk 0                        ; First link is zero

%macro    obtypm  2
%1        equ  tnum                     ; Associate number with name
          %strlen cnt %2                ; Get string length
%%olnk:   dq  olnk                      ; Link to previous object type
%define   olnk %%olnk
          dq  %%obtp1-$                 ; Object size
          dq  otpo                      ; Object type object type
          dq  tnum                      ; Object number
          %assign tnum tnum+1           ; Increment number
          dq  cnt                       ; Length quad
          db  %2                        ; Object text
          %define mod cnt % 8           ; Find remainder after dividing by 8
          %if mod <> 0                  ; Pad to 64-bit boundary
            %define pad 8-mod
            times pad db 32
          %endif
%%obtp1:
%endmacro

; Object type list

; Note that some of the defined types are not currently being used.

obtypm     gdeo,"generic dictionary entry"
obtypm     hlfo,"high-level Forth code"
obtypm     ecpo,"error checking and processing"
obtypm     stqo,"system query"
obtypm     stco,"system control"
obtypm     hcdo,"headerless code"
obtypm     dcto,"dictionary operator"
obtypm     pgmo,"program control"
obtypm     dfno,"defining word"
obtypm     dfdo,"defined word"
obtypm     cmpo,"compiling word"
obtypm     brvo,"braidable vocabulary"
obtypm     nbvo,"non-braidable vocabulary"
obtypm     vcbo,"vocabulary operator"
obtypm     tibo,"terminal input buffer"
obtypm     fibo,"file input buffer"
obtypm     ubfo,"user buffer"
obtypm     abfo,"auxiliary buffer"
obtypm     kipo,"keyboard input pre-buffer"
obtypm     fsto,"file structure"
obtypm     mrko,"marker"
obtypm     hsto,"host os"
obtypm     nifo,"number input filter"
obtypm     emgo,"error message"
obtypm     objo,"object operator"
obtypm     memo,"memory operator"
obtypm     mqmo,"multi-quad memory operator"
obtypm     stko,"stack operator"
obtypm     mqso,"multi-quad stack operator"
obtypm     nbco,"number conversion operator"
obtypm     inpo,"input operator"
obtypm     oupo,"output operator"
obtypm     txto,"text operator"
obtypm     bsno,"byte-string number"
obtypm     otpo,"object type"
obtypm     rlto,"relational operator"
obtypm     ario,"arithmetic operator"
obtypm     lgco,"logical operator"
obtypm     svro,"system variable"
obtypm     saco,"system address constant"
obtypm     snco,"system numeric constant"
obtypm     sdco,"system 2constant"
obtypm     cnso,"constant"
obtypm     dcno,"2constant"
obtypm     tcno,"3constant"
obtypm     qcno,"4constant"
obtypm     ocno,"8constant"
obtypm     ncno,"nconstant"
obtypm     dnco,"2nconstant"
obtypm     qnco,"4nconstant"
obtypm     onco,"8nconstant"
obtypm     icno,"inconstant"
obtypm     reco,"reconstant"
obtypm     raco,"raconstant"
obtypm     flco,"flconstant"
obtypm     cxco,"cxconstant"
obtypm     obco,"oconstant"
obtypm     valo,"value"
obtypm     dvlo,"2value"
obtypm     dfro,"defer"
obtypm     rado,"radio structure"
obtypm     tglo,"toggle"
obtypm     varo,"variable"
obtypm     dvro,"2variable"
obtypm     tvro,"3variable"
obtypm     qvro,"4variable"
obtypm     ovro,"8variable"
obtypm     nvro,"nvariable"
obtypm     dnvo,"2nvariable"
obtypm     qnvo,"4nvariable"
obtypm     onvo,"8nvariable"
obtypm     ivro,"invariable"
obtypm     revo,"revariable"
obtypm     ravo,"ravariable"
obtypm     flvo,"flvariable"
obtypm     cxvo,"cxvariable"
obtypm     obvo,"ovariable"
obtypm     cnao,"conarr"
obtypm     arro,"array"
obtypm     daro,"2array"
obtypm     taro,"3array"
obtypm     qaro,"4array"
obtypm     oaro,"8array"
obtypm     naro,"narray"
obtypm     dnao,"2narray"
obtypm     qnao,"4narray"
obtypm     onao,"8narray"
obtypm     inao,"inarray"
obtypm     reao,"rearray"
obtypm     raao,"raarray"
obtypm     flao,"flarray"
obtypm     cxao,"cxarray"
obtypm     obao,"oarray"

; Object types from external files

obtypm     udso,"Udis86 operator"
obtypm     dpmo,"double-precision floating-point math operator"
obtypm     dpco,"double-precision constant"
obtypm     qpmo,"quad-precision floating-point math operator"
obtypm     qpco,"quad-precision constant"
obtypm     fpmo,"FPU math operator"
obtypm     fpco,"FPU constant"
obtypm     fvro,"FPU variable"
oblnk0:

; Last object type

obtypm     lsto,"last type"

; Additional object types that may be defined later
;
; For complex numbers:
;
;       cxconstant
;       cxvariable
;       cxarray

; *** System Tables

; nif - Number Input Filter - This table translates a string in the input
; buffer to a byte string number according to the current base. It contains
; the binary value of an ascii digit or 255 for an invalid ascii character.
; The upper case and lower case symbols are available for numbers up to
; base 62. To push the capability to base 64, two new symbols are required.
; I'll use & and %.

nif0:   dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 0-15
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 16-31
        dq  0xff3e3fffffffffff, 0xffffffffffffffff  ; bytes 32-47
        dq  0x0706050403020100, 0xffffffffffff0908  ; bytes 48-63
        dq  0x100f0e0d0c0b0aff, 0x1817161514131211  ; bytes 64-79
        dq  0x201f1e1d1c1b1a19, 0xffffffffff232221  ; bytes 80-95
        dq  0x3231302f2e2d2c2b, 0x2a292827262524ff  ; bytes 96-111
        dq  0xffffffffff3d3c3b, 0x3a39383736353433  ; bytes 112-127
times 16 dq  0xffffffffffffffff                     ; bytes 128-255

; nof - Number Output Filter - This table translates a byte string
;      number to an ascii string in the number output buffer.

nof0:   dq  0x3736353433323130, 0x4645444342413938
        dq  0x4e4d4c4b4a494847, 0x565554535251504f
        dq  0x646362615a595857, 0x6c6b6a6968676665
        dq  0x74737271706f6e6d, 0x25267a7978777675

; ascflt - Filter to change non-printable ascii characters to spaces.
; Used by strin.

ascf0:  dq  0x2020202020202020, 0x2020202020202020  ; bytes 0-15
        dq  0x2020202020202020, 0x2020202020202020  ; bytes 16-31
        dq  0x2726252423222120, 0x2f2e2d2c2b2a2928  ; bytes 32-47
        dq  0x3736353433323130, 0x3f3e3d3c3b3a3938  ; bytes 48-63
        dq  0x4746454443424140, 0x4f4e4d4c4b4a4948  ; bytes 64-79
        dq  0x5756555453525150, 0x5f5e5d5c5b5a5958  ; bytes 80-95
        dq  0x6766656463626160, 0x6f6e6d6c6b6a6968  ; bytes 96-111
        dq  0x7776757473727170, 0x207e7d7c7b7a7978  ; bytes 112-127
times 16 dq  0x2020202020202020                     ; bytes 128-255

; asctbl - Valid character table for parsing.

asctb0: dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 0-15
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 16-31
        dq  0x27262524232221ff, 0x2f2e2d2c2b2a2928  ; bytes 32-47
        dq  0x3736353433323130, 0x3f3e3d3c3b3a3938  ; bytes 48-63
        dq  0x4746454443424140, 0x4f4e4d4c4b4a4948  ; bytes 64-79
        dq  0x5756555453525150, 0x5f5e5d5c5b5a5958  ; bytes 80-95
        dq  0x6766656463626160, 0x6f6e6d6c6b6a6968  ; bytes 96-111
        dq  0x7776757473727170, 0xff7e7d7c7b7a7978  ; bytes 112-127
times 16 dq  0xffffffffffffffff                     ; bytes 128-255

; hextab - Special table for converting ASCII characters directly to hexadecimal.

hextb0: dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 0-15
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 16-31
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 32-47
        dq  0x0706050403020100, 0xffffffffffff0908  ; bytes 48-63
        dq  0xff0f0e0d0c0b0aff, 0xffffffffffffffff  ; bytes 64-79
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 80-95
        dq  0xff0f0e0d0c0b0aff, 0xffffffffffffffff  ; bytes 96-111
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 112-127
times 16 dq  0xffffffffffffffff                     ; bytes 128-255

; Special table for converting hexadecimal nibbles to ASCII bytes.

hxbyt0: dq  0x3736353433323130
        dq  0x4645444342413938

; dlmtbl - Delimiter table for parsing words to the dictionary.

dlmtb0: dq  0xffffffffffffffff, 0xffffffffff0a09ff  ; bytes 0-15
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 16-32
        dq  0xffffffffffffff20, 0xffffffffffffffff  ; bytes 32-47
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 48-63
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 64-79
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 80-95
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 96-111
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 112-127
times 16 dq  0xffffffffffffffff                     ; bytes 128-255

; pathtbl - Special delimiter table for parsing pathnames.

pthtb0: dq  0xffffffffffffffff, 0xffffffffff0affff  ; bytes 0-15
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 16-32
        dq  0xffffffffffffff20, 0xffffffffffffffff  ; bytes 32-47
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 48-63
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 64-79
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 80-95
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 96-111
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 112-127
times 16 dq  0xffffffffffffffff                     ; bytes 128-255

; hashmap - Table for vocabulary hashing.

vhtb0:  dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 0-15
        dq  0xffffffffffffffff, 0xffffffffffffffff  ; bytes 16-31
        dq  0x07060504030201ff, 0x0f0e0d0c0b0a0908  ; bytes 32-47
        dq  0x1716151413121110, 0x1f1e1d1c1b1a1918  ; bytes 48-63
        dq  0x2726252423222120, 0x2f2e2d2c2b2a2928  ; bytes 64-79
        dq  0x3736353433323130, 0x3f3e3d3c3b3a3938  ; bytes 80-95
        dq  0x2726252423222120, 0x2f2e2d2c2b2a2928  ; bytes 96-111
        dq  0x3736353433323130, 0xff3e3d3c3b3a3938  ; bytes 112-127
times 16 dq  0xffffffffffffffff                     ; bytes 128-255

; *** System Flags

flgs0:  dq    544                       ; Default flags

; *** System Variables

; Addresses

sysvar0:

dspo0:  dq    dsp0                      ; dsp - data-space pointer
ltst0:  dq    0                         ; latest
cnxt0:  dq    vlink1                    ; context
crnt0:  dq    vlink1                    ; current
vlnk0:  dq    vocln0                    ; voc-link
cspo0:  dq    0                         ; csp
nwnt0:  dq    lastlnk                   ; newentry - NFA of new entry
lstn0:  dq    0                         ; lastentry - before new definition
ctmb0:  dq    tiblst                    ; ctib - current terminal input buffer
ntib0:  dq    nmtibs+2                  ; number of tibs
cflb0:  dq    fib0                      ; cfib - current file input buffer
nfib0:  dq    nmfibs+2                  ; number of fibs
flnk0:  dq    filk0                     ; file-link
bulk0:  dq    0                         ; buffer-link
emlk0:  dq    emsg0                     ; msg-link - head of message list
oblk0:  dq    oblnk0                    ; obj-link - head of object list
cdlk0:  dq    cdlnk0                    ; code-link - head of headerless code list
hndl0:  dq    0                         ; handler
jmpr0:  dq    0                         ; jmpreg - value of r11 on error
ader0:  dq    0                         ; address that caused SIGSEGV error
fmsk0:  dq    0                         ; X87 exception mask
smsk0:  dq    0                         ; SSE exception mask
asct0:  dq    asctb0                    ; ASCII table
hext0:  dq    hextb0                    ; hexadecimal table
dlmt0:  dq    dlmtb0                    ; delimiter table
ptht0:  dq    pthtb0                    ; path table
sctc0:  dq    sctch0                    ; scratch
cctl0:  dq    hght0                     ; cct - location of cursor ctl variables
stsb0:  dq    stsbf0                    ; address of file-status information
gtod0:  dq    time0                     ; gtod - location of tv struct

; Quantities

qdsz0:  dq    4                         ; quadsize
base0:  dq    10                        ; current number base
pdch0:  dq    32                        ; character used for padding
cdlm0:  dq    0                         ; comment delimiter
rdgs0:  dq    64                        ; number of digits to right of radix
obsz0:  dq    0                         ; object size accumulator
nhld0:  dq    0                         ; number of chars in output string
errn0:  dq    0                         ; OS error number
fpex0:  dq    0                         ; floating-point exception number

; Input specification

scid0:  dq    0                         ; source-id
srce0:  dq    tiblst                    ; address of input buffer
bchc0:  dq    0                         ; buffer character count
scin0:  dq    0                         ; >in offset

; Cursor control variables

hght0:  dq    24                        ; window height
wdth0:  dq    80                        ; window width
area0:  dq    1920                      ; window area
cury0:  dq    0                         ; cursor y
curx0:  dq    0                         ; cursor x

; Cursor control variables used exclusively by `strin` and `sigwinch`

liny0:  dq    0                         ; line y
linx0:  dq    0                         ; line x
ancy0:  dq    0                         ; anchor y

; Anchor x is a constant, but must be in this location for placing
; the cursor when writing lines in `strin`.

ancx0:  dq    1                         ; anchor x

; Other variables used exclusively by `strin` and `sigwinch`

; These variables are currently used by `sigwinch` to save the state
; of the cursor control variables before resetting them for the new
; window size.

hght1:  dq    0                         ; previous height
wdth1:  dq    0                         ; previous width
area1:  dq    0                         ; previous area
cury1:  dq    0                         ; previous cursor y
curx1:  dq    0                         ; previous cursor x
liny1:  dq    0                         ; previous line y
linx1:  dq    0                         ; previous line x
ancy1:  dq    0                         ; previous anchor y

; Place to keep cursor coordinates during scroll.

crsy0:  dq    0,0

; Location of Vector offset table for `strin`

vtof0:  dq    tbls0

; The following variable determines when the freeze flag is cleared
; once it has been set. The window size must be returned to the
; maximized state in order to clear the flag.
; Unfortunately it can only be determined at this point by the user.
; An arbitrary value such as 2000 might work well enough.
; If the program could be started in the maximized state, it could
; be set automatically.

; The user should set amax0 to the area when the window is maximized
; and Ctrl+0 has been pressed.
; In order to thaw a frozen window the terminal area will need to be
; returned to a value equal to or greater than amax0.

amax0:  dq    4096                      ; maximized area

inpt0:  dq    13                        ; input terminator

; *** Save Areas and Scratch Areas

; Save area for Callee Saved registers - r15, r14, r13, r12, rbp, and rbx.

cale0:  times 6 dq 0

; Processor Save Areas for Debugging

; Save area #1 for processor integer registers - 20 quads
; A place for the buffer capacity and a place for the byte count
; are provided for compatibility with the standard Forthx64 buffer
; structure.

        dq  144                         ; Buffer capacity
        dq  0                           ; Slot for regs0 byte count
regs0:  times 18 dq  0

; Save area #2 for processor integer registers - 20 quads
; A place for the buffer capacity and a place for the byte count
; are provided for compatibility with the standard Forthx64 buffer
; structure.

        dq  144                         ; Buffer capacity
        dq  0                           ; Slot for regs1 byte count
regs1:  times 18 dq  0

; Save area #3 for processor integer registers - 20 quads
; A place for the buffer capacity and a place for the byte count
; are provided for compatibility with the standard Forthx64 buffer
; structure.

        dq  144                         ; Buffer capacity
        dq  0                           ; Slot for regs1 byte count
regs2:  times 18 dq  0

; Save area xmm registers - 32 quads

        dq  256
        dq  0
sxmm0:  times 32 dq 0

; Save area for ymm registers - 64 quads

        dq  512
        dq  0
symm0:  times 64 dq 0

; Save area for FXSAVE instruction - 32 quads

align 16, db 0

        dq  256
        dq  0
fpusv0: times 32 dq 0

; Save area for XSAVE instruction - 1024 quads

        ; dq  8192
        ; dq  0
align 64

fprgs0: times 1024 dq 0

; Scratch area for braiding vocabularies and saving information
; for marker. It is two quads larger than needed for the hash table, so as
; to include the linear vocabulary link and dsp for marker.

sctch0: times 65 dq 0

; Save area for file status information - 64 quads

stsbf0: times 64 dq 0

; *** C-structure areas

; SIGWINCH handler structure - 20 quads

stsgw0: times 20 dq 0

; SIGSEGV handler structure - 20 quads

stsgv0: times 20 dq 0

; SIGFPE handler structure - 20 quads

stfpe0: times 20 dq 0

; SIGINT handler structure - 20 quads

stint0: times 20 dq 0

; SIGTSTP handler structure - 20 quads

ststp0: times 20 dq 0

; Processor contexts for siglongjmp - 64 quads each

sigbuf0: times 64 dq 0

sigbuf1: times 64 dq 0

sigbuf2: times 64 dq 0

; Select structure - 20 quads

selct0: times 20 dq 0

; Original termios structure - 8 quads

trmio0: times 8 dq 0

; New termios structure - 8 quads

trmin0: times 8 dq 0

; gettimeofday structure - 4 quads

time0:  dq  0,0,-1,-1

; *** Buffers

; Special Buffer for Direct Hexadecimal Output of 16, 32, or 64 bytes.

        dq  64                          ; Buffer capacity
        dq  0                           ; Place for byte count
hxout0: times 64 dq  0

; Macros for Buffer Sizes

; Note: All buffer sizes are in quads. The auxiliary stack is the same
; size as the data stack.

; Tiny Buffer Sizes for compact systems

%macro tinybuffers 0

  dstksz  equ   65536                   ; Data stack size
  rstksz  equ   65536                   ; Return stack size
  nibsz   equ   2048                    ; Number input buffer size
  nobsz   equ   2048                    ; Number output buffer size
  fibsz   equ   2048                    ; File input buffer size
  dictsz  equ   65536                   ; Reserved dictionary space
  tibsz   equ   2048                    ; Terminal input buffer size
  auxsz   equ   2048                    ; Auxiliary buffer size
  hldsz   equ   2048                    ; Hold buffer size

%endmacro

; Small buffer sizes for normal use

%macro smallbuffers 0

  dstksz  equ   131072                  ; Data stack size
  rstksz  equ   131072                  ; Return stack size
  nibsz   equ   65536                   ; Number input buffer size
  nobsz   equ   65536                   ; Number output buffer size
  fibsz   equ   65536                   ; File input buffer size
  dictsz  equ   131072                  ; Reserved dictionary space
  tibsz   equ   65536                   ; Terminal input buffer size
  auxsz   equ   65536                   ; Auxiliary buffer size
  hldsz   equ   65536                   ; Hold buffer size

%endmacro

; Medium Buffer Sizes for experimenting with large numbers

%macro mediumbuffers 0

  dstksz  equ   1048576                 ; Data stack size
  rstksz  equ   1048576                 ; Return stack size
  nibsz   equ   131072                  ; Number input buffer size
  nobsz   equ   131072                  ; Number output buffer size
  fibsz   equ   131072                  ; File input buffer size
  dictsz  equ   1048576                 ; Reserved dictionary space
  tibsz   equ   131072                  ; Terminal input buffer size
  auxsz   equ   131072                  ; Auxiliary buffer size
  hldsz   equ   131072                  ; Hold buffer size

%endmacro

; Large Buffer Sizes for containing large files, including the Forthx64
; source file

%macro largebuffers 0

  dstksz  equ   2097152                 ; Data stack size
  rstksz  equ   2097152                 ; Return stack size
  nibsz   equ   262144                  ; Number input buffer size
  nobsz   equ   262144                  ; Number output buffer size
  fibsz   equ   262144                  ; File input buffer size
  dictsz  equ   2097152                 ; Reserved dictionary space
  tibsz   equ   262144                  ; Terminal input buffer size
  auxsz   equ   262144                  ; Auxiliary buffer size
  hldsz   equ   262144                  ; Hold buffer size

%endmacro

; Huge Buffer Sizes for million-digit calculations

%macro hugebuffers 0

  dstksz  equ   16777216                ; Data stack size
  rstksz  equ   16777216                ; Return stack size
  nibsz   equ   1048576                 ; Number input buffer size
  nobsz   equ   1048576                 ; Number output buffer size
  fibsz   equ   1048576                 ; File input buffer size
  dictsz  equ   16777216                ; Reserved dictionary space
  tibsz   equ   1048576                 ; Terminal input buffer size
  auxsz   equ   1048576                 ; Auxiliary buffer size
  hldsz   equ   1048576                 ; Hold buffer size

%endmacro

; Invoke the desired macro to set buffer sizes:

mediumbuffers

; Equates for buffer integrity check number

bicna   equ   0x134FBDEF23EC4D75
bicnb   equ   0xB4730AA0BF923150

; Terminal Input Buffers

; Terminal Input Buffer Macros

; The format for tibs is:

; | link to prev | link to following | object size | object type
; | buffer number | buffer size | current line length |

; The tib macros establish the circularly linked terminal input buffers.
; It is expedient to separately define a first and last buffer macro.
; The buffer size (tibsz) is expressed as the number of quads.

%assign   sumtib 1

%macro    tibfirst    0
          %push   tibfst
%$tibfst: dq  %$tiblast
          %push   tibnxt
          dq  %$tibnxt+56
          dq  %%tibe-$
          dq  tibo                      ; Terminal input buffer object type
          dq  sumtib                    ; Buffer number
%assign   sumtib sumtib+1
          dq  tibsz*8                   ; Buffer capacity in bytes
          dq  0                         ; Current buffer pointer
tib0:
%$tibprev:
times tibsz dq  0
          dq  bicna,bicnb               ; Install bic number
%%tibe:
%endmacro

%macro    tibmac      0
%$tibnxt: dq  %$tibprev
          %pop
          %push   tibmac
          dq  %$tibnxt+56
          dq  %%tibe-$                  ; Object size
          dq  tibo                      ; Terminal input buffer object type
          dq  sumtib                    ; Buffer number
%assign   sumtib sumtib+1
          dq  tibsz*8                   ; Buffer capacity in bytes
          dq  0                         ; Current buffer pointer
%$tibprev:
times tibsz dq  0
          dq  bicna,bicnb               ; Install bic number
%%tibe:
%endmacro

%macro    tiblast     0
%$tibnxt: dq  %$tibprev
          %pop
          dq  %$tibfst+56
          dq  %%tibe-$                  ; Object size
          dq  tibo                      ; Terminal input buffer object type
          dq  sumtib                    ; Buffer number
          dq  tibsz*8                   ; Buffer capacity in bytes
          dq  0                         ; Current buffer pointer
tiblst:
%$tiblast:
times tibsz dq  0
          dq  bicna,bicnb               ; Install bic number
          %pop
%%tibe:
%endmacro

; Number of Terminal Input buffers

; Since the first and last buffers are separately defined, there are always
; two more than specified here.

nmtibs  equ   30                        ; Define thirty-two tibs

; Invoke macros to establish tibs.

tibfirst

%rep    nmtibs
        tibmac
%endrep

tiblast

; File Input Buffers

; File Input Buffer Macros

; The format for fibs is:

; | link to prev or 0 | link to following or 0 | object size | object type
; | buffer number | buffer size | current line length

; The fib macros establish a bidirectionally, but not circularly, linked list
; of file input buffers. The first backward and last forward links are zero.
; It is expedient to separately define a first and last buffer macro.
; The buffer size (fibsz) is expressed as the number of quads.
; The equate for the fibsz is given below in "*** Equates for buffer sizes."

%assign   sumfib 1

%macro    fibfirst    0
          dq  0
          %push   fibnxt
          dq  %$fibnxt+56
          dq  %%fibe-$
          dq  fibo                      ; File input buffer object type
          dq  sumfib                    ; Buffer number
%assign   sumfib sumfib+1
          dq  fibsz*8                   ; Buffer capacity in quads
          dq  0                         ; Current buffer pointer
fib0:
%$fibprev:
times fibsz dq  0
          dq  bicna,bicnb               ; Install bic number
%%fibe:
%endmacro

%macro    fibmac      0
%$fibnxt: dq  %$fibprev
          %pop
          %push   fibmac
          dq  %$fibnxt+56
          dq  %%fibe-$                  ; Object size
          dq  fibo                      ; File input buffer object type
          dq  sumfib                    ; Buffer number
%assign   sumfib sumfib+1
          dq  fibsz*8                   ; Buffer capacity in bytes
          dq  0                         ; Current buffer pointer
%$fibprev:
times fibsz dq  0
          dq  bicna,bicnb               ; Install bic number
%%fibe:
%endmacro

%macro    fiblast     0
%$fibnxt: dq  %$fibprev
          %pop
          dq  0
          dq  %%fibe-$                  ; Object size
          dq  fibo                      ; File input buffer object type
          dq  sumfib                    ; Buffer number
          dq  fibsz*8                   ; Buffer capacity in bytes
          dq  0                         ; Current buffer pointer
times fibsz dq  0
          dq  bicna,bicnb               ; Install bic number
%%fibe:
%endmacro

; Number of File Input Buffers

; Since the first and last buffers are separately defined, there are always
; two more than specified here.

nmfibs  equ   6                         ; Define 8 fibs

; Note that the number of file input buffers determines the depth of recursive
; calls to `include`.

; Invoke macros to establish fibs.

fibfirst

%rep    nmfibs
        fibmac
%endrep

fiblast

; Auxiliary Buffer

        dq  axb1-$                      ; Object size
        dq  abfo                        ; Auxiliary buffer object type
        dq  auxsz*8                     ; Buffer capacity in quads
        dq  0                           ; Current buffer pointer
axb0:   times auxsz dq 0
        dq  bicna,bicnb                 ; Install bic number
axb1:

; Keyboard Input Pre-buffer
; Note that this buffer must be at least 4096 bytes and will be the same size
; as the terminal input buffers unless those are less than 4096 bytes.

%define kipsz 512
 %if tibsz > kipsz
    %define kipsz tibsz
 %endif

        dq  kip1-$                      ; Object size
        dq  kipo                        ; Pre-buffer object type
        dq  kipsz*8                     ; Buffer capacity
        dq  0                           ; Byte count of current contents
kip0:   times kipsz dq  0
        dq  bicna,bicnb
kip1:

; System Macros

; Dictionary Header Macros

; Header macros set up the object format for Dictionary entries as follows:

; | link1 | link2 | object size | object type | string length | string |
; | code field |

; The high order double word of the object type field is also used for flags.
; Currently there are only two flags - bit #63 indicates an immediate word;
; bit #62 a hidden word.
; An immediate word executes even while compiling. A hidden word cannot be found
; by the interpreter and does not appear in the `words` listing.

; The firsthead macro has two parameters - the name and the object type.
; It is used for the first entry in each of the predefined word lists - Root
; and forthx. The first entry in the Root wordlist is `forthx`; the first entry
; in the forthx wordlist is `org0`. These words are neither immediate nor
; hidden.


%macro  firsthead       2
        %strlen cnt %1                  ; Get string length
        dq  0                           ; First link field is zero
        dq  0                           ; Null link
        %push hsize                     ; Save context for size calculation
        dq  %$nxthd-$-16                ; Object size
        dq  %2                          ; Object type
        %push head                      ; Save context for link
%$link: dq  cnt                         ; Length quad
        db  %1                          ; Name
        %define mod cnt % 8             ; Find remainder after dividing by 8
        %if mod <> 0                    ; Pad to 64-bit boundary
            %define pad 8-mod
            times pad db 32
        %endif
%endmacro

; The head macro has up to three parameters. The first is the name,
; the second, if present, is the object type. The third, if present, is
; the hidden definition flag. The default object type is gdeo - the generic
; dictionary entry, the default hidden flag is 0 - not hidden.
; The hidden flag is arbitrarily defined to be 1. It is not included in the
; parameter list of a definition unless that definition is meant to be hidden.
; Note that there doesn't seem to be a way to leave out an intervening
; parameter, so that if a definition is hidden, the explicit object type
; must be included.

; The head macro is used for all but the first and last dictionary entries.

%define hidden 1

%macro  head            1-3 gdeo,0
        %strlen cnt %1                  ; Get string length
        dq  0                           ; First link field is zero
        dq  %$link-24                   ; Install link
        %pop                            ; Clear link context
%$nxthd:                                ; Label for previous context
        %pop                            ; Clear size context
        %push hsize                     ; Save next size context
        dq  %$nxthd-$-16                ; Object size
        %if %2 < 0
            %define obj -%2 | 1<<63
        %else
            %define obj %2
        %endif
        %if %3 <> 0
            dq  obj | 1<<62             ; Object type | 1<<62
        %else
            dq  obj                     ; Object type
        %endif
        %push head                      ; Save new link context
%$link: dq  cnt                         ; Length quad
        db  %1                          ; Name
        %define mod cnt % 8             ; Find remainder after dividing by 8
        %if mod <> 0                    ; Pad to 64-bit boundary
            %define pad 8-mod
            times pad db 32
        %endif
%endmacro

; The lasthead macro has four parameters - the name, the object type, a label
; corresponding to the location immediately following the object for
; calculating the object size, and the last vocabulary link label. It is used
; for the last entry in the two precompiled wordlists - forthx and Root.

%macro  lasthead        4
        %strlen cnt %1                  ; Get string length
        dq  0                           ; First link field is zero
        dq  %$link-24                   ; Install link
        %pop                            ; Clear link context
%$nxthd:
        %pop                            ; Clear size context
        dq  %3-$                        ; Object size
        dq  %2                          ; Object type 1
%4:     dq  cnt                         ; Last link is context system variable
        db  %1                          ; Name
        %define mod cnt % 8             ; Find remainder after dividing by 8
        %if mod <> 0                    ; Pad to 64-bit boundary
            %define pad 8-mod
            times pad db 32
        %endif
%endmacro

; Macro to provide a name for headerless code.

; Headerless code names have the following format:
; | link | object size | object type | string length | string | code field |

; Headerless code entries form a linearly linked list separate from standard dictionary
; entries. The beginning node is in the system variable - `code-link`.

; The first link field is zero.

%define nlnk  0

%macro    namem        1
          %strlen cnt %1                ; Get string length
%%nlnk:   dq  nlnk                      ; Install link
%define   nlnk  %%nlnk                  ; Define new link
          dq  %%nmme-$+8                ; Object size
          dq  hcdo                      ; Headerless code object type
          %push name                    ; Push name context
%$nmlnk:  dq  cnt                       ; Length quad
          db  %1                        ; Name
          %define mod cnt % 8           ; Find remainder after dividing by 8
          %if mod <> 0                  ; Pad to 64-bit boundary
            %define pad 8-mod
            times pad db 32
          %endif
%%nmme:
%endmacro

; Text and Data Section Macros

; These macros make it possible for the code to appear along with the headers,
; even though it may be assembled into the read-only text section.

; The macros arrange for each section of code to be preceded by its length
; and by a pointer to its associated header, or to its name string in the case
; of headerless code. The length allows the section of code to be disassembled
; by Udis86, while the pointer to the header or name string allows
; decompilation of colon definitions.

; It would also be possible to arrange for the code to be assembled into
; the data section along with the headers and this would simplify things
; somewhat. However, no debugging symbols are produced in this case, and
; the code resides in read-write memory, which is considered bad practice.
; To try it, though, comment out the section directives in the macros.
; The object sizes will still be correct.

; Text Section Macro

; The textm macro is used with the standard dictionary header. It switches
; to the text section, installs the NFA from the preceeding header macro,
; and installs the length of the code segment, disregarding any padding.

%macro  textm 0
        section .text
        dq  %$link                      ; Install NFA from header macro
        %push txtsz                     ; Push code size context
        dq  %$dtam-$-8
%endmacro

; The text section macro for named code, txtnm, is the same as textm,
; except the backward reference must be to the previous namem macro
; invocation.

%macro  txtnm 0
        section .text
        dq  %$nmlnk                     ; Install NFA from namem macro
        %pop                            ; Pop name context
        %push txtsz                     ; Push size context
        dq  %$dtam-$-8
%endmacro

; A different text section macro is required for last dictionary entry (end).

%macro  txtlst 0
        section .text
        dq  lastlnk
        %push txtsz                     ; Push size context
        dq  %$dtam-$-8
%endmacro

; Data Section Macro

; All versions of the text section macro use the same data section macro.
; If the algncd flag is set, the align directive is applied to keep the code
; aligned on an 8-byte boundary for clarity when examining program memory.
; But the inclusion of the directive slows down compilation drastically.
; Apparently this is because the code must be completely assembled and the
; offsets calculated before it can be aligned. Therefore, algncd is zero
; by default. If code alignment becomes desirable, set it to 1.
; Note that if the code is to be assembled in the data section, the align
; directive will be necessary to keep the dictionary and other elements
; aligned.

%macro datam 0
%$dtam:                                 ; Label for size calculation
        %pop                            ; Pop size context

%if algncd

        align 8, db 0

%endif

        section .data
%endmacro

; *** SYSTEM STARTUP - ENTRY POINT

section .text

; Entry point for C-stub program

global _forthx

_forthx:

; nextm macro

; The nextm macro is fundamental to the inner interpreter.

%macro  nextm   0
        mov     r11,[r12]
        add     r12,8
        jmp     [r11]
%endmacro

; Beginning of Assembler Code

; Save Callee Saved Registers

        lea   rdi, [cale0]
        mov   [rdi], r15
        mov   [rdi+8], r14
        mov   [rdi+16], r13
        mov   [rdi+24], r12
        mov   [rdi+32], rbp
        mov   [rdi+40], rbx

; Initialize Inner Interpreter

        lea   r15, [rstack0]            ; Initialize return stack
        lea   r14, [dstack0]            ; Initialize data stack
        lea   r13, [astack0]            ; Initialize auxiliary stack
        lea   r12, [start0]             ; Initialize Interpreter Pointer
        nextm

section .data

; Headerless Interpreter Startup Code

; Note that `start` is the only high-level headerless code.
; Like other high-level code it doesn't need the txtnm/datam macro pair.
; The stack frame created by `catch` in `start` must be preserved, so that
; subsequently the return stack pointer is reset using `rprst`, which
; preserves these quads, instead of `rp0 rp!` which is now used only here.
; Note also that `aprst` resets the auxiliary stack pointer only if system
; flag #8 is clear (the default). Setting flag #8 preserves the auxiliary
; stack pointer and contents across error processing and thus provides
; a debugging tool.

namem   "start"
start0: dq  init
strt1:  dq  rpzro,rpsto
        dq  lit,quit,catch
        dq  errout,cr
        dq  qcol,zbran,strt2
        dq  endcol,rsetdp
strt2:  dq  sprst,aprst
        dq  bran,strt1

;  Headerless System Code

; thro - Code to handle Forthx64 exceptions

namem   "thro"
thro:   dq  thro0
txtnm
thro0:  mov   r15, [hndl0]              ; Restore saved RSP context
        mov   rdx, [r15]                ; Pop previous handler
        mov   [hndl0], rdx              ; Restore previous handler
        add   r15, 8
        mov   r14, [r15]                ; Restore stack pointer
        add   r15, 8
        mov   [jmpr0], r11              ; Save jump register
        sub   r14, 8                    ; Push exception number
        mov   [r14], rbp                ; Exception number is first argument
        mov   r12, [r15]                ; Semis
        add   r15, 8
        nextm
datam

; nzbran - Code to substitute for the 'zequ,zbran' phrase that occurs so often
; in precompiled code, and for which there is no standard dictionary entry.

namem   "nzbran"
nzbran: dq  nzbr0
txtnm
nzbr0:  mov   rdx, [r14]
        add   r14, 8
        test  rdx, rdx
        jnz   nzbr1
        add   r12, 8
        jmp   nzbr2
nzbr1:  mov   r12, [r12]
nzbr2:  nextm
datam

; src>r - Push the four quads of the input specification - src, bcc, sid,
; and tin - to the return stack. This is headerless code. The data stack
; is bypassed.

namem   "src>r"
srctr:  dq  sctr0
txtnm
sctr0:  mov   rax, [srce0]              ; Get buffer addr
        mov   rbx, [bchc0]              ; Get character count
        mov   rcx, [scin0]              ; Get >IN
        mov   rdx, [scid0]              ; Get SOURCE-ID
        sub   r15, 32                   ; Make room on return stack
        mov   [r15+24], rax
        mov   [r15+16], rbx
        mov   [r15+8], rcx
        mov   [r15], rdx
        nextm
datam

; srcr> - Pop the four quads of the input specification - src, bcc, sid,
; and tin - from the return stack into their respective system variables.
; This is headerless code. The data stack is bypassed.

namem   "srcr>"
srcfr:  dq  scfr0
txtnm
scfr0:  mov   rax, [r15+24]
        mov   rbx, [r15+16]
        mov   rcx, [r15+8]
        mov   rdx, [r15]
        add   r15, 32                   ; Pop return stack
        mov   [srce0], rax              ; Put buffer addr
        mov   [bchc0], rbx              ; Put character count
        mov   [scin0], rcx              ; Put >IN
        mov   [scid0], rdx              ; Put SOURCE-ID
        nextm
datam

; next-fib - If this is the 1st call to this function set system flag #17,
; clear the 1st file input buffer, and return its address. If the flag is already
; set, clear the following buffer, return its address, and update cfib.
; If the buffers are all in use (zero link to following buffer), clear the flag,
; reset cfib to fib0, and throw error.

namem   "next-fib"
nxtfib: dq  nxfb0
txtnm
nxfb0:  mov   rdi, [cflb0]              ; Get cfib
        bts   qword[flgs0], 17          ; Test/set 1st file flag
        jnc   nxfb2                     ; Branch if flag was clear

        mov   rdi, [rdi-48]             ; Get addr of following buffer
        cmp   rdi, 0                    ; Test for zero link
        jnz   nxfb1

        btr   qword[flgs0], 17          ; Clear 1st file flag
        lea   rsi, [fib0]               ; Get fib0
        mov   [cflb0], rsi              ; Restore cfib to fib0

        throwm 110                      ; No more buffers

nxfb1:  mov   [cflb0], rdi              ; Update cfib
nxfb2:  mov   rax, [rdi-8]              ; Get number of characters in buffer
        cmp   rax, 0                    ; See if none
        jz    nxfb5                     ; Exit if none

        mov   rcx, rax                  ; Copy character count
        and   rax, 7                    ; See how much to add
        jz    nxfb3                     ; Branch if no bytes to add

        neg   rax
        add   rax, 8
        add   rcx, rax                  ; Add rounding bytes

nxfb3:  shr   rcx, 3                    ; Convert to quad count
        add   rcx, 1                    ; Add 1 for buffer pointer
nxfb4:  mov   qword[rdi+rcx*8-16], 0    ; Null buffer pointer and contents
        sub   rcx, 1                    ; Decrement counter
        jnz   nxfb4

nxfb5:  sub   r14, 8                    ; Put buffer address on stack
        mov  [r14], rdi
        nextm
datam

; prev-fib - After loading file, reset cfib to the previous file input buffer.
; If the link to the previous buffer is zero, clear the 1st file flag.

namem   "prev-fib"
prvfib: dq  pvfb0
txtnm
pvfb0:  mov   rdi, [cflb0]              ; Get cfib
        mov   rdi, [rdi-56]             ; Get addr of previous buffer
        cmp   rdi, 0                    ; Test for zero link
        jnz   pvfb1

        btr   qword[flgs0], 17          ; Clear 1st file flag
        jmp   pvfb2

pvfb1:  mov   [cflb0], rdi              ; Update cfib

pvfb2:  nextm
datam

; rstfbs - Clear the file buffer flag, system flags bit #17, and reset cfib
; to fib0.

namem   "rstfbs"
rstfbs: dq  rsfb0
txtnm
rsfb0:  btr   qword[flgs0], 17          ; Clear 1st file flag
        lea   rsi, [fib0]               ; Get fib0
        mov   [cflb0], rsi              ; Restore cfib to fib0
        nextm
datam

; vclnk - Link new word to vocabulary

namem   "vclnk"
vclnk:  dq  vclk0
txtnm
vclk0:  mov   rdi, [nwnt0]              ; Get newentry
        sub   rdi, 24                   ; Offset to 2nd link field
        mov   rsi, [crnt0]              ; Get vocabulary base address from current
        mov   rdx, [rsi+8]              ; Get single link thread
        mov   [rdi], rdx                ; Link new word to dictionary
        mov   [rsi+8], rdi              ; Put new link in single-thread
        mov   qword[rdi-8], 0           ; Clear 1st link field

; Check if not braided or not braidable.

        cmp   qword[rsi+16], -1         ; See if braid established
        jle   vclk1                     ; Exit if not

        lea   rbp, [vhtb0]              ; Load hash table address
        sub   rdi, 8                    ; Back up to 1st link field
        xor   rax, rax                  ; Zero byte register
        mov   al, [rdi+40]              ; Get first byte of name
        mov   al, [rbp+rax]             ; Get offset from table
        mov   rdx, [rsi+rax*8+8]        ; Get last link in strand
        mov   [rdi], rdx                ; Install in new link field
        mov   [rsi+rax*8+8], rdi        ; Install new link in table

vclk1:  nextm
datam

; bulnk - Link new buffer to buffer chain

namem   "bulnk"
bulnk:  dq  bflk0
txtnm
bflk0:  mov   rdi, [dspo0]              ; Get dictionary pointer
        mov   rdx, [bulk0]              ; Get current buffer link
        mov   [rdi], rdx                ; Put last link in new buffer
        lea   rdi, [rdi+24]             ; Offset to 1st data cell
        mov   [bulk0], rdi              ; Put new link in buffer-link
        add   qword[dspo0], 8           ; Advance dsp
        nextm
datam

; 0allot - ( n --- ) Allot n bytes starting at the current dp location,
; and initialize it to zero. The byte count is assumed to be evenly
; divisible by eight!

namem   "0allot"
zallot: dq  zalt0
txtnm
zalt0:  mov   rcx, [r14]                ; Get byte count
        add   r14, 8                    ; Pop stack
        shr   rcx, 3                    ; Convert to quad count
        mov   rdi, [dspo0]              ; Get dsp

zalt1:  mov   qword[rdi], 0             ; Fill memory with zeroes
        add   rdi, 8                    ; Increment address
        sub   rcx, 1                    ; Decrement count
        jnz   zalt1                     ; Loop for count

        mov   [dspo0], rdi              ; Update dsp
        nextm
datam

; objcom - Install object type in new entry

namem   "objcom"
objcom: dq  objc0
txtnm
objc0:  mov   rdx, [r14]                ; Get object type number
        add   r14, 8                    ; Pop the stack
        mov   rdi, [nwnt0]              ; Get NFA of new entry
        mov   [rdi-8], edx              ; Install object type
        nextm
datam

; oszcom - Install object size in new entry

namem   "oszcom"
oszcom: dq  oszc0
txtnm
oszc0:  mov   rdi, [obsz0]              ; Get object start address
        mov   rsi, [dspo0]              ; Get data space pointer
        sub   rsi, rdi                  ; Calculate object size
        mov   [rdi], rsi                ; Install object size
        nextm
datam

; mrkcom - Install marker

namem   "mrkcom"
mrkcom: dq  mkcm0
txtnm
mkcm0:  mov   rdi, [dspo0]              ; Get dsp

; Save the dsp as it was before the marker was created

        mov   rdx, [r14]                ; Get dsp from stack
        add   r14, 8                    ; Pop the stack
        mov   [rdi], rdx                ; Save dsp

        mov   rdx, [cnxt0]              ; Get context
        mov   [rdi+8], rdx              ; Save context
        mov   r8, rdx                   ; Copy context (top of voc stack)
        mov   rdx, [crnt0]              ; Get current
        mov   [rdi+16], rdx             ; Save current
        mov   r9, rdx                   ; Copy current
        mov   rdx, [vlnk0]              ; Get voc-link
        mov   [rdi+24], rdx             ; Save voc-link
        mov   rdx, [flnk0]              ; Get file-link
        mov   [rdi+32], rdx             ; Save file-link
        mov   rdx, [bulk0]              ; Get buffer-link
        mov   [rdi+40], rdx             ; Save buffer-link

        add   rdi, 48                   ; Advance past file-link cell
        mov   rsi, r8                   ; Copy vocabulary stack link

mkcm1:  mov   [rdi], r8                 ; Save vocabulary base address
        add   rdi, 8                    ; Advance marker pointer
        mov   rdx, [rsi]                ; Get vocabulary stack link
        mov   [rdi], rdx                ; Install vocabulary stack link
        add   rdi, 8                    ; Advance pointers
        add   rsi, 8

; Test for current base address, and if this is the current vocabulary,
; copy links from scratch area.

        cmp   r9, r8                    ; Test for current base address
        jnz   mkcm3                     ; Branch if not current

        mov   rax, [sctc0]              ; Get scratch area base address
        cmp   qword[rsi+8], 0           ; See if braided
        js    mkcm2                     ; Branch if not

; Copy links from scratch area

%rep    65
        mov   rdx, [rax]
        mov   [rdi], rdx
        add   rax, 8
        add   rdi, 8
%endrep

        jmp   mkcm5

; Copy the linear link from scratch area and the braid flag
; from the vocabulary.

mkcm2:  mov   rdx, [rax]
        mov   [rdi], rdx
        add   rdi, 8                    ; Advance pointer
        mov   rdx, [rsi+8]
        mov   [rdi], rdx
        add   rdi, 8                    ; Advance pointer
        jmp   mkcm5

mkcm3:  mov   rdx, [rsi]
        mov   [rdi], rdx                ; Install link to last voc word
        add   rdi, 8                    ; Advance pointers
        add   rsi, 8
        mov   rdx, [rsi]
        mov   [rdi], rdx                ; Install braid flag
        add   rdi, 8                    ; Advance pointers
        add   rsi, 8
        cmp   rdx, 0                    ; See if braided
        js    mkcm5                     ; Branch if not braided

; Save hash table

%rep    63
        mov   rdx, [rsi]
        mov   [rdi], rdx
        add   rsi, 8
        add   rdi, 8
%endrep

mkcm5:  mov   rsi, [r8]                 ; Get next link in voc chain
        mov   r8, rsi                   ; Save copy
        cmp   rsi, 0                    ; Finished if link is zero
        jnz   mkcm1                     ; Else loop

        mov   qword[rdi], 0             ; Install zero for end of list
        add   rdi, 8                    ; Advance dsp
        mov   [dspo0], rdi              ; Set new dsp
        nextm
datam

; Return :C; flag
; colon@ - Return boolean value of :C; - flags bit #3.

namem   "colon@"
qcol:   dq  qcol0
txtnm
qcol0:  bt    qword[flgs0], 3
        setc  al
        neg   al
        movsx rdx, al
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; stcol - Set :C; flag when beginning colon definition. Save newentry in
; lastentry to reset things if an error occurs during compilation of colon
; definition.

namem   "stcol"
stcol:  dq  stcl0
txtnm
stcl0:  bts   qword[flgs0], 3
        mov   rdx, [nwnt0]
        mov   [lstn0], rdx
        nextm
datam

; endcol - Clear :C; flag when finishing colon definition.

namem   "endcol"
endcol: dq  ndcl0
txtnm
ndcl0:  btr   qword[flgs0], 3
        nextm
datam

; rsetdp - Reset the dictionary pointer and newentry if there is an error
;         during the creation of a colon definition.

namem   "rsetdp"
rsetdp: dq  rsdp0

; Reset newentry and set dp to this address. Used to recover from an error
; occuring during compilation of a colon definition.
txtnm
rsdp0:  mov   rdx, [nwnt0]              ; Get newentry
        sub   rdx, 32                   ; Back up to first link field
        mov   [dspo0], rdx              ; Reset dictionary pointer
        mov   rdx, [lstn0]              ; Get saved last entry
        mov   [nwnt0], rdx              ; Reset newentry
        nextm
datam

; rsalso - Reset the also flag in the event of an error during compilation.

namem   "rsalso"
rsalso: dq  rsal0
txtnm
rsal0:  btr   qword[flgs0], 7
        nextm
datam

; stdoes - Set DOES flag when compiling high-level defining word.
; Throw '`create,...does>` cannot be nested' if flag was already set.

namem   "stdoes"
stdos:  dq  stds0
txtnm
stds0:  bts   qword[flgs0], 5
        jnc   stds1

        btr   qword[flgs0], 5

        throwm 38

stds1:  nextm
datam

; cldoes - Clear DOES flag when compiling high-level defining word.
; Throw '`create,` must be paired with `does>`' if flag was already clear.

namem   "cldoes"
cldos:  dq  clds0
txtnm
clds0:  btr   qword[flgs0], 5
        jc    clds1

        throwm 39

clds1:  nextm
datam

; savcrnt - Special routine for `marker` to save the hash table of the current
; vocabulary in the scratch area for braiding vocabularies, so the vocabulary
; may be restored to its state before the marker was linked.

namem   "savcrnt"
savcur: dq  svcr0
txtnm
svcr0:  mov   rsi, [crnt0]              ; Get current
        add   rsi, 8                    ; Advance to linear link field
        mov   rdi, [sctc0]              ; Get scratch area base address
        cmp   qword[rsi+8], -1          ; See if braided
        jz    svcr1                     ; Branch if not

; Save linear link and hash table

%rep    65
        mov   rdx, [rsi]
        mov   [rdi], rdx
        add   rsi, 8
        add   rdi, 8
%endrep

        jmp   svcr2

; Save only the linear link

svcr1:  mov   rdx, [rsi]
        mov   [rdi], rdx

svcr2:  nextm
datam

; >mark - Reserve dictionary location for a forward branch and leave
; its address on the stack. Equivalent of:

; : >mark   here 0 , ;

namem   ">mark"
fmark:  dq  fmrk0
txtnm
fmrk0:  mov   rdi, [dspo0]              ; Get dsp
        mov   qword[rdi], 0             ; Install zero
        sub   r14, 8
        mov   [r14], rdi                ; Put location on stack
        add   qword[dspo0], 8           ; Advance dsp
        nextm
datam

; >resolve - Resolve a forward branch by placing the current dsp address
; in the reserved dictionary location whose address is on the stack.
; Equivalent of:

; : >resolve   here swap ! ;

namem   ">resolve"
frslv:  dq  frsv0
txtnm
frsv0:  mov   rdi, [r14]                ; Pop address from stack
        add   r14, 8
        mov   rdx, [dspo0]              ; Get dsp
        mov   [rdi], rdx                ; Install target
        nextm
datam

; <mark - Put dictionary location for a backward branch on the stack.
; Equivalent of:

; : <mark   here ;

namem   "<mark"
bmark:  dq  bmrk0
txtnm
bmrk0:  mov   rdi, [dspo0]              ; Get dsp
        sub   r14, 8
        mov   [r14], rdi                ; Push to stack
        nextm
datam

; <resolve - Resolve a backward branch by compiling its address,
; which is on the stack at the current dictionary location.
; Equivalent of:

; : <resolve   , ;

namem   "<resolve"
brslv:  dq  brsv0
txtnm
brsv0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rdx, [r14]                ; Get stack item
        add   r14, 8                    ; Pop stack
        mov   [rdi], rdx                ; Store at dsp location
        add   qword[dspo0], 8           ; Advance dsp
        nextm
datam

; *** DICTIONARY

; String macros

; Macro to create a counted asciiz string. If the character count of the
; string is an even multiple of eight bytes, pad with eight zeroes.

%macro  casczm 1
        %strlen cnt %1                  ; Get string length
        dq  cnt                         ; String length
        db  %1                          ; Name
        %define mod cnt % 8             ; Find remainder after dividing by 8
        %if mod = 0                     ; Pad to 64-bit boundary
            %define pad 8               ; There must be at least 1 zero
        %else
            %define pad 8-mod
        %endif
        times pad db 0                  ; Pad with zeroes
%endmacro

; pdtqm - This macro is for outputting strings in precompiled code.
; It outputs the string in one go instead of one character at a time.

%macro  pdtqm 1
        %strlen cnt %1                  ; Get string length
        dq  pdotq                       ; String output handling routine
        dq  cnt                         ; String length
        db  %1                          ; String
        %define mod cnt % 8             ; Find remainder after dividing by 8
        %if mod <> 0                    ; Pad to 64-bit boundary
            %define pad 8-mod
            times pad db 32
        %endif
%endmacro

; qdtqm - This is the same as the above macro, except if the cursor is too
; close to the end of the line to accommodate the string the code routine
; outputs a newline before printing the string.

%macro  qdtqm 1
        %strlen cnt %1                  ; Get string length
        dq  qdotq                       ; String output handling routine
        dq  cnt                         ; String length
        db  %1                          ; String
        %define mod cnt % 8             ; Find remainder after dividing by 8
        %if mod <> 0                    ; Pad to 64-bit boundary
            %define pad 8-mod
            times pad db 32             ; Pad with spaces
        %endif
%endmacro

; psqtm - Macro to perform the function of `s"` in precompiled code.

%macro  psqtm 1
        %strlen cnt %1                  ; Get string length
        dq  pstrq                       ; Code for `s"`
        dq  cnt                         ; String length
        db  %1                          ; String
        %define mod cnt % 8             ; Find remainder after dividing by 8
        %if mod <> 0                    ; Pad to 64-bit boundary
            %define pad 8-mod
            times pad db 32
        %endif
%endmacro

; OS Independent Code

; Root Dictionary - wordlist for only vocabulary

; forthx - Vocabulary structure prototype.

firsthead "forthx", brvo
forthx: dq  dovc0
vocln0: dq  rtlnk                       ; Link to previously defined vocabulary

vlink1: dq  vlink0                      ; Vocabulary stack link
        dq  lastlnk-24                  ; Link to last word in forthx

; First braid strand cell is used for braid flag. It is initialized
; to -1 (unbraided).

        dq  -1                          ; Initialize first strand cell to -1
times 63 dq 0                           ; 64-quad link table

; forth-wordlist - Return the wordlist id (vlink field address)
; of the forthx vocabulary.

head    "forth-wordlist", vcbo
fwid:   dq  fwid0
textm
fwid0:  sub   r14, 8
        lea   rdx, [vlink1]
        mov   [r14], rdx
        nextm
datam

; order - List vocabulary search order

; : order   context @ begin dup 8- 8- >name .name space
;         @ dup 0= until drop 4 spaces current @ 8- 8-
;         >name .name ;

head    "order", hlfo
ordr:   dq  docl0,cont,qat
ordr1:  dq  dupl,eighm,eighm,cftnf,dtnam,space
        dq  qat,dupl,zequ,uzbrn,ordr1
        dq  drop,four,spaces,curr,qat,eighm,eighm
        dq  cftnf,dtnam,semis

; words - ( words --- ) List the dictionary on top of the search order.

; : words   context @ dup
;           begin
;                cr 16- >name cr .name ." Wordlist:" cr dup 8+ @ dup 0=
;                if
;                  ." vocabulary is empty"
;                else
;                    begin
;                         dup dup 16+ 62 (btst) ?hide and
;                         if
;                           drop
;                         else
;                           24+ .name 1 ?spaces
;                         then
;                         @ dup 0=
;                    until
;                then
;                drop @ dup dup 0=
;           until 2drop ;

lasthead "words", hlfo, dict0, rootlnk
words:  dq  docl0
        dq  cont,qat,dupl
words1: dq  cr,sixtm,cftnf,cr,dtnam
        pdtqm "Wordlist:"
        dq  cr,dupl,eighp,qat,dupl
        dq  zequ,izbrn,words2
        pdtqm "vocabulary is empty"
        dq  ebran,words5
words2: dq  dupl,dupl,sixtp,lit,62
        dq  pbtst,qhid,andf,izbrn,words3
        dq  drop,ebran,words4
words3: dq  twfp,dtnam,one,qspacs
words4: dq  qat,dupl,zequ,uzbrn,words2
words5: dq  drop,qat,dupl,dupl
        dq  zequ,uzbrn,words1
        dq  ddrop,semis
dict0:

; Forth Dictionary

; System address constants - Constants are pushed to the stack when invoked.

; org0 - Address of the beginning of the data segment.

firsthead "org0", saco
orgn:   dq  orgn0
textm
orgn0:  lea   rdi, [intro0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; txt0 - Address of beginning of the text segment

head    "txt0", saco
txtn:   dq  txtn0
textm
txtn0:  lea   rdi, [_forthx]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; sp0 - Initial data stack pointer.

head    "sp0", saco
spzro:  dq  spzr0
textm
spzr0:  lea   rdi, [dstack0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; rp0 - Initial return stack pointer.

head    "rp0", saco
rpzro:  dq  rpzr0
textm
rpzr0:  lea   rdi, [rstack0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; ap0 - Initial auxiliary stack pointer.

head    "ap0", saco
apzro:  dq  apzr0
textm
apzr0:  lea   rdi, [astack0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; dsp0 - Initial data space pointer.

head    "dsp0", saco
dspn:   dq  dspn0
textm
dspn0:  lea   rdi, [dsp0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; kip0 - Keyboard input pre-buffer

head    "kip0", saco
kipn:   dq  kipn0
textm
kipn0:  lea   rdi, [kip0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; tib0 - First terminal input buffer

head    "tib0", saco
tibn:   dq  tibn0
textm
tibn0:  lea   rdi, [tib0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; fib0 - First file input buffer

head    "fib0", saco
fibn:   dq  fibn0
textm
fibn0:  lea   rdi, [fib0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; axb0 - Auxiliary buffer

head    "axb0", saco
axbn:   dq  axbn0
textm
axbn0:  lea   rdi, [axb0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; nib0 - Number input buffer

head    "nib0", saco
nibn:   dq  nibn0
textm
nibn0:  lea   rdi, [nib0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; nob0 - Number output buffer

head    "nob0", saco
nobn:   dq  nobn0
textm
nobn0:  lea   rdi, [nob0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; hld0 - Hold buffer

head    "hld0", saco
hldn:   dq  hldn0
textm
hldn0:  lea   rdi, [hld0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; regs0 - Save area for processor integer registers, instruction pointer,
; and flags register for debugging - 18 quads in extent

head    "regs0", saco
srzro:  dq  rzro0
textm
rzro0:  lea   rdi, [regs0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; regs1 - Save area for processor integer registers, instruction pointer,
; and flags register for debugging - 18 quads in extent

head    "regs1", saco
srone:  dq  rone0
textm
rone0:  lea   rdi, [regs1]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; regs2 - Save area for processor integer registers, instruction pointer,
; and flags register for debugging - 18 quads in extent

head    "regs2", saco
srtwo:  dq  rtwo0
textm
rtwo0:  lea   rdi, [regs2]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; sxmm0 - Save area for xmm registers

head    "sxmm0", saco
sxmmz:  dq  xmmz0
textm
xmmz0:  lea   rdi, [sxmm0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; symm0 - Save area for ymm registers

head    "symm0", saco
symmz:  dq  ymmz0
textm
ymmz0:  lea   rdi, [symm0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; fpusv0 - Save area for x87 fxsave instruction - 32 quads in extent

head    "fpusv0", saco
fpusv:  dq  fpus0
textm
fpus0:  lea   rdi, [fpusv0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; fprgs0 - Save area for x87 registers - 16 quads in extent

head    "fprgs0", saco
fprgs:  dq  fprg0
textm
fprg0:  lea   rdi, [fprgs0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; sysvar0 - Address of the System Variable table.

head    "sysvar0", saco
sysv:   dq  sysv0
textm
sysv0:  lea   rdi, [sysvar0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; System numeric constants - Constants are pushed to the stack when invoked.

; stksz - Size of data stack

head    "dstksz", snco
dstsz:  dq  dssz0
textm
dssz0:  sub   r14, 8
        mov   qword[r14], dstksz*8
        nextm
datam

; rstksz - Size of return stack

head    "rstksz", snco
rstsz:  dq  rssz0
textm
rssz0:  sub   r14, 8
        mov   qword[r14], rstksz*8
        nextm
datam

; nibsz - Size of number input buffer

head    "nibsz", snco
nisz:   dq  nisz0
textm
nisz0:  sub   r14, 8
        mov   qword[r14], nibsz*8
        nextm
datam

; nobsz - Size of number output buffer

head    "nobsz", snco
nosz:   dq  nosz0
textm
nosz0:  sub   r14, 8
        mov   qword[r14], nobsz*8
        nextm
datam

; hldsz - Size of hold buffer

head    "hldsz", snco
hlsz:   dq  hlsz0
textm
hlsz0:  sub   r14, 8
        mov   qword[r14], hldsz*8
        nextm
datam

; dictsz - Maximum dictionary size

head    "dictsz", snco
dctsz:  dq  dctsz0
textm
dctsz0: sub   r14, 8
        mov   qword[r14], dictsz*8
        nextm
datam

; bic# - Special 2constant to return the two-quad buffer integrity check number

head    "bic#", sdco
bicn:   dq  bicn0
textm
bicn0:  sub   r14, 16
        mov   rax, bicna                ; Get bic# in two parts
        mov   rbx, bicnb
        mov   [r14], rax
        mov   [r14+8], rbx
        nextm
datam

; flbias - The exponent bias for Forthx64 floating-point format numbers

head    "flbias", snco
flbias: dq  fbis0
textm
fbis0:  mov   rdx, 0x3FFFFFFFFFFFFFFF
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; Character constants

; bl - Blank space character.

head    "bl", snco
blsp:   dq  blsp0
textm
blsp0:  sub   r14, 8
        mov   qword[r14], 32
        nextm
datam

; " - Double-quote character. Note: can't be represented enclosed
; in double-quotes in yasm.

head    '"', snco
dbqt:   dq  dbqt0
textm
dbqt0:  sub   r14, 8
        mov   qword[r14], 34
        nextm
datam

; Integer constants

; 0

head    "0", snco
zero:   dq  zero0
textm
zero0:  sub   r14, 8
        mov   qword[r14], 0
        nextm
datam

; 1

head    "1", snco
one:    dq  one0
textm
one0:   sub   r14, 8
        mov   qword[r14], 1
        nextm
datam

; 2

head    "2", snco
two:    dq  two0
textm
two0:   sub   r14, 8
        mov   qword[r14], 2
        nextm
datam

; 3

head    "3", snco
three:  dq  thre0
textm
thre0:  sub   r14, 8
        mov   qword[r14], 3
        nextm
datam

; 4

head    "4", snco
four:   dq  four0
textm
four0:  sub   r14, 8
        mov   qword[r14], 4
        nextm
datam

; 8

head    "8", snco
eight:  dq  eigh0
textm
eigh0:  sub   r14, 8
        mov   qword[r14], 8
        nextm
datam

; -1

head    "-1", snco
mone:   dq  mone0
textm
mone0:  sub   r14, 8
        mov   qword[r14], -1
        nextm
datam

; -2

head    "-2", snco
mtwo:   dq  mtwo0
textm
mtwo0:  sub   r14, 8
        mov   qword[r14], -2
        nextm
datam

; -3

head    "-3", snco
mthr:   dq  mthr0
textm
mthr0:  sub   r14, 8
        mov   qword[r14], -3
        nextm
datam

; -4

head    "-4", snco
mfor:   dq  mfor0
textm
mfor0:  sub   r14, 8
        mov   qword[r14], -4
        nextm
datam

; -8

head    "-8", snco
megt:   dq  megt0
textm
megt0:  sub   r14, 8
        mov   qword[r14], -8
        nextm
datam

; System Variables. The address of the variable is returned as a constant.

; dsp - data-space pointer (ANSI parlance)

head    "dsp", svro
dspo:   dq  cons0,dspo0

; latest

head    "latest", svro
lates:  dq  cons0,ltst0

; context

head    "context", svro
cont:   dq  cons0,cnxt0

; current

head    "current", svro
curr:   dq  cons0,crnt0

; voc-link

head    "voc-link", svro
voclnk: dq  cons0,vlnk0

; csp

head    "csp", svro
cspo:   dq  cons0,cspo0

; newentry

head    "newentry", svro
newe:   dq  cons0,nwnt0

; lastentry - Last entry before new definition.
; Used to restore system after new definition fails
; due to error.

head    "lastentry", svro
lste:   dq  cons0,lstn0

; ctib - Current terminal input buffer

head    "ctib", svro
ctib:   dq  cons0,ctmb0

; ntibs - Number of terminal input buffers

head    "ntibs", svro
ntib:   dq  cons0,ntib0

; cfib - Current file input buffer

head    "cfib", svro
cfib:   dq  cons0,cflb0

; nfibs - Number of file input buffers

head    "nfibs", svro
nfib:   dq  cons0,nfib0

; file-link

head    "file-link", svro
flnk:   dq  cons0,flnk0

; buffer-link

head    "buffer-link", svro
bulk:   dq  cons0,bulk0

; obj-link

head    "obj-link", svro
objlnk: dq  cons0,oblk0

; code-link

head    "code-link", svro
cdelnk: dq  cons0,cdlk0

; err-link

head    "err-link", svro
errlnk: dq  cons0,emlk0

; handler

head    "handler", svro
hndlr:  dq  cons0,hndl0

; jmpreg - Used by throw to save the CFA of the operator
; in which the error occured.

head    "jmpreg", svro
jpreg:  dq  cons0,jmpr0

; addrerr - Address where address error occured.

head    "addrerr", svro
adrer:  dq  cons0,ader0

; fpumsk - Floating-point exception mask for x87 FPU

head    "fpumsk", svro
fpumsk: dq  cons0,fmsk0

; ssemsk - Floating-point exception mask for SSE instructions

head    "ssemsk", svro
ssemsk: dq  cons0,smsk0

; asctbl

head    "asctbl", svro
asctbl: dq  cons0,asct0

; hextbl

head    "hextbl", svro
hextbl: dq  cons0,hext0

; dlmtbl

head    "dlmtbl", svro
dlmtbl: dq  cons0,dlmt0

; pathtbl

head    "pathtbl", svro
pthtbl: dq  cons0,ptht0

; scratch

head    "scratch", svro
sctch:  dq  cons0,sctc0

; curctl - Location of cursor control variables

head    "curctl", svro
cctl:   dq  cons0,cctl0

; stsbuf - Address of buffer containing file status structure returned
; by file-status.

head    "stsbuf"
stsbuf: dq  cons0,stsb0

; gtod

head    "gtod", svro
gtod:   dq  cons0,gtod0

; System integer variables

; quadsize

head    "qsz", svro
qdsz:   dq  cons0,qdsz0

; base

head    "base", svro
base:   dq  cons0,base0

; pdchr - Character to use for padding in .R

head    "pdchr", svro
pdchr:  dq  cons0,pdch0

; cdlm - Comment delimiter for parsing

head    "cdlm", svro
cdlm:   dq  cons0,cdlm0

; rdigs

head    "rdigs", svro
rdigs:  dq  cons0,rdgs0

; objsz - Object size accumulator

head    "objsz", svro
objsz:  dq  cons0,obsz0

; #hld

head    "#hld", svro
dhld:   dq  cons0,nhld0

; source-id

head    "source-id", svro
srcid:  dq  cons0,scid0

; src - source buffer address

head    "src", svro
xsrc:   dq  cons0,srce0

; bcc - number of characters in source buffer

head    "bcc", svro
xbcc:   dq  cons0,bchc0

; >in - pointer into input buffer used by WORD.
; The behavior of >in has been slightly changed.
; Since words in the terminal input buffer are most often
; separated by a single space, >in will point
; to the next cell after that space. This way,
; more often than not, >in will not have to skip
; leading delimiters.

head    ">in", svro
xtin:   dq  cons0,scin0

; unused - Return the number of bytes of remaining dictionary space.

head    "unused", dcto
unuse:  dq  unus0
textm
unus0:  mov   rdx, [dspo0]              ; Get data space pointer
        lea   rbx, [dsp0]               ; Get initial dsp
        sub   rdx, rbx                  ; Subtract initial dsp
        mov   rcx, dictsz               ; Get # of quads allocated for dictionary
        shl   rcx, 3                    ; Find # of bytes
        sub   rcx, rdx                  ; Subtract number of bytes used
        sub   r14, 8
        mov   [r14], rcx                ; Push to stack
        nextm
datam

; noop - This operator does nothing.

head    "noop", pgmo
noop:   dq  noop0
textm
noop0:  
        nextm
datam

; Standard Dictionary Entries

; Program Control Definitions

; execute  - execute the word whose CFA is on the stack.

head    "execute", pgmo
exec:   dq  exec0
textm
exec0:  mov   r11, [r14]
        add   r14, 8
        jmp   [r11]
datam

; @execute - execute the word whose CFA is contained
;   in the addr passed on the stack

head    "@execute", pgmo
atexec: dq  atxe0
textm
atxe0:  mov   rdi, [r14]
        add   r14, 8
        mov   r11, [rdi]
        jmp   [r11]
datam

; Error processing definitions

; catch - Handle error conditions signaled by throw

head    "catch", ecpo
catch:  dq  ctch0
textm
ctch0:

; Set up to resume with the word following `catch`.

        sub   r15, 8
        mov   [r15], r12
        sub   r15, 8
        mov   [r15], r14                ; Save stack pointer
        mov   rdx, [hndl0]              ; Save previous handler
        sub   r15, 8
        mov   [r15], rdx
        mov   [hndl0], r15              ; Set new handler

; Set up to return to ctch3 if no error.

        lea   r12, [ctch1]

        mov   r11, [r14]                ; EXECUTE
        add   r14, 8
        jmp   [r11]

ctch3:  mov   rdx, [r15]                ; Restore previous handler
        mov   [hndl0], rdx
        add   r15, 8
        add   r15, 8                    ; Drop previous stack pointer
        sub   r14, 8                    ; Return 0
        xor   rcx, rcx
        mov   [r14], rcx
        mov   r12, [r15]                ; Execute ;s
        add   r15, 8
        nextm
ctch1:  dq    ctch2
ctch2:  dq    ctch3
datam

; High-level catch

; catch - Handle error conditions signaled by throw

; : catch   sp@ >r handler @ >r rp@ handler ! execute
;           r> handler ! r> drop 0 ;

; head    "catch", hlfo
; catch:  dq  docl0
;         dq  spat,tor,hndlr,qat,tor
;         dq  rpat,hndlr,stor,exec
;         dq  fromr,hndlr,stor,fromr
;         dq  drop,zero,semis

; throw

head    "throw", ecpo
throw:  dq  thrw0
textm
thrw0:  lea   rdi, [dstack0]            ; Make sure there is a value
        cmp   rdi, r14                  ; on the stack
        jz    thrw2                     ; Don't throw with empty stack

        cmp   qword[r14], 0             ; Don't throw zero
        jz    thrw1

        mov   r15, [hndl0]              ; Restore saved RSP context
        mov   rdx, [r15]
        add   r15, 8
        mov   [hndl0], rdx              ; Restore previous handler
        mov   rax, [r14]                ; Get exception number
        mov   r14, [r15]                ; before restoring stack pointer
        add   r15, 8
        mov   [jmpr0], r11              ; Save jump register
        sub   r14,8                     ; Push exception number
        mov   [r14], rax
        jmp   thrw2                     ; Exit

thrw1:  add   r14, 8                    ; Pop zero
thrw2:  mov   r12, [r15]                ; Semis
        add   r15, 8
        nextm
datam

; High-level throw

; : throw   ?dup if handler @ rp! r> handler ! r> swap >r sp! drop r> then ;

; head    "throw", hlfo
; throw   dq  docl0
;         dq  dupnz,izbrn,xthro1
;         dq  hndlr,qat,rpsto
;         dq  fromr,hndlr,stor
;         dq  fromr,swp,tor
;         dq  spsto,drop,fromr
; xthro1  dq  semis

; abort - Unconditionally terminate execution, issue "execution aborted"
; message.

; : abort   -1 throw ;

head    "abort", hlfo
abort:  dq  docl0
        dq  mone,throw,semis

; abort" ( flag --- ) If flag is true, set up to issue enclosed error message
; and throw -2.

head    'abort"', -hlfo
abortq: dq  docl0
        dq  pcomp,pabtq,dbqt,csword,drop,semis
pabtq:  dq  pabq0
textm
pabq0:  mov   rbx, [r12]                ; Get string length
        add   r12, 8                    ; Offset past length
        mov   rsi, r12                  ; Save string address
        mov   rcx, rbx                  ; Make two copies of length
        mov   rax, rbx
        and   rax, 7                    ; See if there are pad bytes
        jz    pabq1                     ; Branch if not
        neg   rax                       ; Calculate number of pad bytes
        add   rax, 8
        add   r12, rax
pabq1:  add   r12, rbx                  ; Add string length

        add   r14, 8                    ; Pop the stack
        cmp   qword[r14-8], 0           ; See if entry was zero
        jz    pabq3                     ; Do nothing if so

        lea   rdi, [abtq0]              ; Get address of msg buffer
        mov   [rdi], rcx                ; Put length in msg buffer
        add   rdi, 8                    ; Advance pointer
pabq2:  mov   bl, [rsi+rcx-1]           ; Move message to special buffer
        mov   [rdi+rcx-1], bl
        sub   rcx, 1
        jnz   pabq2

        throwm -2                       ; Throw abort"

pabq3:  nextm
datam

; finderr - ( msg# --- addr ) Chain through error message list until
;          passed message number is found and return the message
;          address.

head    "finderr", ecpo
fnderr: dq  ferr0
textm
ferr0:  mov   rdx, [r14]                ; Get message number
        mov   rdi, [emlk0]              ; Get first message link
ferr1:  cmp   qword[rdi], 0             ; Test for zero link
        jz    ferr2                     ; Last message in list
        cmp   [rdi+24], rdx             ; Compare message numbers
        jz    ferr2                     ; Branch on match
        mov   rdi, [rdi]                ; Get previous link
        jmp   ferr1                     ; Loop

ferr2:  add   rdi, 32                   ; Offset to counted string
        mov   [r14], rdi                ; Put message address on stack
        nextm
datam

; errout - ( n --- ) Write error message associated with #n.

head    "errout", hlfo
errout: dq  docl0
        dq  fnderr,count,strout,semis

; itperr - ( n --- )  Error handler for `interpret`.
; If a colon definition is in progress, clear the :C; flag, reset newentry,
; and set the dictionary pointer to this address. Clear the `also` flag
; in case there was an error in naming a vocabulary. Single out special
; cases of address error and non-unique entry. Output the message associated
; with the number on the stack.
; Special error conditions are as follows:


; 133, "floating-point exception: "
;  63, "is not a valid address"
;  59, "OS interface error: "
;   4, "definition not unique"
;   1, "not found"

head    "itperr", hlfo
itperr: dq  docl0
        pdtqm " error: "
        dq  dupl,lit,63,equal,zbran,ierr1
        dq  adrer,qat,udot,bran,ierr3
ierr1:  dq  dupl,four,equal,zbran,ierr2
        dq  swp,cftnf,dtnam,bran,ierr4
ierr2:  dq  dupl,one,equal,zbran,ierr3
        dq  lates,qat,count,strout,space
ierr3:  dq  qcol,zbran,ierr4
        dq  endcol,rsetdp
ierr4:  dq  rsalso,dupl,errout
        dq  dupl,lit,59,equal,zbran,ierr5
        dq  syser,bran,ierr6
ierr5:  dq  lit,133,equal,zbran,ierr6
        dq  fperr,fpeen
ierr6:  dq  cr,semis

; msgerr - ( n --- )  Error handler for `msgout`.
; Ordinarily an error can't happen with `msgout`, but since it is a radio,
; routines may be added which can result in errors. Notably `.fpstk`.
; This is added by FPUmath.asm, and can cause an error if a floating-point
; stack entry can't be represented in the current quadsize.
; Consequently this error handler is defined as a defer, whose default
; behavior is to do nothing. The FPUmath.asm module will then set this defer
; to handle possible output errors due to `.fpstk`.

head    "msgerr", dfro
msgerr: dq  ddfr0
        dq  noop

; ?stack - ( --- ) Check the stack for underrun or overrun and issue
; the appropriate error message for either condition. Else do nothing.

head    "?stack", ecpo
qstac:  dq  qstc0
textm
qstc0:  lea   rdx, [dstack0]            ; Get initial stack pointer
        cmp   rdx, r14                  ; Check for underrun
        jnc   qstc1

        throwm 2

qstc1:  cmp   r14, [rdx-rstksz*8]       ; Check for overrun
        jnc   qstc2                     ; Exit if no overrun

        throwm 3

qstc2:  nextm
datam

; ckstk - ( n --- ) - Check if there are at least n items on the stack
; and throw an error if not.

head    "ckstk", ecpo
ckstk:  dq  cstk0
textm
cstk0:  mov   rcx, [r14]                ; Get item count
        add   r14, 8                    ; Pop stack
        lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to quads
        cmp   rdi, rcx                  ; Compare items needed
        jnc   cstk1

        throwm 69

cstk1:  nextm
datam

; check-buffers - Perform buffer integrity check. Throw appropriate error
; if buffer integrity violated, or return stack has overflowed.

head    "check-buffers", ecpo
ckbufs: dq  cbfs0
textm
cbfs0:  mov   rax, bicna                ; Get bic# in two parts
        mov   rbx, bicnb

; Check nib, nob, hld, and return stack.

        lea   rdi, [nob0-16]            ; Check nib
        cmp   [rdi], rax
        jnz   cnib1

        cmp   [rdi+8], rbx
        jz    cnob1

cnib1:  throwm 84

cnob1:  lea   rdi, [hld0-16]            ; Check nob
        cmp   [rdi], rax
        jnz   cnob2

        cmp   [rdi+8], rbx
        jz    chld1

cnob2:  throwm 85

; Note that the bic# for hld is placed at the boundary between the hld
; buffer and the return stack, and since the return stack grows in the
; opposition direction, a problem with either will throw the same error.

chld1:  lea   rdi, [rstack0-rstksz*8-16]  ; Check hld and return stack
        cmp   [rdi], rax
        jnz   chld2

        cmp   [rdi+8], rbx
        jz    ckip1

chld2:  throwm 86

; Check keyboard input pre-buffer.

ckip1:  lea   rdi, [kip0]               ; Load kip0
        mov   rdx, [rdi-16]             ; Get buffer capacity
        cmp   [rdi+rdx], rax            ; Compare 1st quad
        jnz   ckip2                     ; Throw if no match

        cmp   [rdi+rdx+8], rbx          ; Compare 2nd quad
        jz    caxb1                     ; Branch if match

ckip2:  throwm 83

; Check auxiliary buffer.

caxb1:  lea   rdi, [axb0]               ; Load axb0
        mov   rdx, [rdi-16]             ; Get buffer capacity
        cmp   [rdi+rdx], rax            ; Compare 1st quad
        jnz   caxb2                     ; Throw if no match

        cmp   [rdi+rdx+8], rbx          ; Compare 2nd quad
        jz    ctbs1                     ; Branch if match

caxb2:  throwm 81

; Check terminal input buffers.

ctbs1:  lea   rdi, [tib0]               ; Load tib0
        mov   rsi, rdi                  ; Make copy
ctbs2:  mov   rdx, [rdi-16]             ; Get buffer capacity
        cmp   [rdi+rdx], rax            ; Compare 1st quad
        jnz   ctbs3                     ; Throw if no match
        cmp   [rdi+rdx+8], rbx          ; Compare 2nd quad
        jnz   ctbs3                     ; Throw if no match
        mov   rdi, [rdi-56]             ; Get next buffer address
        cmp   rdi, rsi                  ; See if back to beginning
        jz    cfbs1                     ; Go check file input buffers
        jmp   ctbs2                     ; Loop

ctbs3: throwm 79

; Check file input buffers.

cfbs1:  lea   rdi, [fib0]               ; Load fib0
cfbs2:  mov   rdx, [rdi-16]             ; Get buffer capacity
        cmp   [rdi+rdx], rax            ; Compare 1st quad
        jnz   cfbs3                     ; Throw if no match
        cmp   [rdi+rdx+8], rbx          ; Compare 2nd quad
        jnz   cfbs3                     ; Throw if no match
        mov   rdi, [rdi-48]             ; Get next buffer address
        cmp   rdi, 0                    ; See if link is zero
        jz    cubs1                     ; Check user buffers
        jmp   cfbs2                     ; Loop

cfbs3: throwm 80

; Check user buffers.

cubs1:  mov   rdi, [bulk0]              ; Get buffer-link
        cmp   rdi, 0                    ; Check for zero link
        jz    cbfs1                     ; Nothing to do if link is zero

; Note that the capacity of user buffers is not required to be an even multiple
; of 8 bytes, while the size allocated will still be so.

cubs2:  mov   rdx, [rdi-16]             ; Get buffer capacity
        mov   rcx, rdx                  ; Make copy
        and   rcx, 7                    ; See how much to add
        jz    cubs3                     ; Branch if no bytes to add
        neg   rcx
        add   rcx, 8
        add   rdx, rcx

cubs3:  cmp   [rdi+rdx], rax            ; Compare 1st quad
        jnz   cubs4                     ; Throw if no match
        cmp   [rdi+rdx+8], rbx          ; Compare 2nd quad
        jnz   cubs4                     ; Throw if no match
        mov   rdi, [rdi]                ; Get next link
        cmp   rdi, 0                    ; See if link is zero
        jz    cbfs1                     ; Exit if so
        jmp   cubs2                     ; Else loop

cubs4:  throwm 82

cbfs1:  nextm
datam

; rp@ - Get current value of return stack pointer.

head    "rp@", stqo
rpat:   dq  rpat0
textm
rpat0:  sub   r14, 8
        mov   [r14], r15
        nextm
datam

; rp! - Set return stack pointer to value on top of data stack.

head    "rp!", stco, hidden
rpsto:  dq  rpst0
textm
rpst0:  mov   r15, [r14]
        add   r14, 8
        nextm
datam

; rprst - Reset return stack pointer for `quit`. In order not to obliterate
; the stack frame created by the `catch` in `start` the 1st two cells must
; be preserved.

head    "rprst", stco, hidden
rprst:  dq  rprs0
textm
rprs0:  lea   r15, [rstack0]
        sub   r15, 16
        nextm
datam

; sp@ - Get current value of data stack pointer.

head    "sp@", stqo
spat:   dq  spat0
textm
spat0:  mov   rdx, r14
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; sp! - Set data stack pointer to value on top of stack.

head    "sp!", stco, hidden
spsto:  dq  spst0
textm
spst0:  mov   r14, [r14]
        nextm
datam

; sprst - Reset data stack pointer.

head    "sprst", stco, hidden
sprst:  dq  sprs0
textm
sprs0:  lea   r14, [dstack0]
        nextm
datam

; ap@ - Get current value of auxiliary stack pointer.

head    "ap@", stqo
apat:   dq  apat0
textm
apat0:  sub   r14, 8
        mov   [r14], r13
        nextm
datam

; ap! - Set auxiliary stack pointer to value on top of data stack.

head    "ap!", stco, hidden
apsto:  dq  apst0
textm
apst0:  mov   r13, [r14]
        add   r14, 8
        nextm
datam

; pastk - Toggle the error checking and handling flag #8 to tell `aprst`
; whether to preserve the auxiliary stack across exceptions. If flag
; #8 is clear (the default) the auxiliary stack will be reset whenever
; the data stack is reset. When #8 is set, the stack will only be
; reset by `start` itself, which means only when Forthx64 is restarted.
; This can be valuable for debugging.

head    "pastk", stco
pastk:  dq  pstk0
textm
pstk0:  btc   qword[flgs0], 8
        nextm
datam

; aprst - Reset auxiliary stack pointer. Unlike, the data stack,
; the auxiliary stack may be made persistent by setting system flag #8.
; Therefore `aprst` only resets the stack pointer if the flag is clear.

head    "aprst", stco, hidden
aprst:  dq  aprs0
textm
aprs0:  bt    qword[flgs0], 8
        jc    aprs1

        lea   r13, [astack0]

aprs1:  nextm
datam

; Outer interpreter definitions

; source ( --- addr n ) Return the address of the input buffer and the number
; of characters it contains.

head    "source", stco
srcat:  dq  scat0
textm
scat0:  mov   rdx, [srce0]              ; Get buffer address
        mov   rcx, [bchc0]              ; Get number of characters in buffer
        sub   r14, 16                   ; Make room on stack
        mov   [r14+8], rdx              ; Put buffer address on stack
        mov   [r14], rcx                ; Put character count on stack
        nextm
datam

; source! ( addr n --- ) Store the address of the input buffer and the number
; of characters it contains in src.

head    "source!", stco
srcst:  dq  scst0
textm
scst0:  mov   rdx, [r14]                ; Get character count
        mov   rcx, [r14+8]              ; Get buffer address
        add   r14, 16                   ; Pop stack
        mov   [bchc0], rdx              ; Store character count
        mov   [srce0], rcx              ; Store buffer address
        nextm
datam

; quit - Initialize the data stack, load the startup file if it has not already
; been loaded, and enter the terminal interpret loop.

head    "quit", hlfo
quit:   dq  docl0
xxa1:   dq  rprst,lbrac
        dq  ifinit,nzbran,xxa2

; If system not initialized, load and interpret startup file.

        dq  strtup,dupl,pathf,swp,dupl
        dq  twfp,qat,swp,ttwp,qat
        dq  creatf,dupl,strtup,eighp,stor

        dq  dupl,toa,nxtfib,dupl,toa
        dq  swp,getfl,froma,aat,srctr
        dq  srcid,stor,dupl,eighm,qat
        dq  lit,inter,catch,srcfr,froma,closef
        dq  prvfib,bran,xxa3

; If system initialized, receive input from terminal and enter interpret loop.

xxa2:   dq  strin,space,srcat,lit,inter,catch
xxa3:   dq  dupnz,zbran,xxa5
        dq  dupl,mtwo,zero,withn,zbran,xxa4

; Rethrow -1 and -2 to `start`.

        dq  throw

xxa4:   dq  itperr
        dq  sprst,aprst,bran,xxa7
xxa5:   dq  stat,zbran,xxa6
        dq  qcol,zbran,xxa7
        dq  endcol,rsetdp,eight,bran,xxa4
xxa6:   dq  lit,msgout,catch
        dq  cr,dupnz,zbran,xxa7
        dq  msgerr,cr,sprst,aprst
xxa7:   dq  rstfbs,bran,xxa1,semis

; interpret - Begin interpretation until the input stream is exhaused
; or an error occurs.

head    "interpret", hlfo
inter:  dq  docl0
        dq  srcst,zero,xtin,stor
xxb1:   dq  dctwrd,dupl,qat,zbran,xxb6
        dq  pfind,dupnz,zbran,xxb4
        dq  zless,stat,andf,zbran,xxb2
        dq  comma,bran,xxb3
xxb2:   dq  exec
xxb3:   dq  qstac,bran,xxb1
xxb4:   dq  count,nibn,swp,tnumb
        dq  stat,zbran,xxb5
        dq  lites,qstac,bran,xxb1
xxb5:   dq  drop,qstac,bran,xxb1
xxb6:   dq  drop,ckbufs,semis

; evaluate - ( i*x c-addr u --- j*x )

; : evaluate   src>r -1 source-id ! [']
;              interpret catch r>src throw ;

head    "evaluate", hlfo
eval:   dq  docl0
        dq  srctr
        dq  mone,srcid,stor
        dq  lit,inter,catch
        dq  srcfr,throw,semis

; include-file - ( fileid --- ) Load and interpret the file whose fileid
; is passed on the stack. The availability of the fileid implies that the
; file is already open when include-file is invoked.

; : include-file   dup >a next-fib dup >a swap getfile a> a@ src>r source-id
;                  ! dup 8- @ ['] interpret catch srcr> a> close-file
;                  prev-fib throw       ;

head    "include-file", hlfo
inclf:  dq  docl0
        dq  dupl,toa,nxtfib
        dq  dupl,toa,swp,getfl
        dq  froma,aat,srctr
        dq  srcid,stor
        dq  dupl,eighm,qat
        dq  lit,inter,catch
        dq  srcfr,froma,closef
        dq  prvfib,throw,semis

; included - ( c-addr --- ) Load and interpret the file whose pathname
; is at c-addr.

; : included   r/o openf dup >a next-fib dup >a swap getfile a> a@ src>r
;              source-id ! dup 8- @ ['] interpret catch srcr> a> close-file
;              prev-fib throw ;

head    "included", hlfo
incldd: dq  docl0
        dq  rdonly,openf
        dq  dupl,toa,nxtfib
        dq  dupl,toa,swp,getfl
        dq  froma,aat,srctr
        dq  srcid,stor
        dq  dupl,eighm,qat
        dq  lit,inter,catch
        dq  srcfr,froma,closef
        dq  prvfib,throw,semis

; include <filename> Load and interpret the file whose pathname follows
; in the input stream.

; : include   axb0 bufword r/o openf dup >a next-fib dup >a swap
;             getfile a> a@ src>r source-id ! dup 8- @ ['] interpret
;             catch srcr> a> close-file prev-fib throw ;

head    "include", hlfo
includ: dq  docl0
        dq  axbn,bufwrd
        dq  rdonly,openf
        dq  dupl,toa,nxtfib
        dq  dupl,toa,swp,getfl
        dq  froma,aat,srctr
        dq  srcid,stor
        dq  dupl,eighm,qat
        dq  lit,inter,catch
        dq  srcfr,froma,closef
        dq  prvfib,throw,semis

; bin - Set number base to binary

head    "bin"
bin:    dq  bin0
textm
bin0:   mov qword[base0], 2
        nextm
datam

; oct - Set number base to octal
head    "oct"
oct:    dq  oct0
textm
oct0:   mov qword[base0], 8
        nextm
datam

; dec - Set number base to decimal

head    "dec"
deci:   dq  deci0
textm
deci0:  mov qword[base0], 10
        nextm
datam

; decimal - ANSI Standard synonym for dec

; : decimal   dec ;

head    "decimal", hlfo
decml:  dq  docl0
        dq  deci,semis

; duodec - Set number base to duodecimal

head    "duodec"
duodec: dq  dudc0
textm
dudc0:  mov qword[base0], 12
        nextm
datam

; hex - Set number base to hexadecimal

head    "hex"
hex:    dq  hex0
textm
hex0:   mov qword[base0], 16
        nextm
datam

; ascii>bsn - Convert an ASCII string at address to a byte-string number.
; The return address for leaf functions is in rbp.
; Stack: source-addr destination-addr char-count ---
;                    destination-addr | source-addr char-count 0
;
; Zero denominator will throw 30.
;
; The caret symbol ^ stands for the sequence (* base ^ exponent). In decimal,
; 2^3 means 2*10^3 and 1.4^-2 means 1.4*10^-2.
; Be aware that 0^0 means 0x10^0, and therefore it should be interpreted as
; floating-point 0. As should 0.^0, 0.0^0, and .0^0 . Zero to any exponent is
; floating-point zero.

; Examples of floating-point numbers:

;           1.23445^3    1^4    ABDC.1ECD^A  -17.86^-5    -3^-7

; This version uses the following byte-string format:
;
; |       0       |      8      |     16      |     24      |         32
; | object length | object type | number type | number base | length of 1st string |
;
; | string | length of second string | string | length of third string | string

; The second and third string length quads may occur at odd boundaries, but the
; entire bsn will be padded to an 8-byte boundary.
; The first length quad carries the sign of the number, and the third length
; quad carries the sign of the exponent in the case of a floating-point number.
; The format for zero is the same for all number types:
;
; |      0        |      8      |     16      |     24      | 32  |
; | object length | object type | number type | number base |  0  |
;
; Number types are as follows:
;
; 1 - single precision integer
; 2 - multiprecision integer
; 3 - real number
; 4 - rational number
; 5 - floating-point number

; Rstack frame usage:

;  [r15+24] - r11
;  [r15+16] - r10
;  [r15+8]  - flags
;  [r15]    - temporary
;
; Register usage
;
;    r11 - base address of number input filter
;    r10 - base address of bsn object
;    r9  - address of current bsn string length cell
;    r8  - current number base
;    rbp - return address for leaf functions
;    rdi - bsn string pointer
;    rsi - ascii string source pointer
;    rdx - output digit count
;    rcx - input character count
;    rbx - input character register
;    rax - number input filter entry
;
; Flags
;
;    r15+8 bit #0 - negative number flag
;    r15+8 bit #1 - negative exponent flag
;    r15+8 bit #2 - zero integer/numerator flag
;    r15+8 bit #3 - zero mantissa flag

head    "ascii>bsn",nbco,hidden
asbsn:  dq  asbs0
textm
asbs0:  sub   r15, 16                   ; Create rstack frame
        mov   qword[r15+8], 0           ; Zero flags quad
        mov   rcx, [r14]                ; Get char count
        mov   rdi, [r14+8]              ; Get destination address
        mov   r10, rdi                  ; Save for base addr of bsn
        mov   rsi, [r14+16]             ; Get source address
        lea   r11, [nif0]               ; Get base addr of number input filter
        mov   r8, [base0]               ; Get number base
        mov   qword[r10], 40            ; Initialize bsn length to 40 bytes
        mov   qword[r10+8], bsno        ; Install object type for bsn
        mov   [r10+24], r8              ; Install number base in bsn
        lea   r9, [rdi+32]              ; Set pointer to 1st bsn string length
        lea   rdi, [rdi+40]             ; Set destination pointer to 1st bsn string
        cmp   byte[rsi], 43             ; Test for +
        jz    asbs1                     ; Ignore + if present
        cmp   byte[rsi], 45             ; Test for minus sign
        jnz   asbs2                     ; Branch if no minus sign
        bts   qword[r15+8], 0           ; Else set negative number flag
asbs1:  add   rsi, 1                    ; Advance char pointer
        sub   rcx, 1                    ; Decrement char count
        jz    asbs35                    ; Not valid if no other characters

asbs2:  lea   rbp, [asbs3]              ; Set return address
        jmp   slzs0                     ; Convert digits until next delimiter

; If character register contains 0, invalid character was encountered.

asbs3:  cmp   rbx, 0                    ; See if digit register contains 0
        jz    asbs35                    ; If so, number not valid

        cmp   rax, -1                   ; See if special character encountered
        jz    asbs5                     ; Branch if so

; If no special character was encountered, number is spi.

        mov   qword[r10+16], 1          ; Set number type to spi

        test  rdx, rdx                  ; See if there were non-zero digits
        jnz   asbs4                     ; Branch if so

; If there were no non-zero digits, number is spi 0.

        mov   qword[r9], 0              ; Install zero digit count
        jmp   asbs36                    ; Exit with success

asbs4:  mov   [r9], rdx                 ; Install digit count
        add   [r10], rdx                ; Add digit count to bsn size
        jmp   asbs32                    ; Go pad bsn

; If special character encountered, check for non-zero digits.

asbs5:  test  rdx, rdx                  ; See if there were non-zero digits processed
        jnz   asbs10                    ; Branch if so

; If there were no non-zero digits processed, the special character may be the
; radix, the slash in the case of rational zero, or the caret in the case of
; floating-point zero.

; Test for radix.

        cmp   rbx, 46                   ; See if radix encountered
        jnz   asbs8                     ; Branch if not

; If the radix was encountered, the number may be multiprecision 0,
; the special case of 0.^e, real with no integer part, or floating
; point with no integer part.

        cmp   rcx, 1                    ; See if character count is 1
        jnz   asbs6                     ; Branch if not

; Number is multiprecision 0.

        mov   qword[r10+16], 2          ; Set number type to mpi
        mov   qword[r9], 0              ; Install zero digit count
        jmp   asbs36                    ; Exit with success

; Check for special case of 0.^exp.

asbs6:  cmp   byte[rsi+1], 94           ; Check for caret following radix
        jnz   asbs7                     ; Branch if none

; If there is a caret, the number may be floating-point with a 0 integer part
; and no fractional part. But note that we have to verify that the 1st digit
; is actually 0 and that the user has not entered an invalid exponent.

        cmp   [r14], rcx                ; Test if radix was first character encountered
        jz    asbs35                    ; Not valid if so

        mov   qword[r10+16], 5          ; Set number type to floating-point
        mov   qword[r9], 0              ; Install zero string length
        bts   qword[r15+8], 3           ; Set zero mantissa flag
        add   r9, 8                     ; Advance pointer past length field
        add   rsi, 2                    ; Advance source pointer past radix and caret
        sub   rcx, 2                    ; Decrement character count
        jz    asbs35                    ; Not valid if no other characters
        jmp   asbs25                    ; Go process exponent

; If there is more than one character remaining, the number is real or floating
; point with a zero integer part. The integer length will be tentatively set to
; 1 and the 0 digit installed, but the bsn size won't be adjusted until we have
; determined whether the number is zero.

asbs7:  bts   qword[r15+8], 2           ; Set zero integer flag
        mov   qword[r9], 1              ; Install digit count
        add   r9, 8                     ; Advance pointer to 1st string
        mov   byte[r9], 0               ; Install zero digit
        add   r9, 1                     ; Advance pointer to 2nd string length field
        add   rdi, 9                    ; Advance destination pointer to 2nd string field
        add   rsi, 1                    ; Advance source pointer past radix
        sub   rcx, 1                    ; Decrement character count
        jz    asbs35                    ; Not valid if no other characters

        jmp   asbs12                    ; Go process fraction

; Test for slash.

asbs8:  cmp   rbx, 47                   ; See if slash encountered
        jnz   asbs9                     ; Branch if not

; If the slash was encountered, it cannot be the first character.
; It must be preceeded by at least one 0.

        cmp   [r14], rcx                ; Test if slash was first character encountered
        jz    asbs35                    ; If so, number is not valid

        mov   qword[r10+16], 4          ; Set number type to rational
        mov   qword[r9], 0              ; Install zero digit count
        bts   qword[r15+8], 2           ; Set zero numerator flag
        add   r9, 8                     ; Advance pointer to 1st string
        add   rsi, 1                    ; Advance source pointer past slash
        sub   rcx, 1                    ; Decrement character count
        jz    asbs35                    ; Not valid if no other characters

        jmp   asbs21                    ; Go process denominator

; Test for caret.

asbs9:  cmp   rbx, 94                   ; See if caret encountered
        jnz   asbs7                     ; Branch if not

; If the caret was encountered, it cannot be the first character.
; It must be preceeded by at least one 0.

        cmp   [r14], rcx                ; Test if caret was first character encountered
        jz    asbs35                    ; If so, number is not valid

        mov   qword[r10+16], 5          ; Set number type to floating-point
        mov   qword[r9], 0              ; Install zero digit count
        bts   qword[r15+8], 3           ; Set zero mantissa flag
        add   r9, 8                     ; Advance pointer to 1st string
        add   rsi, 1                    ; Advance source pointer past caret
        sub   rcx, 1                    ; Decrement character count
        jz    asbs35                    ; Not valid if no other characters

        jmp   asbs25                    ; Go process exponent

; If special character encountered and there were non-zero digits, number may be
; multiprecision integer, real, rational, or floating-point.

; Test for radix.

asbs10: cmp   rbx, 46                   ; See if radix encountered
        jnz   asbs20                    ; Branch if not

; If character count is 1, the radix is the last character, and the number is a
; multiprecision integer.

        cmp   rcx, 1                    ; See if character count is 1
        jnz   asbs11

        mov   qword[r10+16], 2          ; Set number type to mpi
        mov   [r9], rdx                 ; Install digit count
        add   [r10], rdx                ; Add 1st string count to bsn size
        jmp   asbs32                    ; Go pad bsn

; If radix is not the last character, number is real or floating-point.

asbs11: mov   [r9], rdx                 ; Install digit count
        add   [r10], rdx                ; Add 1st string count to bsn size
        add   r9, 8                     ; Advance pointer to 1st string
        add   r9, rdx                   ; Advance pointer to 2nd string length field
        add   rdi, 8                    ; Advance destination pointer to 2nd string field
        add   rsi, 1                    ; Advance source pointer past radix
        sub   rcx, 1                    ; Decrement character count
        jz    asbs35                    ; Not valid if no other characters

; Process fraction.

asbs12: lea   rbp, [asbs13]             ; Set return address
        jmp   plzs0                     ; Process fractional part

; If character register contains 0, invalid character was encountered.

asbs13: cmp   rbx, 0                    ; See if digit register contains 0
        jz    asbs35                    ; If so, number not valid

; If nif register is negative, go test for caret.

        cmp   rax, -1                   ; See if nif entry is negative
        jz    asbs17

; If character count not exhausted, number is not valid

        cmp   rcx, 0                    ; See if character count exhausted
        jnz   asbs35                    ; If not, number is not valid

; At this point, it is clear that the number type is real.

        mov   qword[r10+16], 3          ; Set number type to real

        cmp   rdx, 0                    ; See if there were non-zero digits
        jnz   asbs15                    ; Branch if so

; If there were no non-zero digits, test zero integer flag, and if it is
; set, install zero in 1st string length field, but leave flag set in case
; negative number flag has been set.

        bt    qword[r15+8], 2           ; Test zero integer flag
        jnc   asbs14                    ; Branch if flag is clear

        mov   qword[r10+32], 0          ; Set 1st string length to zero
        jmp   asbs36                    ; Exit with success

asbs14: mov   qword[r9], 1              ; Install 1 for length of 2nd string
        add   r9, 8                     ; Advance to 2nd string field
        mov   byte[r9], 0               ; Install fraction digit
        add   rdi, 1                    ; Advance destination pointer
        add   qword[r10], 9             ; Add string length and length quad to bsn size
        jmp   asbs32                    ; Go pad bsn

asbs15: btr   qword[r15+8], 2           ; Test/clear zero integer flag
        jnc   asbs16                    ; Branch if flag was clear

        add   qword[r10], 9             ; Add 1st string length quad and digit to bsn size

asbs16: mov   [r9], rdx                 ; Install 2nd string length
        add   [r10], rdx                ; Add 2nd string length to bsn size
        add   qword[r10], 8             ; Add 2nd string length quad to bsn size
        jmp   asbs32                    ; Go pad bsn

; If caret encountered, number is floating-point.

asbs17: cmp   rbx, 94                   ; See if caret encountered
        jnz   asbs35                    ; Nothing else is valid

        mov   qword[r10+16], 5          ; Set number type to floating-point
        cmp   rdx, 0                    ; See if there were non-zero digits
        jnz   asbs19                    ; Branch if so

; If there were no non-zero digits, test zero integer flag, and if it is
; set, install zero in 1st string length field, but leave flag set in case
; negative number flag has been set.

        bt    qword[r15+8], 2           ; Test zero integer flag
        jnc   asbs18                    ; Branch if flag is clear

        bts   qword[r15+8], 3           ; Set zero mantissa flag
        mov   qword[r10+32], 0          ; Set 1st string length to zero
        jmp   asbs36                    ; Exit with success

asbs18: btr   qword[r15+8], 2           ; Clear zero integer flag
        mov   qword[r9], 1              ; Set 2nd string length to 1
        add   r9, 8                     ; Advance to 2nd string
        mov   byte[r9], 0               ; Install fraction digit
        add   qword[r10], 9             ; Add length quad and digit to bsn size
        add   r9, 1                     ; Advance to 3rd string length field
        add   rdi, 9                    ; Advance destination pointer to 3rd string field
        add   rsi, 1                    ; Advance source pointer past caret
        sub   rcx, 1                    ; Decrement character count
        jz    asbs35                    ; Not valid if no other characters

        jmp   asbs25                    ; Go process exponent

; If the zero integer flag is not cleared here, the floating-point number won't
; be negated if it is negative and has a zero integer part.

asbs19: btr   qword[r15+8], 2           ; Clear zero integer flag
        mov   [r9], rdx                 ; Install 2nd string length
        add   [r10], rdx                ; Add 2nd string length to bsn size
        add   qword[r10], 8             ; Add 2nd string length quad to bsn size
        add   r9, 8                     ; Advance pointer to 2nd string
        add   r9, rdx                   ; Advance pointer to 3rd string length field
        add   rdi, 8                    ; Advance destination pointer to 3rd string field
        add   rsi, 1                    ; Advance source pointer past caret
        sub   rcx, 1                    ; Decrement character count
        jz    asbs35                    ; Not valid if no other characters

        jmp   asbs25                    ; Go process exponent

; Test for slash.

asbs20: cmp   rbx, 47                   ; See if slash encountered
        jnz   asbs23                    ; Branch if not

        mov   qword[r10+16], 4          ; Set number type to rational
        mov   [r9], rdx                 ; Install digit count
        add   [r10], rdx                ; Add 1st string count to bsn size
        add   r9, 8                     ; Advance pointer to 1st string
        add   r9, rdx                   ; Advance pointer to 2nd string length field
        add   rdi, 8                    ; Advance destination pointer to 2nd string field
        add   rsi, 1                    ; Advance source pointer past slash
        sub   rcx, 1                    ; Decrement character count
        jz    asbs35                    ; Not valid if no other characters

asbs21: lea   rbp, [asbs22]             ; Set return address
        jmp   slzs0                     ; Process denominator

; If character register contains 0, invalid character was encountered.

asbs22: cmp   rbx, 0                    ; See if digit register contains 0
        jz    asbs35                    ; If so, number not valid

; If nif register is negative, number is not valid

        cmp   rax, -1                   ; See if nif entry is negative
        jz    asbs35                    ; If so, number not valid

; If character count not exhausted, number is not valid

        cmp   rcx, 0                    ; See if character count exhausted
        jnz   asbs35                    ; If not, number is not valid

; If no non-zero digit encountered, denominator is zero. Throw error 30.

        test  rdx, rdx                  ; See if there were non-zero digits
        jz    asbs31                    ; Error if not

        btr   qword[r15+8], 2           ; Test/clear zero numerator flag
        jc    asbs36                    ; Finish if flag was set

        mov   [r9], rdx                 ; Install 2nd string length
        add   [r10], rdx                ; Add 2nd string length to bsn size
        add   qword[r10], 8             ; Add 2nd string length quad to bsn size
        jmp   asbs32                    ; Go pad bsn

; Test for caret

asbs23: cmp   rbx, 94                   ; See if special character is the caret
        jnz   asbs35                    ; Nothing else is valid

; At this point the integer part has been processed, but the fractional part
; of the floating-point number is only implied, so a single 0 is supplied
; for the fraction.

        mov   qword[r10+16], 5          ; Set number type to floating-point
        mov   [r9], rdx                 ; Install digit count
        add   [r10], rdx                ; Add 1st string count to bsn size
        add   r9, 8                     ; Advance pointer to 1st string
        add   r9, rdx                   ; Advance pointer to 2nd string length field
        mov   qword[r9], 1              ; Install 2nd string length
        add   r9, 8                     ; Advance pointer to 2nd string
        mov   byte[r9], 0               ; Install 0 fraction digit
        add   qword[r10], 9             ; Add 2nd string length and length quad to bsn size
        add   r9, 1                     ; Advance to 3rd string length field
        mov   rdi, r9                   ; Copy to destination pointer
        add   rdi, 8                    ; Advance destination pointer to 3rd string field
        add   rsi, 1                    ; Advance source pointer past caret
        sub   rcx, 1                    ; Decrement character count
        jz    asbs35                    ; Not valid if no other characters

asbs25: cmp   byte[rsi], 43             ; Test for +
        jz    asbs26                    ; Ignore + if present
        cmp   byte[rsi], 45             ; Test for minus sign
        jnz   asbs27                    ; Branch if no minus sign
        bts   qword[r15+8], 1           ; Else set negative exponent flag
asbs26: add   rsi, 1                    ; Advance char pointer
        sub   rcx, 1                    ; Decrement char count
        jz    asbs35                    ; Not valid if no other characters

asbs27: lea   rbp, [asbs28]             ; Set return address
        jmp   slzs0                     ; Process exponent

; If character register contains 0, invalid character was encountered.

asbs28: cmp   rbx, 0                    ; See if digit register contains 0
        jz    asbs35                    ; If so, number not valid

; If nif register is negative, number is not valid

        cmp   rax, -1                   ; See if nif entry is negative
        jz    asbs35                    ; If so, number not valid

; If character count not exhausted, number is not valid

        cmp   rcx, 0                    ; See if character count exhausted
        jnz   asbs35                    ; If not, number is not valid

; If mantissa is zero, finish with zero exponent.

        btr   qword[r15+8], 3           ; Test/clear zero mantissa flag
        jc    asbs36                    ; Finish if flag was set

        test  rdx, rdx                  ; See if there were non-zero digits
        jnz   asbs29                    ; Branch if so

; If there were no non-zero digits, exponent is 0.

        mov   qword[r9], 1              ; Install 3rd string length
        add   r9, 8                     ; Advance to 34rd string field
        mov   byte[r9], 0               ; Install zero digit
        add   qword[r10], 9             ; Add to bsn size
        add   rdi, 1                    ; Advance destination pointer
        jmp   asbs32                    ; Go pad bsn

asbs29: mov   [r9], rdx                 ; Install 3rd string length
        add   [r10], rdx                ; Add 3rd string length to bsn size
        add   qword[r10], 8             ; Add 3rd string length quad to bsn size

        btr   qword[r15+8], 1           ; Test/clear negative exponent flag
        jnc   asbs30                    ; Branch if flag was clear
        neg   qword[r9]                 ; Else negate exponent length

asbs30: jmp   asbs32                    ; Go pad bsn

; Leaf functions

; Leaf function to skip leading zeroes and process digits until counter
; exhausted or invalid character or special character encountered. If no
; non-zero digits encountered, the character count register will be zero on
; exit. If invalid character encountered, character register will be set to 0.
; If special character encountered, its ascii value will be in the character
; register, and -1 will be in the nif entry register.

slzs0:  xor   rdx, rdx                  ; Zero character count register
slzs1:  movzx rbx, byte[rsi]            ; Get first/next char
        movsx rax, byte[r11+rbx]        ; Get nif entry
        test  rax, rax                  ; Test entry
        js    slzs7                     ; Special character if negative
        jnz   slzs3                     ; Branch if not zero
        add   rsi, 1                    ; Increment source pointer
        sub   rcx, 1                    ; Decrement digit counter
        jnz   slzs1                     ; Loop until non-zero or count exhausted

; If loop falls through, there were no non-zero digits.

        jmp   slzs7                     ; Branch to end

slzs2:  movzx rbx, byte[rsi]            ; Get first/next char
        movsx rax, byte[r11+rbx]        ; Get nif entry
        test  rax, rax                  ; Test entry
        js    slzs7                     ; Special character if negative

slzs3:  cmp   rax, r8                   ; Compare digit with base
        jns   slzs6                     ; Not valid if not less
        mov   [rdi], al                 ; Install digit in bsn
        add   rsi, 1                    ; Increment source and
        add   rdi, 1                    ; destination pointers
        add   rdx, 1                    ; Increment character count
        sub   rcx, 1                    ; Decrement digit counter
        jnz   slzs2                     ; Loop until zero

; If loop falls through here, no special character was encountered.

        jmp   slzs7

; If invalid character encountered, set character register to 0.

slzs6:  mov   rbx, 0

slzs7:  jmp   rbp                       ; Return

; Leaf function to process digits with significant leading zeroes until
; counter exhausted or invalid character or special character encountered.
; If no non-zero digits encountered, the character count register will be clear.
; If invalid character encountered, character register will be set to 0.
; If special character encountered, its ascii value will be in the character
; register, and -1 will be in the nif entry register.

; This version checks for and keeps a count of leading zeroes until a non-zero
; digit is found. If a non-zero digit is encountered, it installs the counted
; number of leading zeroes, then the non-zero digit, and continues processing
; digits. If no non-zero digits are found, or a special character is found
; before any non-zero digits, it sets the character count register to zero.

plzs0:  xor   rdx, rdx                  ; Zero character count register

plzs1:  movzx rbx, byte[rsi]            ; Get first/next char
        movsx rax, byte[r11+rbx]        ; Get nif entry
        test  rax, rax                  ; Test entry
        js    plzs2                     ; Special character if negative
        jnz   plzs3                     ; Branch if not zero
        add   rsi, 1                    ; Increment source pointer
        add   rdx, 1                    ; Increment zero count
        sub   rcx, 1                    ; Decrement digit count
        jnz   plzs1                     ; Loop until non-zero or count exhausted

; If loop falls through, there were no non-zero digits.

plzs2:  xor   rdx, rdx                  ; Zero character count register
        jmp   plzs8                     ; Branch to end

plzs3:  cmp   rdx, 0                    ; See if there were leading zeroes
        jz    plzs6                     ; Branch to install non-zero digit

        mov   [r15], rdx                ; Save character count on return stack
plzs4:  mov   byte[rdi], 0              ; Install zeroes in bsn
        add   rdi, 1                    ; Increment destination pointer
        sub   rdx, 1                    ; Decrement zero count
        jnz   plzs4                     ; Loop for zero count
        mov   rdx, [r15]                ; Restore character count
        jmp   plzs6                     ; Branch to install non-zero digit

plzs5:  movzx rbx, byte[rsi]            ; Get first/next char
        movsx rax, byte[r11+rbx]        ; Get nif entry
        test  rax, rax                  ; Test entry
        js    plzs8                     ; Special character if negative

plzs6:  cmp   rax, r8                   ; Compare digit with base
        jns   plzs7                     ; Not valid if not less
        mov   [rdi], al                 ; Install digit in bsn
        add   rsi, 1                    ; Increment source and
        add   rdi, 1                    ; destination pointers
        add   rdx, 1                    ; Increment character count
        sub   rcx, 1                    ; Decrement digit counter
        jnz   plzs5                     ; Loop until zero

; If loop falls through here, no special character was encountered.

        jmp   plzs8

; If invalid character encountered, set character register to 0.

plzs7:  mov   rbx, 0

plzs8:  jmp   rbp                       ; Return

; Error exit for zero denominator

asbs31: add   r15, 16                   ; Release rstack frame

        throwm 30                       ; Denominator is zero

; Pad bsn to 8-byte boundary

asbs32: mov   rdx, [r10]                ; Copy bsn length
        and   rdx, 7                    ; See how many blanks to add
        jz    asbs34                    ; No padding needed
        neg   rdx
        add   rdx, 8
        add   [r10], rdx                ; Add number of pad bytes to bsn size
asbs33: mov   byte[rdi], 0xff           ; Pad word to 8-byte boundary
        add   rdi, 1                    ; Increment pointer
        sub   rdx, 1                    ; Decrement counter
        jnz   asbs33
asbs34: btr   qword[r15+8], 0           ; Test/clear negative number flag
        jnc   asbs36                    ; Finish if flag was clear
        btr   qword[r15+8], 2           ; Test/clear zero integer flag
        jc    asbs36                    ; Finish if flag was set
        neg   qword[r10+32]             ; Else negate digit count
        jmp   asbs36                    ; Finish

; Conversion failed - stack contains source address, character count, and zero

asbs35: mov   rdx, [r14]                ; Get character count
        mov   qword[r14], 0             ; Put zero on top
        mov   [r14+8], rdx              ; Put char count on stack
        jmp   asbs37                    ; Source addr remains

; Success - stack contains destination address

asbs36: mov   rdx, [r14+8]              ; Get destination addr
        add   r14, 16                   ; Pop two items
        mov   [r14], rdx                ; Overwrite source with destination

asbs37: add   r15, 16                   ; Release rstack frame
        nextm
datam

; tgl-ovf - toggle flags, bit #10, which governs whether overflow is thrown
; for a single-quad number not preceded by a minus sign when the high order bit
; is set. The flag is clear by default, and unsigned input is allowed.
; If, for example, the hexadecimal number, FFFFFFFFFFFFFFFF is entered, and the flag
; is set, the system will throw "numeric overflow on input", but if the flag is clear,
; the number is allowed. It is anticipated that this word will rarely be used,
; therefore it is hidden.

head    "tgl-ovf", nbco, hidden
tglof:  dq  tgof0
textm
tgof0:  btc   qword[flgs0], 10          ; Complement unsigned flag
        nextm
datam

; bsn> - ( addr --- case# 1|0 ) Convert a byte-string number to a number
; on the stack according to the number type in the first byte of the BSN.
; Return hash number according to the number type.
; Takes the address of a byte-string number and converts it to a
; number on the stack according to the case number given in the first byte
; of the byte-string number object (bsn) and the number base given in the
; second byte of the bsn. Leaves the number and a true-flag on the stack.
; If the conversion fails, leaves a false flag on the stack.
; Can throw 25 - overflow on input.
;
; Flags:
;
;   0 - sign
;   1 - exponent sign
;   2 - zero integer
;   3 - non-zero result
;   4 - non-zero fraction
;
; Stack: address-of-byte-string-number --- number case  true-flag | false-flag
;
; The case number may be one of the following:
;
;   0 - not valid
;   1 - 64-bit integer
;   2 - multi-precision integer
;   3 - real
;   4 - rational
;   5 - floating-point

head    "bsn>",nbco,hidden
fbsn:   dq  fbsn0
textm
fbsn0:  cmp   qword[r14], 0             ; Check if bsn is valid
        jz    fbsn7                     ; Exit if not

        sub   r15, 24                   ; Free up r12
        mov   [r15+16], r12
        mov   qword[r15+8], 0           ; Zero flags quad
        mov   rsi, [r14]                ; Get bsn address
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get quadsize
        mov   rcx, [rsi+16]             ; Get number type
        mov   r8, [rsi+24]              ; Get number base of bsn
        mov   r9, [rsi+32]              ; Get integer digit count
        add   rsi, 40                   ; Advance to digit string
        test  r9, r9                    ; See if negative
        jns   fbsn1                     ; Jump if not
        bts   qword[r15+8], 0           ; Set sign flag
        neg   r9                        ; Make count positive

fbsn1:  mov   [r15], rcx                ; Put hash number in rstack frame
        cmp   rcx, 1                    ; Test for 64-bit integer
        jz    spin0
        cmp   rcx, 2                    ; Test for multi-precision integer
        jz    mpin0
        cmp   rcx, 3                    ; Test for real number
        jz    renu0
        cmp   rcx, 4                    ; Test for rational number
        jz    ranu0
        cmp   rcx, 5                    ; Test for floating-point number
        jz    flot0

; These are the only possibilities for now

        add   r15, 8                    ; Pop hash number from return stack
        jmp   fbsn5                     ; Branch to exit

; Case 1 - 64-bit Integer
; System flag #10 determines whether to throw overflow on input in order
; to allow the entry of unsigned single precision integers. It is set
; by default to allow unsigned integers to be entered directly.

spin0:  xor   rax, rax                  ; Clear low order accumulator
        cmp   r9, 0                     ; See if zero
        jz    spin4                     ; Branch if so

        cmp   r9, 1                     ; See if only one digit
        jnz   spin1                     ; Branch if not
        movzx rbx, byte[rsi]            ; Get single digit
        add   rax, rbx                  ; Accumulate single digit
        jmp   spin3

spin1:  xor   rdx, rdx                  ; Clear high order product
spin2:  movzx rbx, byte[rsi]            ; Get first/next digit
        mul   r8                        ; Multiply by base
        jo    fbsn2                     ; Throw overflow on input
        add   rax, rbx                  ; Accumulate digit value
        add   rsi, 1                    ; Advance digit pointer
        sub   r9, 1                     ; Decrement digit count
        jnz   spin2                     ; Loop until digit count exhausted

        bt    qword[flgs0], 10          ; Test unsigned flag
        jnc   spin3                     ; Branch if clear
        bt    rax, 63                   ; Test sign bit
        jc    fbsn2                     ; If set, throw overflow on input

spin3:  btr   qword[r15+8], 0           ; Test and clear sign flag
        jnc   spin4                     ; Jump if not set
        neg   rax
spin4:  sub   r14, 8                    ; Push low order result
        mov   [r14], rax
        jmp   fbsn4                     ; Exit with success

; Case 2 - Multi-precision Integer

mpin0:  mov   rcx, r10                  ; Using qsz for loop counter,
mpin1:  sub   r14, 8                    ; clear stack space for result
        mov   qword[r14], 0
        sub   rcx, 1
        jnz   mpin1

        cmp   r9, 0                     ; See if zero
        jz    mpin5                     ; Branch to exit if so

        cmp   r9, 1                     ; See if only one digit
        jnz   mpin2                     ; Branch if not

        movzx rbx, byte[rsi]            ; Get single digit
        mov   [r14+r10*8-8], rbx        ; Install in stack
        jmp   mpin4

mpin2:  mov   rdi, r14                  ; Copy stack pointer

        lea   rbp, [mpin3]              ; Set return address
        jmp   mpis0                     ; Convert integer

mpin3:  test  rdx, rdx                  ; See if overflow occurred
        jnz   fbsn2                     ; If so, throw overflow on input

; Negate result if sign flag set.

mpin4:  btr   qword[r15+8], 0           ; Test and clear sign flag
        jnc   fbsn4                     ; Finish if not negative

        mov   rbx, r10                  ; Use qsz for counter
        mov   rdi, r14                  ; Copy stack pointer

        lea   rbp, [mpin5]              ; Set return address
        jmp   negs0                     ; Negate result

mpin5:  jmp   fbsn4                     ; Branch to finish

; Case 3 - Real Number

; Integer part of real number

renu0:  mov   rcx, r10                  ; Using twice qsz for loop counter,
        shl   rcx, 1                    ; clear stack space for result
renu1:  sub   r14, 8
        mov   qword[r14], 0
        sub   rcx, 1                    ; Decrement counter
        jnz   renu1                     ; Loop

        cmp   r9, 0                     ; See if zero
        jz    fbsn4                     ; Branch to exit if so

        mov   rdi, r14                  ; Copy stack pointer
        cmp   r9, 1                     ; See if integer is only one digit
        jnz   renu3                     ; Branch if not
        cmp   byte[rsi], 0              ; See if single digit is zero
        jnz   renu2                     ; Branch if not

        bts   qword[r15+8], 2           ; Set zero integer flag
        add   rsi, 1                    ; Advance to 2nd string
        jmp   renu5                     ; Process fraction

renu2:  movzx rbx, byte[rsi]            ; Get single integer digit
        mov   [r14+r10*8-8], rbx        ; Install in stack
        add   rsi, 1                    ; Advance to 2nd string
        jmp   renu5                     ; Process fraction

renu3:  lea   rbp, [renu4]              ; Set return address
        jmp   mpis0                     ; Convert integer part

renu4:  test  rdx, rdx                  ; See if overflow occurred
        jnz   fbsn2                     ; If so, throw overflow on input

; Fractional part of real number

renu5:  lea   rbp, [renu6]              ; Set return address
        jmp   frcs0

; If number base register is zero, carry went all the way through to the
; most significant quad resulting in overflow.

renu6:  cmp   r8, 0                     ; See if count exhausted
        jz    fbsn2                     ; If so, throw overflow on input

; If result is negative, overflow occurred.

        bt    qword[r14], 63            ; Test sign bit of result
        jc    fbsn2                     ; Throw overflow if not positive

; If zero integer flag is set, check for underflow.

        btr   qword[r15+8], 2           ; Test/clear zero integer flag
        jnc   renu8                     ; Branch if flag was clear

; See if there are any non-zero quads on the stack

        mov   rcx, r10
        shl   rcx, 1
renu7:  cmp   qword[r14+rcx*8-8], 0
        jnz   renu8
        sub   rcx, 1
        jnz   renu7

; If loop falls through, throw underflow on input.

        jmp   fbsn3

; Negate result if case number was negative.

renu8:  btr   qword[r15+8], 0           ; Test and clear sign flag
        jnc   fbsn4                     ; Finish if not negative

        mov   rbx, r10                  ; Use twice qsz for counter
        shl   rbx, 1
        mov   rdi, r14                  ; Copy stack pointer

        lea   rbp, [fbsn4]              ; Set return address
        jmp   negs0                     ; Negate result

; Case 4 - Rational Number

ranu0:  mov   rcx, r10                  ; Using twice qsz for loop counter,
        shl   rcx, 1                    ; clear stack space for result
ranu1:  sub   r14, 8
        mov   qword[r14], 0
        sub   rcx, 1
        jnz   ranu1

        cmp   r9, 0                     ; Test for zero
        jnz   ranu2                     ; Branuch if not zero

        mov   qword[r14+r10*8-8], 1     ; Install 1 for denominator
        jmp   fbsn4                     ; Branuch to exit

ranu2:  lea   rdi, [r14+r10*8]          ; Advance to numerator stack location

        lea   rbp, [ranu3]              ; Set return address
        jmp   mpis0                     ; Convert numerator

ranu3:  test  rdx, rdx                  ; See if overflow occurred
        jnz   fbsn2                     ; If so, throw overflow on input

        mov   r9, [rsi]                 ; Get digit count for 2nd string
        add   rsi, 8                    ; Advance to 2nd string
        mov   rdi, r14                  ; Copy stack pointer

        lea   rbp, [ranu4]              ; Set return address
        jmp   mpis0                     ; Convert denominator

ranu4:  test  rdx, rdx                  ; See if overflow occurred
        jnz   fbsn2                     ; If so, throw overflow on input

        btr   qword[r15+8], 0           ; Test and clear sign flag
        jnc   fbsn4                     ; Finish if not negative

        mov   rbx, r10                  ; Copy qsz for count
        lea   rdi, [r14+r10*8]          ; Offset to numerator

        lea   rbp, [fbsn4]              ; Set return address
        jmp   negs0                     ; Negate numerator

; Case 5 - Floating-point Number
;
; Integer part of floating-point number

flot0:  mov   rcx, r10                  ; Using twice qsz for loop counter,
        shl   rcx, 1                    ; clear stack space for result
flot1:  sub   r14, 8
        mov   qword[r14], 0
        sub   rcx, 1                    ; Decrement counter
        jnz   flot1                     ; Loop

        cmp   r9, 0                     ; See if zero
        jz    fbsn4                     ; Branch to exit if so

        mov   rdi, r14                  ; Copy stack pointer
        cmp   r9, 1                     ; See if integer is only one digit
        jnz   flot3                     ; Branch if not
        cmp   byte[rsi], 0              ; See if single digit is zero
        jnz   flot2                     ; Branch if not

        bts   qword[r15+8], 2           ; Set zero integer flag
        add   rsi, 1                    ; Advance to 2nd string
        jmp   flot5                     ; Process fraction

flot2:  movzx rbx, byte[rsi]            ; Get single integer digit
        mov   [r14+r10*8-8], rbx        ; Install in stack
        add   rsi, 1                    ; Advance to 2nd string
        jmp   flot5                     ; Process fraction

flot3:  lea   rbp, [flot4]              ; Set return address
        jmp   mpis0                     ; Convert integer part

flot4:  test  rdx, rdx                  ; See if overflow occurred
        jnz   fbsn2                     ; If so, throw overflow on input

; Fractional part of floating-point number

flot5:  btr   qword[r15+8], 4           ; Clear non-zero fraction flag
        lea   rbp, [flot6]              ; Set return address
        jmp   frcs0

; If number base register is zero, carry went all the way through to the
; most significant quad resulting in overflow.

flot6:  cmp   r8, 0                     ; See if count exhausted
        jz    fbsn2                     ; If so, throw overflow on input

; If result is negative, overflow occurred.

        bt    qword[r14], 63            ; Test sign bit of result
        jc    fbsn2                     ; Throw overflow if not positive

; If zero integer flag is set, check non-zero fraction flag.

        btr   qword[r15+8], 2           ; Test/clear zero integer flag
        jnc   flot8                     ; Branch if flag was clear

; If non-zero fraction flag is set, check for underflow.

        btr   qword[r15+8], 4           ; Test/clear non-zero fraction flag
        jnc   flot8                     ; Branch if flag was clear

; See if there are any non-zero quads on the stack

        mov   rcx, r10
        shl   rcx, 1
flot7:  cmp   qword[r14+rcx*8-8], 0
        jnz   flot8
        sub   rcx, 1
        jnz   flot7

; If loop falls through, throw underflow on input

        jmp   fbsn3

; Convert exponent

flot8:  mov   rdx, [rsi-8]              ; Get fraction length
        lea   rsi, [rsi+rdx]            ; Offset to exponent length
        mov   r9, [rsi]                 ; Get exponent digit count
        test  r9, r9                    ; See if negative
        jns   flot9                     ; Jump if not
        bts   qword[r15+8], 1           ; Set exponent sign flag
        neg   r9                        ; Make count positive

flot9:  add   rsi, 8                    ; Offset to exponent string

        xor   rax, rax                  ; Clear low order accumulator
        cmp   r9, 1                     ; See if only one digit
        jnz   flot10                    ; Branch if not
        movzx rbx, byte[rsi]            ; Get single digit
        add   rax, rbx                  ; Accumulate single digit
        jmp   flot12                    ; Branch to continue

flot10: xor   rdx, rdx                  ; Clear high order product
flot11: movzx rbx, byte[rsi]            ; Get first/next digit
        mul   r8                        ; Multiply by base
        jo    fbsn2                     ; Throw overflow on input
        add   rax, rbx                  ; Accumulate digit value
        add   rsi, 1                    ; Advance digit pointer
        sub   r9, 1                     ; Decrement digit count
        jnz   flot11                    ; Loop until digit count exhausted

        bt    rax, 63                   ; Test sign bit
        jc    fbsn2                     ; If set, throw overflow on input

; Multiply or divide the real number by the power of the base corresponding
; to the exponent.

flot12: mov   r9, rax                   ; Copy exponent

        shl   r10, 1                    ; Temporarily double qsz

        btr   qword[r15+8], 1           ; Test and clear exponent sign flag
        jc    flot16                    ; Branch if exponent is negative

        cmp   r9, 0                     ; See if exponent is 0
        jna   flot22                    ; Do nothing if so

; If high order product is not zero at the end of each outer loop, overflow
; occured. Throw overflow on input.

        mov   rdi, r14                  ; Copy stack pointer
        xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear high order transfer register
flot13: mov   rcx, r10                  ; Set/reset inner loop counter
flot14: mov   rax, [rdi+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add digit/high order
        jnc   flot15                    ; Branch if no carry
        add   rdx, 1                    ; Else add carry
flot15: mov   [rdi+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order
        sub   rcx, 1                    ; Decrement count
        jnz   flot14                    ; Loop for qsz
        test  rdx, rdx                  ; Check for overflow
        jnz   flot20                    ; Branch if overflow
        bt    qword[r14], 63            ; Test sign of high order
        jc    flot20                    ; Overflow if set
        sub   r9, 1                     ; Decrement exponent count
        jnz   flot13                    ; Loop for digit count
        jmp   flot22                    ; Branch to exit

; If result becomes zero, underflow occured. Throw underflow on input.

flot16: xor   rax, rax                  ; Clear quotient register
flot17: btr   qword[r15+8], 3           ; Clear non-zero result flag
        xor   rdx, rdx                  ; Clear remainder register
        mov   rdi, r14                  ; Copy stack pointer
        mov   rcx, r10                  ; Set/reset inner loop counter
flot18: mov   rax, [rdi]                ; Get first/next stack quad
        div   r8                        ; Divide by number base
        cmp   rax, 0                    ; See if result is zero
        jz    flot19                    ; Branch if so
        bts   qword[r15+8], 3           ; Set non-zero result flag

flot19: mov   [rdi], rax                ; Return to stack
        add   rdi, 8                    ; Advance pointer
        sub   rcx, 1                    ; Decrement quad counter
        jnz   flot18                    ; Loop for double qsz count
        bt    qword[r15+8], 3           ; Test non-zero result flag
        jnc   flot21                    ; Underflow if flag not set

        sub   r9, 1                     ; Decrement exponent counter
        jnz   flot17                    ; Loop for count
        jmp   flot22                    ; Branch to continue

flot20: shr   r10, 1                    ; Restore qsz
        jmp   fbsn2                     ; Throw overflow on input

flot21: shr   r10, 1                    ; Restore qsz
        jmp   fbsn3                     ; Throw underflow on input

; Find number of leading zero quads

flot22: xor   r8, r8                    ; Clear for leading zero-quad count
        mov   rcx, r10                  ; Set counter
flot23: cmp   qword[r14+r8*8], 0        ; Find leading non-zero quad
        jnz   flot24                    ; Leave loop if non-zero
        add   r8, 1                     ; Increment count/index
        sub   rcx, 1                    ; Decrement quad count
        jnz   flot23                    ; Loop for 2*qsz

; If loop falls through, number is zero. Use high order quad for exponent.

        shr   r10, 1                    ; Restore qsz
        jmp   fbsn4                     ; Branch to exit

; Find trailing non-zero quad.

flot24: xor   r9, r9                    ; Clear for trailing zero-quad count
        mov   rcx, r10                  ; Set counter
flot25: cmp   qword[r14+rcx*8-8], 0     ; Find trailing non-zero quad
        jnz   flot26                    ; Leave loop if non-zero
        add   r9, 1                     ; Increment count
        sub   rcx, 1                    ; Decrement index
        jmp   flot25

; Find leading set bit and normalize number. Subtract number of trailing zero
; quads and number of leading zero quads from 2*qsz for number of quads
; to shift.

flot26: mov   r11, r10                  ; Copy 2*qsz
        sub   r11, r8                   ; Subtract leading zero quads
        sub   r11, r9                   ; Subtract trailing zero quads

        mov   rcx, 63                   ; Set up for shift calculation
        bsr   rbx, [r14+r8*8]           ; Scan for leading set bit
        sub   rcx, rbx                  ; Find number of bits to shift
        jz    flot29                    ; Branch if no bits to shift

; Use leading zero count for index. Shift bits left.

        mov   rdx, r8                   ; Copy index
        mov   rbx, r11                  ; Copy total quad count
        sub   rbx, 1                    ; One less for last shift
        jz    flot28                    ; Only 1 quad to shift
flot27: mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   flot27
flot28: shl   qword[r14+rdx*8], cl      ; Shift single quad

; Set up first part of exponent calculation {32*[(2*qsz)-2]-1}.

flot29: mov   rdx, r11                  ; Save total quad count
        mov   r11, r10                  ; Copy 2*qsz
        sub   r11, 2                    ; Subtract 2
        shl   r11, 5                    ; Multiply by 32
        sub   r11, 1                    ; Subtract 1

; Decrement the leading zero quad count to compensate for the exponent cell.
; If there was only one leading zero quad no further shifting is needed.
; If there were no leading zero quads, shift significand right one quad, clear
; leading zero quad count, and add back one quad worth of bits for shift
; calculation. Otherwise shift significand left.

        sub   r8, 1                     ; See if there were leading zero quads
        jz    flot37                    ; Branch if one lzq
        jnc   flot34                    ; Branch if more than one lzq

; If there is no leading non-zero quad, the number will have to be shifted
; one quad to the right to accommodate the exponent. First test if there were
; trailing zero quads. If so, no rounding will be needed.

        xor   r8, r8                    ; Clear negative lq count
        add   r11, 64                   ; Add back 64 bits
        cmp   r9, 0                     ; See if there were trailing zero quads
        jz    flot31                    ; Branch if not

; Shift significand right one quad. No rounding needed.

flot30: mov   rax, [r14+rdx*8-8]        ; Move quads right
        mov   [r14+rdx*8], rax
        sub   rdx, 1                    ; Decrement count/index
        jnz   flot30

        jmp   flot37                    ; Go process exponent

; Shift significand right one quad. Save low order quad for rounding.

flot31: sub   rdx, 1                    ; Shifting 2*qsz-1 quads
        mov   rbx, [r14+r10*8-8]        ; Save low order quad
flot32: mov   rax, [r14+rdx*8-8]        ; Move quads right
        mov   [r14+rdx*8], rax
        sub   rdx, 1                    ; Decrement count/index
        jnz   flot32

; For rounding purposes, test high order bit of the low order quad, and if it
; is set, add 1 to shifted significand, and propagate the carry as far as it
; will go. If the carry goes all the way past the highest order quad, set
; the high order bit to one, and increment the exponent. This will only happen
; with the highest order real number representable in the current quadsize,
; and the result will throw overflow on output

        bt    rbx, 63                   ; See if rounding needed
        jnc   flot37                    ; If not, go process exponent

        mov   rdx, r10                  ; Get qsz*2
        sub   rdx, 1                    ; One less for exponent
flot33: add   qword[r14+rdx*8], 1       ; Add 1 to low order
        jnc   flot37                    ; If no carry, go process exponent
        sub   rdx, 1                    ; Else decrement index and repeat
        jnz   flot33

; If loop falls through carry went past high order, set high order bit
; and increment exponent.

        bts   qword[r14+8], 63          ; Set high order bit of significand
        add   r11, 1                    ; Increment exponent
        jmp   flot37                    ; Go process exponent

; If there was more than one leading zero quad, shift quads left by one less
; than that number of quads.

flot34: mov   rbx, r10                  ; Copy number size
        sub   rbx, 1                    ; Subtract 1 quad for exponent
        sub   rbx, r8                   ; Subtract quad shift count
        xor   rdx, rdx                  ; Clear index register
        lea   rsi, [r14+r8*8+8]         ; Load addr of 1st non-zero quad
        lea   rdi, [r14+8]              ; Load addr of high order significand
flot35: mov   rax, [rsi+rdx*8]          ; Move significand left
        mov   [rdi+rdx*8], rax
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement counter
        jnz   flot35                    ; Loop for non-zero quad count

        mov   rbx, r8                   ; Set counter to zero-quad count
flot36: mov   qword[rdi+rdx*8], 0       ; Zero shifted quads
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement counter
        jnz   flot36

; Calculate exponent. The unbiased exponent is the bit count of one less than
; the system qsz minus 1 minus the total shift count. To this is added the bias
; according to the formula,
; exp = [64*(qsz-1)-1] - shift + bias
; The first part of the calculation has been done above.
; Calculate shift and subtract it.

        shl   r8, 6                     ; Quads shifted * 64

flot37: add   r8, rcx                   ; Add bits shifted
        sub   r11, r8                   ; Subtract total bits shifted

; Add exponent bias.

        mov   rcx, 0x3FFFFFFFFFFFFFFF   ; Put bias in register
        add   r11, rcx                  ; Add bias
        mov   [r14], r11                ; Put exponent on stack
        shr   r10, 1                    ; Restore qsz

        btr   qword[r15+8], 0           ; Test/clear sign flag
        jnc   fbsn4                     ; Branch if flag was clear
        bts   qword[r14], 63            ; Else set floating-point sign bit
        jmp   fbsn4

; Leaf function to convert multiprecision integer in bsn to number on the
; stack. It is assumed that the input digit pointer is in rsi, that stack
; space has been cleared for the result, and that rdi contains the stack
; pointer. If overflow occurs, rdx will be non-zero on return.

mpis0:  movzx rbx, byte[rsi]            ; Get first/next digit
        mov   rcx, r10                  ; Set/reset inner loop counter
mpis1:  mov   rax, [rdi+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add digit/high order
        jnc   mpis2                     ; Branch if no carry
        add   rdx, 1                    ; Else add carry
mpis2:  mov   [rdi+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order
        sub   rcx, 1                    ; Decrement count
        jnz   mpis1                     ; Loop for qsz
        test  rdx, rdx                  ; Check for overflow
        jnz   mpis3                     ; Exit if overflow
        add   rsi, 1                    ; Increment digit pointer
        sub   r9, 1                     ; Decrement digit count
        jnz   mpis0                     ; Loop for digit count

        bt    qword[rdi], 63            ; Test sign bit
        jnc   mpis3                     ; Exit if no sign change
        mov   rdx, 1                    ; Else set for overflow

mpis3:  jmp   rbp                       ; Return

; Leaf function to convert fractional part of real number. The address of
; the fraction digit count is assumed to be in rsi when the function is
; called. The stack pointer is expected to be in rdi.
; 3/26/14 Modified to set non-zero fraction flag if at least one non-zero
; fraction digit encountered. This will be used to detect underflow.

frcs0:  lea   r11, [rdi+r10*8]          ; Offset stack past integer part
        xor   rax, rax                  ; Clear division registers
        xor   rdx, rdx
        mov   rcx, [rsi]                ; Get digit count
        add   rsi, 8                    ; Offset to fraction string

frcs1:  movzx rdx, byte[rsi+rcx-1]      ; Get first/next digit
        cmp   rdx, 0                    ; See if zero
        jnc   frcs2                     ; Branch if so
        bts   qword[r15+8], 4           ; Else set non-zero fraction flag

frcs2:  mov   rdi, r11                  ; Copy stack pointer
        mov   rbx, r10                  ; Set/reset inner loop counter

frcs3:  mov   rax, [rdi]                ; Get first/next stack quad
        add   rdi, 8                    ; Advance pointer
        div   r8                        ; Divide by number base
        mov   [rdi-8], rax              ; Return to stack
        sub   rbx, 1                    ; Decrement quad counter
        jnz   frcs3                     ; Loop for qsz count
        sub   rcx, 1                    ; Decrement digit counter
        jnz   frcs1                     ; Loop for digit count

        mov   rbx, r8                   ; Copy number base
        shr   rbx, 1                    ; Halve number base
        cmp   rdx, rbx                  ; Compare with remainder
        js    frcs6                     ; If remainder<base/2, round down (chop)
        jnz   frcs4                     ; If remainder>base/2, round up
        bt    qword[rdi-8], 0           ; Test LS bit of result
        jz    frcs6                     ; Round down if zero

frcs4:  mov   rcx, r10                  ; Use twice qsz for counter
        shl   rcx, 1
frcs5:  add   qword[r14+rcx*8-8], 1     ; Add 1 until carry clear
        jnc   frcs6
        sub   rcx, 1
        jnz   frcs5                     ; Loop for count

; If loop falls through, carry went all the way to the high order integer quad,
; causing overflow. To signal this condition, the number base register will be
; set to 0.

        mov   r8, 0                     ; Set number base register to 0

frcs6:  jmp   rbp                       ; Return

; Leaf function to negate multiprecision integer. It is assumed that the
; quad count is in rbx and the stack pointer is in rdi.

negs0:  mov   rcx, rbx                  ; Copy count
negs1:  not   qword[rdi+rcx*8-8]        ; Complement stack entry
        sub   rcx, 1
        jnz   negs1
        mov   rcx, rbx                  ; Reset loop counter
negs2:  add   qword[rdi+rcx*8-8], 1     ; Add 1 until no carry
        jnc   negs3
        sub   rcx, 1
        jnz   negs2
negs3:  jmp   rbp                       ; Return

; Handle overflow on input error.

fbsn2:  mov   r12, [r15+16]             ; Restore registers
        add   r15, 24

        throwm 25                       ; Throw overflow on input

; Handle underflow on input error.

fbsn3:  mov   r12, [r15+16]             ; Restore r12
        add   r15, 24

        throwm 26                       ; Throw underflow on input

; End of successful processing.

fbsn4:  mov   rdx, [r15]                ; Get hash number
        sub   r14, 8                    ; Push to data stack
        mov   [r14], rdx                ; Put hash number on stack
        sub   r14, 8                    ; Push true flag
        mov   qword[r14], 1
        jmp   fbsn6

; Conversion failed. Put false flag on stack.

fbsn5:  sub   r14, 8
        mov   qword[r14], 0             ; Push false flag to stack

fbsn6:  mov   r12, [r15+16]             ; Restore r12
        add   r15, 24
fbsn7:  nextm
datam

; >number - convert ASCII at address to a number on the stack, passing
; from ASCII to byte-string to binary on the stack. Return a number
; from the following list representing the number type or zero for failure:

;   0 - not valid
;   1 - 64-bit integer
;   2 - multi-precision integer
;   3 - real
;   4 - rational
;   5 - floating-point

; The hash number is only used when compiling, as an index into
; the jump table of appropriate routines to compile the number
; as a literal preceeded the address of code to handle it.

; : >number  ascii>bsn bsn> ?found ;

head    ">number", hlfo, hidden
tnumb:  dq  docl0
        dq  asbsn,fbsn,qfound,semis

; ascii>bin - ( addr n --- in ) Convert ASCII string of length n at addr directly
; to a integer of the current quadsize on the stack. The string must represent a
; valid binary number. The number may be proceeded by "0b" or "0B". Note that while
; any number of zeroes are allowed to precede the binary number number itself,
; only one zero can occur before the "b" or "B". For example, 0b001101 is recognized,
; but not 00b1101. Also note that with the "0b" and "0B"  forms, the sign of the
; number occurs before the "0b" or "0B". Thus, -0B10101  is recognized, but not
; 0B-10101.

head    "ascii>bin", nbco, hidden
ascbi:  dq  asbi0
textm
asbi0:  mov   rdi, [r14+8]              ; Get addr of string
        mov   rdx, [r14]                ; Get byte count
        add   r14, 16                   ; Pop stack
        mov   r10, [qdsz0]              ; Get system qsz
        btr   r11, 63                   ; Clear sign flag

; Clear stack space for result.

        lea   rbp, [r14-8]              ; Initialize result pointer
        mov   rax, r10                  ; Copy qsz
asbi1:  sub   r14, 8                    ; Clear stack space
        mov   qword[r14], 0
        sub   rax, 1
        jnz   asbi1

        xor   rcx, rcx                  ; Zero buffer index register

; A leading minus sign indicates a negative number. A leading plus sign is ignored.
; A b or B following a leading zero, or a leading minus sign and a zero, is ignored.
; Any number of leading zeroes is ignored.

        cmp   byte[rdi], 45             ; Test for leading minus sign
        jnz   asbi2                     ; Branch if none

        bts   r11, 63                   ; Use r11 high for sign flag
        sub   rdx, 1                    ; Decrement chr count
        jz    asbi9                     ; Error if zero

        add   rcx, 1                    ; Increment index
        jmp   asbi3

asbi2:  cmp   byte[rdi+rcx], 43         ; Test for leading plus sign
        jnz   asbi3                     ; Branch if none

        sub   rdx, 1                    ; Decrement chr count
        jz    asbi9                     ; Error if zero

        add   rcx, 1                    ; Increment index

asbi3:  cmp   byte[rdi+rcx], 48         ; Test for 1st leading zero
        jnz   asbi6                     ; Branch if none
        sub   rdx, 1                    ; Decrement chr count
        jz    asbi20                    ; If zero, number is zero

        add   rcx, 1                    ; Increment index

        cmp   byte[rdi+rcx], 66         ; Test for B
        jnz   asbi4

        sub   rdx, 1                    ; Decrement chr count
        jz    asbi9                     ; Error if zero
        add   rcx, 1                    ; Increment index
        jmp   asbi5                     ; Resume testing for leading zeroes

asbi4:  cmp   byte[rdi+rcx], 98         ; Test for b
        jnz   asbi5

        sub   rdx, 1                    ; Decrement chr count
        jz    asbi9                     ; Error if zero

        add   rcx, 1                    ; Increment index

asbi5:  cmp   byte[rdi+rcx], 48         ; Test for leading zero
        jnz   asbi6                     ; Branch if no more
        sub   rdx, 1                    ; Decrement char count
        jz    asbi20                    ; If zero, number is zero

        add   rcx, 1                    ; Increment index
        jmp   asbi5                     ; Loop

; Make sure non-zero character is valid before proceeding.

asbi6:  movzx rax, byte[rdi+rcx]        ; Get buffer character
        sub   rax, 48                   ; Convert from ASCII
        cmp   al, 1                     ; See if valid
        ja    asbi14                    ; Branch if not

        mov   rax, r10                  ; Copy system quadsize
        shl   rax, 6                    ; Find number of bits

        cmp   rax, rdx                  ; See if number will fit
        ja    asbi7                     ; Branch if so

        btr   r11, 63                   ; Make sure sign flag is clear
        lea   r14, [r14+r10*8]          ; Restore stack pointer

        throwm 25                       ; Overflow on input

asbi7:  add   rdi, rcx                  ; Add index to buffer base addr
        mov   rcx, rdx                  ; Reset index to end

        mov   rax, rdx                  ; Copy number of chrs
        shr   rdx, 6                    ; Convert bits to quadwords

; Round up to the nearest quad if either the result of the shift is zero,
; or there were bits shifted out.

        jnz   asbi8
        jmp   asbi9

asbi8:  and   rax, 111111b
        jz    asbi10

asbi9:  add   rdx, 1                    ; Round up

asbi10: xor   rbx, rbx                  ; Clear bit accumulator
        xor   r8, r8                    ; Clear bit counter
        mov   r9, 63                    ; Set loop counter

asbi11: movzx rax, byte[rdi+rcx-1]      ; Get buffer character
        sub   rax, 48                   ; Convert from ASCII
        cmp   al, 1                     ; See if valid
        ja    asbi14                    ; Branch if not

        jc    asbi12                    ; CF --> digit is zero

        bts   rbx, r8                   ; Set next bit

asbi12: sub   rcx, 1                    ; Decrement buffer index
        jz    asbi13                    ; Finished if zero
        add   r8, 1                     ; Increment bit number
        cmp   r8, 64                    ; Check limit
        jnz   asbi11                    ; Loop if less

; Install quad on stack.

asbi13: mov   [rbp], rbx                ; Install quad
        sub   rbp, 8                    ; Decrement pointer
        sub   rdx, 1                    ; Decrement quad counter
        jz    asbi15                    ; Finished if zero
        jmp   asbi10                    ; Reset for next quad

asbi14: btr   r11, 63                   ; Make sure sign flag is clear
        lea   r14, [r14+r10*8]          ; Restore stack pointer

        throwm 123                      ; Not valid binary number

asbi15: btr   r11, 63                   ; Test/clear sign flag
        jnc   asbi21                    ; Exit if clear

; Negate result.

; Find trailing non-zero quad

asbi16: cmp   qword[r14+r10*8-8], 0     ; Scan for non-zero quad
        jnz   asbi17
        sub   r10, 1
        jnz   asbi16

asbi17: mov   rbx, r10
asbi18: not   qword[r14+r10*8-8]
        sub   r10, 1
        jnz   asbi18
asbi19: add   qword[r14+rbx*8-8], 1
        jnc   asbi21
        sub   rbx, 1
        jnz   asbi19
        jmp   asbi21                    ; Branch to exit

asbi20: btr   r12, 63                   ; Make sure sign flag is clear

asbi21: nextm
datam

; bin" - ( --- in ) Move the string that follows in the input stream
; to the auxiliary buffer until the next quotation mark is encountered and
; convert it directly from ASCII to a multiprecision integer in the current
; quadsize on the stack. The string must represent a valid binary number.

head    'bin"', hlfo
binq:   dq  docl0
        dq  axbn,dbqt,dlmwrd,dupl
        dq  eighm,qat,ascbi,semis

; ascii>hex - ( addr n --- in ) Convert ASCII string of length n at addr directly
; to an integer of the current quadsize on the stack. The string must represent a
; valid hexadecimal number. All forms of hex number are recognized, include those
; with mixed uppercase and lowercase letters and those preceded by "0x" or "0X".
; Note that while any number of zeroes are allowed to precede the hexadecimal
; number itself, only one zero can occur before the "x" or "X". For example,
; 0x00abcd is recognized, but not 00xabcd. Also note that with the "0x" and "0X"
; forms, the sign of the number occurs before the "0x" or "0X". Thus, -0x7fff
; is recognized, but not 0x-7fff.

head    "ascii>hex", nbco, hidden
aschx:  dq  ashx0
textm
ashx0:  mov   rdi, [r14+8]              ; Get addr of string
        mov   rdx, [r14]                ; Get byte count
        add   r14, 16                   ; Pop stack
        mov   r10, [qdsz0]              ; Get system qsz
        btr   r11, 63                   ; Clear sign flag

; Clear stack space for result.

        mov   rbp, r14                  ; Copy stack pointer
        mov   rax, r10                  ; Copy qsz
ashx1:  sub   r14, 8                    ; Clear stack space
        mov   qword[r14], 0
        sub   rax, 1
        jnz   ashx1

        xor   rcx, rcx                  ; Zero buffer index register

; A leading minus sign indicates a negative number. A leading plus sign is ignored.
; An x or X following a leading zero, or a leading minus sign and a zero, is ignored.
; Any number of zeroes preceding the number itself is ignored.

        cmp   byte[rdi], 45             ; Test for leading minus sign
        jnz   ashx2                     ; Branch if none

        bts   r11, 63                   ; Use r11 high for sign flag
        sub   rdx, 1                    ; Decrement chr count
        jz    ashx10                    ; Error if zero

        add   rcx, 1                    ; Increment index
        jmp   ashx3

ashx2:  cmp   byte[rdi+rcx], 43         ; Test for leading plus sign
        jnz   ashx3                     ; Branch if none

        sub   rdx, 1                    ; Decrement chr count
        jz    ashx10                    ; Error if zero

        add   rcx, 1                    ; Increment index

ashx3:  cmp   byte[rdi+rcx], 48         ; Test for 1st leading zero
        jnz   ashx6                     ; Branch if none
        sub   rdx, 1                    ; Decrement chr count
        jz    ashx18                    ; If zero, number is zero

        add   rcx, 1                    ; Increment index
        cmp   byte[rdi+rcx], 88         ; Test for X
        jnz   ashx4

        sub   rdx, 1                    ; Decrement chr count
        jz    ashx10                    ; Error if zero
        add   rcx, 1                    ; Increment index
        jmp   ashx5                     ; Resume testing for leading zeroes

ashx4:  cmp   byte[rdi+rcx], 120        ; Test for x
        jnz   ashx5

        sub   rdx, 1                    ; Decrement chr count
        jz    ashx10                    ; Error if zero
        add   rcx, 1                    ; Increment index

ashx5:  cmp   byte[rdi+rcx], 48         ; Test for leading zero
        jnz   ashx6                     ; Branch if no more
        sub   rdx, 1                    ; Decrement char count
        jz    ashx18                    ; If zero, number is zero

        add   rcx, 1                    ; Increment index
        jmp   ashx5                     ; Loop

ashx6:  lea   rsi, [hextb0]             ; Get hex table base address

; Make sure non-zero character is valid before proceeding.

        movzx rax, byte[rdi+rcx]        ; Get buffer character
        movzx rax, byte[rsi+rax]        ; Get hex digit
        cmp   al, -1                    ; See if valid hex digit
        jz    ashx12                    ; Error if not

        mov   rax, r10                  ; Copy system quadsize
        shl   rax, 4                    ; Find number of nibbles

        cmp   rax, rdx                  ; See if number will fit
        ja    ashx8                     ; Branch if so
        jc    ashx7                     ; Branch if not

; If the number takes all nibbles in the stack cell, it can be accommodated
; only if the leading nibble is 7 or less.

        movzx rax, byte[rdi+rcx]        ; Get buffer character
        movzx rax, byte[rsi+rax]        ; Get hex digit
        cmp   al, -1                    ; See if valid hex digit
        jz    ashx12                    ; Error if not

        cmp   rax, 8                    ; See if 7 or less
        jc    ashx8                     ; Continue if so

ashx7:  btr   r11, 63                   ; Make sure sign flag is clear
        mov   r14, rbp                  ; Restore stack pointer

        throwm 25                       ; Overflow on input

ashx8:  add   rdi, rcx                  ; Add index to buffer base addr
        mov   rcx, rdx                  ; Reset index to end
        shr   rdx, 1                    ; Convert nibbles to bytes
        jnc   ashx9

        add   rdx, 1                    ; Round up

ashx9:  mov   r8, rbp                   ; Copy saved stack pointer
        mov   r9, -8                    ; Set index

ashx10: movzx rax, byte[rdi+rcx-1]      ; Get 1st byte
        movzx rax, byte[rsi+rax]        ; Get hex digit
        cmp   al, -1                    ; See if valid hex digit
        jz    ashx12                    ; Branch if not

        sub   rcx, 1                    ; Decrement buffer index
        jz    ashx11                    ; Finished if zero

        movzx rbx, byte[rdi+rcx-1]      ; Get 2nd byte
        movzx rbx, byte[rsi+rbx]        ; Get hex digit
        cmp   bl, -1                    ; See if valid hex digit
        jz    ashx12                    ; Branch if not

        sub   rcx, 1                    ; Decrement buffer index
        shl   rbx, 4                    ; Shift nibble left
        or    al, bl                    ; Compose byte

ashx11: mov   byte[r8+r9], al           ; Install byte on stack
        sub   rdx, 1                    ; Decrement byte count
        jz    ashx13                    ; Finished if zero

        add   r9, 1                     ; Increment index
        jnz   ashx10                    ; Loop if not zero

        sub   r8, 8                     ; Decrement quad pointer
        mov   r9, -8                    ; Reset index
        jmp   ashx10                    ; Loop

ashx12: btr   r11, 63                   ; Make sure sign flag is clear
        mov   r14, rbp                  ; Restore stack pointer

        throwm 124                      ; Not valid hex number

ashx13: btr   r11, 63                   ; Test/clear sign flag
        jnc   ashx19                    ; Exit if clear

; Negate result.

; Find trailing non-zero quad

ashx14: cmp   qword[r14+r10*8-8], 0     ; Scan for non-zero quad
        jnz   ashx15
        sub   r10, 1
        jnz   ashx14

ashx15: mov   rbx, r10
ashx16: not   qword[r14+r10*8-8]
        sub   r10, 1
        jnz   ashx16
ashx17: add   qword[r14+rbx*8-8], 1
        jnc   ashx19
        sub   rbx, 1
        jnz   ashx17
        jmp   ashx19                    ; Branch to exit

ashx18: btr   r11, 63                   ; Make sure sign flag is clear

ashx19: nextm
datam

; hex" - ( --- in ) Move the string that follows in the input stream
; to the auxiliary buffer until the next quotation mark is encountered and
; convert it directly from ASCII to a multiprecision integer in the current
; quadsize on the stack. The string must represent a valid hexadecimal number.

head    'hex"', hlfo
hexq:   dq  docl0
        dq  axbn,dbqt,dlmwrd,dupl
        dq  eighm,qat,aschx,semis

; spi>bsn - Convert single precision number on the stack to a byte-string
; number at the address passed on the stack.

head    "spi>bsn",nbco,hidden
spbsn:  dq  spbs0
textm
spbs0:  mov   r8, [r14]                 ; Get number base
        mov   rsi, [r14+8]              ; Get buffer address
        mov   rax, [r14+16]             ; Get number
        add   r14, 16                   ; Pop two stack items

        xor   rbp, rbp                  ; Zero flags register
        mov   qword[rsi+8], bsno        ; Set object type to bsn
        mov   qword[rsi+16], 1          ; Set number type to spi
        mov   [rsi+24], r8              ; Install number base

        xor   rdx, rdx                  ; Clear high order division register
        mov   rcx, 1                    ; Initialize count (at least 1 digit)

        bt    rax, 63                   ; Test sign of number
        jnc   spbs1                     ; Branch if not set
        bts   rbp, 0                    ; Set sign flag
        neg   rax                       ; Negate number

spbs1:  div   r8                        ; Divide by base
        mov   [rsi+rcx+39], dl          ; Install digit in bsn
        test  rax, rax                  ; Test for zero
        jz    spbs2                     ; Finished
        xor   rdx, rdx                  ; Clear remainder
        add   rcx, 1                    ; Increment index/digit count
        jmp   spbs1                     ; Loop

spbs2:  mov   rbx, rcx                  ; Copy string length
        btr   rbp, 0                    ; Test and reset sign flag
        jnc   spbs3                     ; Jump if not negative
        neg   rbx                       ; Else negate string length
spbs3:  mov   [rsi+32], rbx             ; Install string length
        lea   rdi, [rsi+rcx+40]         ; Load address of end of string
        add   rcx, 40                   ; Add 40 to length for bsn size
        mov   [rsi], rcx                ; Install bsn size

        and   rcx, 7                    ; Determine pad bytes
        jz    spbs5                     ; Branch if none needed
        neg   rcx
        add   rcx, 8
        add   [rsi], rcx                ; Add pad bytes to bsn size

spbs4:  mov   byte[rdi], -1             ; Pad bsn to 64-bit boundary
        add   rdi, 1
        sub   rcx, 1
        jnz   spbs4

spbs5:  mov   [r14], rsi                ; Put bsn addr on stack
        nextm
datam

; uspi>bsn - Convert unsigned single precision number on the stack to a
; byte-string number at the address passed on the stack.

head    "uspi>bsn",nbco,hidden
usbsn:  dq  usbs0
textm
usbs0:  mov   r8, [r14]                 ; Get number base
        mov   rsi, [r14+8]              ; Get buffer address
        mov   rax, [r14+16]             ; Get number
        add   r14, 16                   ; Pop two stack items

        mov   qword[rsi+8], bsno        ; Set object type to bsn
        mov   qword[rsi+16], 1          ; Set number type to spi
        mov   [rsi+24], r8              ; Install number base

        xor   rdx, rdx                  ; Clear high order division register
        mov   rcx, 1                    ; Initialize count (at least 1 digit)

usbs1:  div   r8                        ; Divide by base
        mov   [rsi+rcx+39], dl          ; Install digit in bsn
        test  rax, rax                  ; Test for zero
        jz    usbs2                     ; Finished
        xor   rdx, rdx                  ; Clear remainder
        add   rcx, 1                    ; Increment index/digit count
        jmp   usbs1                     ; Loop

usbs2:  mov   [rsi+32], rcx             ; Install string length
        lea   rdi, [rsi+rcx+40]         ; Load address of end of string
        add   rcx, 40                   ; Add 40 to length for bsn size
        mov   [rsi], rcx                ; Install bsn size

        and   rcx, 7                    ; Determine pad bytes
        jz    usbs4                     ; Branch if none needed
        neg   rcx
        add   rcx, 8
        add   [rsi], rcx                ; Add pad bytes to bsn size

usbs3:  mov   byte[rdi], -1             ; Pad bsn to 64-bit boundary
        add   rdi, 1
        sub   rcx, 1
        jnz   usbs3

usbs4:  mov   [r14], rsi                ; Put bsn addr on stack
        nextm
datam

; mpi>bsn - Convert multi-precision number on the stack to a byte-string
; number at the address passed on the stack.

head    "mpi>bsn",nbco,hidden
mpbsn:  dq  mpbs0
textm
mpbs0:  xor   rbp, rbp                  ; Zero flags register
        mov   r8, [r14]                 ; Get number base
        mov   rsi, [r14+8]              ; Get buffer address
        add   r14, 16                   ; Pop top two items
        mov   r10, [qdsz0]              ; Get quadsize
        mov   qword[rsi+8], bsno        ; Set object type to bsn
        mov   qword[rsi+16], 2          ; Set number type to mpi
        mov   [rsi+24], r8              ; Install number base

        bt    qword[r14], 63            ; Test sign of number
        jnc   mpbs3                     ; Branch if not set
        bts   rbp, 0                    ; Set sign flag

        mov   rbx, r10                  ; Use CS for counter
mpbs1:  not   qword[r14+rbx*8-8]        ; Negate integer
        sub   rbx, 1                    ; Decrement counter
        jnz   mpbs1                     ; Loop for qsz
        mov   rbx, r10                  ; Reset loop counter
mpbs2:  add   qword[r14+rbx*8-8], 1     ; Add 1 until no carry
        jnc   mpbs3
        sub   rbx, 1                    ; Decrement counter
        jnz   mpbs2                     ; Loop for qsz

; Find leading non-zero quad.

mpbs3:  mov   rcx, r10                  ; Set loop counter
        xor   rdx, rdx                  ; Zero count/index
mpbs4:  cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   mpbs5                     ; Exit loop if not
        add   rdx, 1                    ; Increment index/count
        sub   rcx, 1
        jnz   mpbs4

; If loop falls through, number is zero.

        mov   rdx, 0xFFFFFFFFFFFFFF00
        mov   [rsi+40], rdx             ; Install padded zero byte
        mov   qword[rsi], 48            ; Install bsn length
        mov   qword[rsi+32], 1          ; Install digit count
        jmp   mpbs15                    ; Finish

mpbs5:  lea   r11, [r14+rdx*8]          ; Load temporary stack pointer
        mov   r9, rcx                   ; Save quad counter
        btr   rbp, 1                    ; Clear non-zero quotient flag

        xor   rdx, rdx                  ; Clear high order division register
        xor   rcx, rcx                  ; Clear digit counter
mpbs9:  mov   rdi, r11                  ; Set/reset temporary stack pointer
        mov   rbx, r9                   ; Set/reset inner loop counter

mpbs10: mov   rax, [rdi]                ; Get first/next stack quad
        add   rdi, 8                    ; Increment pointer
        div   r8                        ; Divide by number base
        mov   [rdi-8], rax              ; Return to stack
        test  rax, rax                  ; Test for zero quotient
        jz    mpbs11                    ; Jmp if quotient is zero
        bts   rbp, 1                    ; Set non-zero quotient flag

mpbs11: sub   rbx, 1                    ; Decrement counter
        jnz   mpbs10                    ; Loop for qsz count

        mov   [rsi+rcx+40], dl          ; Install digit in bsn
        add   rcx, 1                    ; Increment index/digit counter
        xor   rdx, rdx                  ; Clear high order division register

        btr   rbp, 1                    ; Test/clear zero-quotient flag
        jnc   mpbs12                    ; Done if quotient is zero

        jmp   mpbs9                     ; Else, continue processing

mpbs12: mov   rbx, rcx                  ; Copy string length
        btr   rbp, 0                    ; Test and reset sign flag
        jnc   mpbs13                    ; Jump if not negative
        neg   rbx                       ; Else negate string length
mpbs13: mov   [rsi+32], rbx             ; Install digit count
        lea   rdi, [rsi+rcx+40]         ; Load address of end of string
        add   rcx, 40                   ; Add 40 to length for bsn size
        mov   [rsi], rcx                ; Install bsn size

        and   rcx, 7                    ; Determine pad bytes
        jz    mpbs15                    ; Branch if none needed
        neg   rcx
        add   rcx, 8
        add   [rsi], rcx                ; Add pad bytes to bsn size

mpbs14: mov   byte[rdi], -1             ; Pad bsn to 64-bit boundary
        add   rdi, 1
        sub   rcx, 1
        jnz   mpbs14

mpbs15: mov   rbx, r10                  ; Copy qsz
        sub   rbx, 1                    ; Leave space for buffer addr
        shl   rbx, 3                    ; Pop mpi from stack
        add   r14, rbx
        mov   [r14], rsi                ; Put buffer addr on stack
        nextm
datam

; umpi>bsn - Convert unsigned multi-precision number on the stack to a
; byte-string number at the address passed on the stack.

head    "umpi>bsn",nbco,hidden
umbsn:  dq  umbs0
textm
umbs0:  mov   r8, [r14]                 ; Get number base
        mov   rsi, [r14+8]              ; Get buffer address
        add   r14, 16                   ; Pop top two items

        mov   r10, [qdsz0]              ; Get quadsize
        xor   rbp, rbp                  ; Zero flags register
        mov   qword[rsi+8], bsno        ; Set object type to bsn
        mov   qword[rsi+16], 2          ; Set number type to mpi
        mov   [rsi+24], r8              ; Install number base

; Find leading non-zero quad.

        mov   rcx, r10                  ; Set loop counter
        xor   rdx, rdx                  ; Zero count/index
umbs1:  cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   umbs2                     ; Exit loop if not
        add   rdx, 1                    ; Increment index/count
        sub   rcx, 1
        jnz   umbs1

; If loop falls through, number is zero.

        mov   rdx, 0xFFFFFFFFFFFFFF00
        mov   [rsi+40], rdx             ; Install padded zero byte
        mov   qword[rsi], 48            ; Install bsn length
        mov   qword[rsi+32], 1          ; Install digit count
        jmp   umbs8                     ; Finish

umbs2:  lea   r11, [r14+rdx*8]          ; Load temporary stack pointer
        mov   r9, rcx                   ; Save quad counter
        btr   rbp, 1                    ; Clear non-zero quotient flag

        xor   rdx, rdx                  ; Clear high order division register
        xor   rcx, rcx                  ; Clear digit counter
umbs3:  mov   rdi, r11                  ; Set/reset temporary stack pointer
        mov   rbx, r9                   ; Set/reset inner loop counter

umbs4:  mov   rax, [rdi]                ; Get first/next stack quad
        add   rdi, 8                    ; Increment pointer
        div   r8                        ; Divide by number base
        mov   [rdi-8], rax              ; Return to stack
        test  rax, rax                  ; Test for zero quotient
        jz    umbs5                     ; Jmp if quotient is zero
        bts   rbp, 1                    ; Set non-zero quotient flag

umbs5:  sub   rbx, 1                    ; Decrement counter
        jnz   umbs4                     ; Loop for qsz count

        mov   [rsi+rcx+40], dl          ; Install digit in bsn
        add   rcx, 1                    ; Increment index/digit counter
        xor   rdx, rdx                  ; Clear rdx

        btr   rbp, 1                    ; Test and clear zero-quotient flag
        jnc   umbs6                     ; Done if quotient is zero

        jmp   umbs3                     ; Else, continue processing

umbs6:  mov   [rsi+32], rcx             ; Install digit count
        lea   rdi, [rsi+rcx+40]         ; Load address of end of string
        add   rcx, 40                   ; Add 40 to length for bsn size
        mov   [rsi], rcx                ; Install bsn size

        and   rcx, 7                    ; Determine pad bytes
        jz    umbs8                     ; Branch if none needed
        neg   rcx
        add   rcx, 8
        add   [rsi], rcx                ; Add pad bytes to bsn size

umbs7:  mov   byte[rdi], -1             ; Pad bsn to 64-bit boundary
        add   rdi, 1
        sub   rcx, 1
        jnz   umbs7

umbs8:  mov   rbx, r10                  ; Copy qsz
        sub   rbx, 1                    ; Leave space for buffer addr
        shl   rbx, 3                    ; Pop mpi from stack
        add   r14, rbx
        mov   [r14], rsi                ; Put buffer addr on stack
        nextm
datam

; re>bsn - Convert a real number on the stack to a bsn at the address passed
; on the stack (default nob) according to the number base passed on the stack.
; After the conversion, the bsn is padded to an 8-byte boundary.
;
; Integer digits are developed by dividing the integer portion by the number
; base. The remainder of this division is the digit. The low order digits come
; out first and are placed in the bsn in reverse order. When all the digits are
; extracted, the dividend will be zero.
; The integer part of real numbers will always include the rounding overflow
; byte. The rob will be zero unless rounding propagates all the way past
; the highest order digit. In this case, the integer length will not be
; incremented. Instead, the bsn>ascii output routine will check the rob using
; the integer length as an offset and output the extra digit if it is not zero.
;
; Fraction digits are developed by multiplying the fractional portion of the
; real number by the number base. The final high order product is the digit.
; Unlike integer digit development, when processing fractions there is no
; simple way of determining when all digits are extracted. This is because,
; in general, radix oriented fractions cannot be expressed exactly in a given
; number base. Each digit is extracted by multiplying the fractional portion
; by the number base, but beyond the ability of the allocated fraction quads
; to contain them, the digits are no longer valid. Consquently, the criterion
; for determining when fraction digit development is complete is founded on
; calculating the power of the current number base that can be contained in a
; cell of the current quadsize. The cell is seeded with 1 and multiplied
; by the base each time through the fraction processing loop. When this
; calculation overflows, processing is considered complete.
; When the allocated quadsize is more than enough to contain as many digits
; as requested by the system variable, rdigs, rdigs+1 sets the limit of fraction
; digit development with the last digit being used for rounding.
; If during processing the fraction cell becomes zero, this means that
; the fraction could be expressed exactly in binary and processing is complete.
; The result will be padded with zeroes to the rdigs limit. No rounding is
; necessary.
; Fraction digits are developed until either the rdigs+1 limit is reached,
; the power-of-base calculation overflows, or the zero multiplicand condition
; is encountered. When the rdigs+1 limit is reached or the pob calculation
; overflows, the last digit is used to round to the previous digit.
; If the integer portion of the number is zero and no non-zero digits are developed
; by the time the rdigs+1 limit is reached or the power-of-base calculation
; overflows, the result underflows to zero, and the sign of the bsn is set
; to positive if it had been negative.

; Rstack frame usage:

;  [r15+24]  - r12
;  [r15+16]  - r11
;  [r15+8]   - flags
;  [r15]     - number of significant fraction quads | 0

; Register usage:

;    r12 - temporary stack pointer / rdigs counter
;    r11 - bsn base address
;    r10 - quad size
;    r9  - integer non-zero quad count
;    r8  - number base

; Flags:

;   0 - sign
;   1 - non-zero quotient
;   2 - overflow

head    "re>bsn", nbco, hidden
rebsn:  dq  rebs0
textm

rebs0:  sub   r15, 24                   ; Free up r12
        mov   [r15+16], r12
        mov   qword[r15+8], 0           ; Zero flags quad
        mov   r8, [r14]                 ; Get number base
        mov   r11, [r14+8]              ; Get buffer address
        add   r14, 16                   ; Pop top two items
        mov   r10, [qdsz0]              ; Get quadsize

; Initialize bsn. Set length to 40 - 32 for header plus 8 for integer length.

        mov   qword[r11], 40            ; Initialize bsn length
        mov   qword[r11+8], bsno        ; Set object type to bsn
        mov   qword[r11+16], 3          ; Set number type to real
        mov   [r11+24], r8              ; Install number base
        bt    qword[r14], 63            ; Test sign of number
        jnc   rebs3                     ; Branch if not set
        bts   qword[r15+8], 0           ; Set sign flag

; Negate real number if negative

        mov   rcx, r10
        shl   rcx, 1
        mov   rbx, rcx
rebs1:  not   qword[r14+rcx*8-8]
        sub   rcx, 1
        jnz   rebs1
rebs2:  add   qword[r14+rbx*8-8], 1
        jnc   rebs3
        sub   rbx, 1
        jnz   rebs2

; Find leading non-zero integer quad. If loop finishes before qsz counter
; is exhausted, the integer part is non-zero. Go process integer.

rebs3:  mov   rcx, r10                  ; Set loop counter
        xor   rdx, rdx                  ; Zero count/index
rebs4:  cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   rebs6                     ; Exit loop if not
        add   rdx, 1                    ; Increment index/count
        sub   rcx, 1
        jnz   rebs4

; If loop falls through, integer is zero. Check for real zero. If loop
; finishes before counter is exhausted, go process fraction.

        mov   rbx, r10
rebs5:  cmp   qword[r14+rdx*8], 0
        jnz   rebs12
        add   rdx, 1
        sub   rbx, 1
        jnz   rebs5

; If loop falls through, real number is zero.

        mov   qword[r11+32], 1          ; Install 1st string length
        mov   byte[r11+40], 0           ; Install zero integer byte
        mov   byte[r11+41], 0           ; Install zero rounding overflow byte
        mov   rdx, [rdgs0]              ; Get rdigs
        mov   [r11+42], rdx             ; Install rdigs for fraction length

; Add single integer byte, rounding overflow byte, 2nd string length, and rdigs
; to bsn size

        add   qword[r11], 10            ; Add integer digit, rob, and 2nd length
        add   [r11], rdx                ; Add rdigs

; Set up to install rdigs zeroes in fractional part.

        lea   rdi, [r11+50]             ; Load address of 2nd string
        jmp   rebs36                    ; Finish

; Set up to process integer. Set temporary stack pointer and quad counter.

rebs6:  lea   r12, [r14+rdx*8]          ; Load temporary stack pointer
        mov   r9, rcx                   ; Save quad counter
        btr   qword[r15+8], 1           ; Clear non-zero quotient flag

; Process integer part.

        xor   rdx, rdx                  ; Clear high order division register
        xor   rcx, rcx                  ; Clear digit counter

rebs7:  mov   rdi, r12                  ; Set/reset temporary stack pointer
        mov   rbx, r9                   ; Set/reset inner loop counter

rebs8:  mov   rax, [rdi]                ; Get first/next stack quad
        add   rdi, 8                    ; Advance pointer
        div   r8                        ; Divide by number base
        mov   [rdi-8], rax              ; Return to stack
        test  rax, rax                  ; Test for zero
        jz    rebs9                     ; Branch if dividend is zero
        bts   qword[r15+8], 1           ; Set non-zero quotient flag

rebs9:  sub   rbx, 1                    ; Decrement counter
        jnz   rebs8                     ; Loop for qsz count

        mov   [r11+rcx+40], dl          ; Install digit in bsn
        add   rcx, 1                    ; Increment index/digit counter
        xor   rdx, rdx                  ; Clear high order division register

        btr   qword[r15+8], 1           ; Test/clear non-zero quotient flag
        jnc   rebs10                    ; Go process fraction if quotient is zero

        jmp   rebs7                     ; Else continue processing

; The size of the bsn has been initialized to 40 bytes. Here we add the integer
; string length, rdigs for the fraction string length, 8 for the fraction length
; cell, and 1 for the rounding overflow byte.

rebs10: mov   byte[r11+rcx+40], 0       ; Install rounding overflow byte
        mov   [r11+32], rcx             ; Install 1st string length
        btr   qword[r15+8], 0           ; Test and reset sign flag
        jnc   rebs11                    ; Jump if not negative
        neg   qword[r11+32]             ; Else negate string length
rebs11: lea   rdi, [r11+rcx+41]         ; Load address of 2nd string
        mov   r12, [rdgs0]              ; Get rdigs
        mov   rdx, r12                  ; Make copy
        mov   [rdi], r12                ; Install for 2nd string length
        add   rdx, 9                    ; Add 9 for 2nd length cell and rob
        add   rdx, rcx                  ; Add integer string length
        add   [r11], rdx                ; Add to bsn size
        add   r12, 1                    ; Set up for fraction processing

; Process fractional part with non-zero integer. Underflow can't occur.

        mov   qword[r14+r10*8-8], 1     ; Seed power calculation
        lea   rsi, [r14+r10*8]          ; Advance to fraction
        xor   r9, r9                    ; Clear for digit count
        jmp   rebs22                    ; Branch to process fraction

; Set up to process fraction with zero integer part.

rebs12: mov   qword[r11+32], 1          ; Install 1st string length
        btr   qword[r15+8], 0           ; Test/clear sign flag
        jnc   rebs13                    ; Branch if flag was clear
        neg   qword[r11+32]             ; Negate sign

rebs13: mov   byte[r11+40], 0           ; Install zero integer byte
        mov   byte[r11+41], 0           ; Install zero rounding overflow byte
        mov   r12, [rdgs0]              ; Get rdigs
        mov   [r11+42], r12             ; Install rdigs for fraction length
        add   [r11], r12                ; Add to bsn size
        add   qword[r11], 10            ; Add integer digit, rob, and 2nd length
        add   r12, 1                    ; Add 1 to rdigs for rounding digit
        lea   rdi, [r11+42]             ; Load address of fraction string length

; Process fractional part with zero integer part. Processing with potential
; underflow is done in two stages. At first, we must flag non-zero digits in order
; to trap underflow, but as soon as there is a non-zero digit, no further testing
; is necessary, so we go to the next stage. Underflow occurs when there are no
; digits developed by the time the rdigs+1 limit is reached or the pob calculation
; overflows.

        lea   rsi, [r14+r10*8]          ; Advance to fraction
        xor   r9, r9                    ; Clear for digit count
        mov   qword[r14+r10*8-8], 1     ; Seed power calculation

rebs14: xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear for carry
        mov   rcx, r10                  ; Copy qsz

rebs15: mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; High order and carry
        jnc   rebs16                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit for next pass
rebs16: mov   [rsi+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   rebs15                    ; Loop for qsz

        mov   rbp, rdx                  ; Save developed digit

; Calculate next power of the base.

        xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear for carry
        mov   rcx, r10                  ; Copy qsz

rebs17: mov   rax, [r14+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add digit/high order
        jnc   rebs18                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit to high order
rebs18: mov   [r14+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   rebs17                    ; Loop for qsz

        bt    qword[r14], 63            ; Test high order bit
        jc    rebs19                    ; Branch if overflow
        test  rdx, rdx                  ; Check for overflow
        jnz   rebs19                    ; Branch if overflow

        sub   r12, 1                    ; Decrement rdigs+1
        jz    rebs20                    ; Branch if count exhausted

        mov   [rdi+r9+8], bpl           ; Install digit in bsn
        add   r9, 1                     ; Increment digit count

        cmp   rbp, 0                    ; See if digit is zero
        jnz   rebs22                    ; Branch to 2nd stage if not

        jmp   rebs14                    ; Else continue processing

rebs19: bts   qword[r15+8], 2           ; Set overflow flag

rebs20: mov   rbx, r8                   ; Copy number base
        shr   rbx, 1                    ; Halve number base
        cmp   rbp, rbx                  ; Compare base/2 with digit
        jc    rebs21                    ; Round down (underflow)

        add   byte[rdi+r9+7], 1         ; Add 1 to last digit
        jmp   rebs34                    ; Branch to finish

rebs21: bt    qword[r11+32], 63         ; Test bsn sign
        jnc   rebs34                    ; Branch if positive
        neg   qword[r11+32]             ; Else negate
        jmp   rebs34                    ; Branch to finish

; Process fraction without the possibility of underflow.
; During the 2nd stage of fraction processing, it is only necessary to monitor
; the non-zero multiplicand condition to see if the fraction can be expressed
; exactly in binary.

rebs22: xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear for carry
        mov   rcx, r10                  ; Copy qsz

rebs23: mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; High order and carry
        jnc   rebs24                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit for next pass
rebs24: mov   [rsi+rcx*8-8], rax        ; Install result on stack
        test  rax, rax                  ; See if quad is zero
        jz    rebs25                    ; Jump if zero
        bts   qword[r15+8], 1           ; Set non-zero quotient flag

rebs25: mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   rebs23                    ; Loop for qsz

        mov   rbp, rdx                  ; Save developed digit

; Calculate next power of the base.

        xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear for carry
        mov   rcx, r10                  ; Copy qsz

rebs26: mov   rax, [r14+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add digit/high order
        jnc   rebs27                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit to high order
rebs27: mov   [r14+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   rebs26                    ; Loop for qsz

        bt    qword[r14], 63            ; Test high order bit
        jc    rebs28                    ; Branch if overflow
        test  rdx, rdx                  ; Check for overflow
        jnz   rebs28                    ; Branch if overflow

        sub   r12, 1                    ; Decrement rdigs
        jz    rebs29                    ; Finished if rdigs exhausted

        mov   [rdi+r9+8], bpl           ; Install digit in bsn
        add   r9, 1                     ; Increment digit count

        btr   qword[r15+8], 1           ; Test non-zero quotient flag
        jnc   rebs35                    ; Exit early if clear

        jmp   rebs22                    ; Else continue processing

rebs28: bts   qword[r15+8], 2           ; Set overflow flag

; Round fractional part to last digit.

rebs29: mov   rcx, r9                   ; Copy digit count
        mov   rbx, r8                   ; Copy number base
        shr   rbx, 1                    ; Halve number base
        cmp   qword[r14+r10*8], -1      ; See if lead fraction quad is -1
        jnz   rebs30                    ; Branch if not

        add   rbp, 1                    ; Add 1 to final digit

rebs30: cmp   rbp, rbx                  ; Compare base/2 with digit
        jc    rebs34                    ; Round down (chop)

rebs31: add   byte[rdi+rcx+7], 1        ; Add 1 to last digit
        cmp   r8b, [rdi+rcx+7]          ; Compare digit with number base
        jnz   rebs34                    ; If not equal, no carry
        mov   byte[rdi+rcx+7], 0        ; Clear digit, carry to next
        sub   rcx, 1                    ; Decrement digit count
        jnz   rebs31

; If loop falls through, propagate carry into integer part.

        mov   rsi, r11                  ; Get bsn address
        mov   rcx, [rsi+32]             ; Get string length
        test  rcx, rcx                  ; See if negative
        jns   rebs32                    ; Branch if not
        neg   rcx                       ; Else negate

rebs32: xor   rdx, rdx                  ; Clear index register
rebs33: add   byte[rsi+rdx+40], 1       ; Add 1 to LS digit
        cmp   r8b, [rsi+rdx+40]         ; Compare digit with number base
        jnz   rebs34                    ; If not equal, no carry
        mov   byte[rsi+rdx+40], 0       ; Clear digit, carry to next
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement digit count
        jnz   rebs33                    ; Loop for digit count

; If loop falls through, install 1 in integer MS digit position but do not
; increment the integer length or the bsn size.

        mov   byte[rsi+rdx+40], 1       ; Install 1 digit

rebs34: btr   qword[r15+8], 2           ; Test/clear overflow flag
        jnc   rebs37                    ; Branch if flag was clear

; If rdigs is greater than the number of developed digits, pad with zeroes
; to the rdigs limit.

rebs35: lea   rdi, [rdi+r9+8]           ; Load address of last developed digit
        mov   rdx, [rdgs0]              ; Get rdigs
        sub   rdx, r9                   ; Find number of zeroes
        jz    rebs37                    ; Skip if none

rebs36: mov   byte[rdi+rdx-1], 0        ; Pad with zeroes
        sub   rdx, 1                    ; to rdigs limit
        jnz   rebs36

; Pad bsn to 64-bit boundary.

rebs37: mov   rdx, [r11]                ; Get bsn length
        mov   rcx, rdx                  ; Make copy
        and   rcx, 7                    ; Calculate padding bytes
        jz    rebs39                    ; No padding needed
        neg   rcx
        add   rcx, 8
        add   [r11], rcx                ; Add padding bytes to bsn length
        lea   rdi, [r11+rdx]            ; Load address of next byte
rebs38: mov   byte[rdi], 0xff           ; Pad bsn to 8-byte boundary
        add   rdi, 1                    ; Increment pointer
        sub   rcx, 1                    ; Decrement counter
        jnz   rebs38

rebs39: lea   r14, [r14+r10*8]          ; Pop power of base
        lea   r14, [r14+r10*8]          ; Pop fraction
        sub   r14, 8                    ; Push bsn addr
        mov   [r14], r11
        mov   r12, [r15+16]             ; Restore r12
        add   r15, 24
        nextm
datam

; ra>bsn - Convert rational number to byte-string number in the buffer
; whose address is passed on the stack (default: nob).
; After the conversion, the bsn is aligned on an 8-byte boundary.
; If the numerator is zero and the denominator is any non-zero positive number,
; the routine outputs 0/1 (rational zero). An error is thrown for either a zero
; denominator or a negative denominator.

; Flags:

;   0 - sign
;   1 - zero numerator
;   2 - non-zero quotient

head    "ra>bsn", nbco, hidden
rabsn:  dq  rabs0
textm
rabs0:  sub   r15, 8                    ; Free up r12
        mov   [r15], r12
        xor   rbp, rbp                  ; Clear flags register
        mov   r8, [r14]                 ; Get number base
        mov   r11, [r14+8]              ; Get buffer address
        add   r14, 16                   ; Pop two items
        mov   r10, [qdsz0]              ; Get quadsize

        bt    qword[r14], 63            ; Test sign of denominator
        jc    rabs19                    ; Throw error if negative

        mov   qword[r11], 40            ; Initialize bsn length to 40
        mov   qword[r11+8], bsno        ; Set object type to bsn
        mov   qword[r11+16], 4          ; Set number type to rational
        mov   [r11+24], r8              ; Install number base

        lea   r12, [r14+r10*8]          ; Load address of numerator
        bt    qword[r12], 63            ; Test sign of numerator
        jnc   rabs3                     ; Branch if not set

        bts   rbp, 0                    ; Set sign flag
        mov   rcx, r10                  ; Use qsz for counter
rabs1:  not   qword[r12+rcx*8-8]        ; Negate numerator
        sub   rcx, 1
        jnz   rabs1
        mov   rcx, r10                  ; Reset loop counter
rabs2:  add   qword[r12+rcx*8-8], 1     ; Add 1 until no carry
        jnc   rabs3
        sub   rcx, 1
        jnz   rabs2

; Find leading non-zero quad of numerator

rabs3:  btr   rbp, 1                    ; Clear zero numerator flag
        mov   rcx, r10                  ; Set loop counter
        xor   rdx, rdx                  ; Zero count/index
rabs4:  cmp   qword[r12+rdx*8], 0       ; See if quad is zero
        jnz   rabs5                     ; Exit loop if not
        add   rdx, 1                    ; Increment index/count
        sub   rcx, 1
        jnz   rabs4

; If loop falls through, numerator is zero.

        bts   rbp, 1                    ; Set zero numerator flag
        jmp   rabs11                    ; Branch to test denominator

; Process numerator.

rabs5:  lea   r12, [r12+rdx*8]          ; Load temporary stack pointer
        mov   r9, rcx                   ; Save quad counter
        btr   rbp, 2                    ; Clear non-zero quotient flag

        xor   rdx, rdx                  ; Clear remainder for division
        xor   rcx, rcx                  ; Clear digit counter

rabs6:  mov   rdi, r12                  ; Set/reset stack pointer
        mov   rbx, r9                   ; Set/reset inner loop counter

rabs7:  mov   rax, [rdi]                ; Get first/next stack quad
        add   rdi, 8                    ; Advance pointer
        div   r8                        ; Divide by number base
        mov   [rdi-8], rax              ; Return quotient to stack
        test  rax, rax                  ; Test for zero quotient
        jz    rabs8                     ; Branch if zero
        bts   rbp, 2                    ; Set non-zero quotient flag

rabs8:  sub   rbx, 1                    ; Decrement counter
        jnz   rabs7                     ; Loop for qsz count

        mov   [r11+rcx+40], dl          ; Install digit in bsn
        add   rcx, 1                    ; Increment digit counter
        xor   rdx, rdx                  ; Clear rdx

        btr   rbp, 2                    ; Test/clear non-zero quotient flag
        jnc   rabs9                     ; Done if quotient is zero

        jmp   rabs6                     ; Else, continue processing

rabs9:  mov   [r11+32], rcx             ; Install digit count
        btr   rbp, 0                    ; Test/clear sign flag
        jnc   rabs10                    ; Branch if flag was clear
        neg   qword[r11+32]             ; Negate numerator length

rabs10: add   [r11], rcx                ; Add to bsn length

; Set up to process denominator

        lea   rsi, [r11+rcx+40]         ; Load address of 2nd string
        add   qword[r11], 8             ; Add 8 to bsn size for length cell

; Find leading non-zero quad of denominator

rabs11: mov   rcx, r10                  ; Set loop counter
        xor   rdx, rdx                  ; Zero count/index
rabs12: cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   rabs13                    ; Exit loop if not
        add   rdx, 1                    ; Increment index/count
        sub   rcx, 1
        jnz   rabs12

; If loop falls through, denominator is zero. The value of the numerator
; is irrelavent.

        btr   rbp, 1                    ; Clear zero numerator flag
        jmp   rabs20                    ; Throw zero denominator

; Process denominator. First test if numerator is zero, and, if so, output
; 0/1. The denominator is irrelavent.

rabs13: btr   rbp, 1                    ; Test/clear zero numerator flag
        jc    rabs18                    ; Branch if flag was set

        lea   r12, [r14+rdx*8]          ; Load temporary stack pointer
        mov   r9, rcx                   ; Save quad counter
        btr   rbp, 2                    ; Clear non-zero quotient flag

        xor   rdx, rdx                  ; Clear remainder for division
        xor   rcx, rcx                  ; Clear digit counter

rabs14: mov   rdi, r12                  ; Set/reset stack pointer
        mov   rbx, r9                   ; Set/reset inner loop counter

rabs15: mov   rax, [rdi]                ; Get first/next stack quad
        add   rdi, 8                    ; Advance pointer
        div   r8                        ; Divide by number base
        mov   [rdi-8], rax              ; Return quotient to stack
        test  rax, rax                  ; Test for zero quotient
        jz    rabs16                    ; Branch if zero
        bts   rbp, 2                    ; Set non-zero quotient flag

rabs16: sub   rbx, 1                    ; Decrement counter
        jnz   rabs15                    ; Loop for qsz count

        mov   [rsi+rcx+8], dl           ; Install digit in bsn
        add   rcx, 1                    ; Increment digit counter
        xor   rdx, rdx                  ; Clear rdx

        btr   rbp, 2                    ; Test/clear zero-quotient flag
        jnc   rabs17                    ; Done if quotient is zero

        jmp   rabs14                    ; Else, continue processing

rabs17: mov   [rsi], rcx                ; Install digit count
        add   [r11], rcx                ; Add to bsn length
        jmp   rabs21

; If numerator is zero and denominator is non-zero, output 0/1.

rabs18: mov   qword[r11], 56            ; Object length
        mov   qword[r11+8], bsno        ; Object type
        mov   qword[r11+16], 4          ; Rational number
        mov   qword[r11+32], 1          ; Install integer digit count
        mov   byte[r11+40], 0           ; Install zero digit
        mov   qword[r11+41], 1          ; Install fraction digit count
        mov   byte[r11+49], 1           ; Install fraction digit
        mov   dword[r11+50], -1         ; Pad to 8-byte boundary
        mov   word[r11+54], -1
        jmp   rabs23                    ; Done

; If denominator is negative, throw 31

rabs19: mov   r12, [r15]                ; Restore r12
        add   r15, 8

        throwm 31                       ; Denominator is negative

; If denominator is zero, throw 30.

rabs20: mov   r12, [r15]                ; Restore r12
        add   r15, 8

        throwm 30                       ; Denominator is zero

; Pad bsn to 64-bit boundary

rabs21: mov   rdx, [r11]                ; Get bsn length
        and   rdx, 7                    ; See if padding needed
        jz    rabs23                    ; Branch if  not

        neg   rdx                       ; Calculate pad bytes
        add   rdx, 8
        add   [r11], rdx                ; Add to bsn size
        lea   rsi, [rsi+rcx+8]          ; Offset to end of bsn

rabs22: mov   byte[rsi], 0xff           ; Pad bsn to 8-byte boundary
        add   rsi, 1                    ; Increment pointer
        sub   rdx, 1                    ; Decrement counter
        jnz   rabs22

rabs23: lea   r14, [r14+r10*8]          ; Pop denominator
        lea   r14, [r14+r10*8-8]        ; Pop numerator minus 1 quad
        mov   [r14], r11
        mov   r12, [r15]                ; Restore r12
        add   r15, 8
        nextm
datam

; fl>bsn - Convert floating-point number on the stack to a byte-string
; number in the base passed on the stack at the address passed on the stack.
; When converting from floating-point to a byte-string number, it is
; not necessary to actually perform quad shifts. Instead, find the total shift
; count, isolate the quad shift count from the bit shift count, shift by the bit
; count, then use the quad shift count to separate the integer part from the
; fraction. Keep track of the exponents while processing the integer and
; the fractional part. The count of developed digits starting with 0 for the
; first digit will be the exponent if there is an integer part. The negative
; count of leading zero digits minus 1 will be the exponent if there are no
; integer digits. The integer part of the bsn always contains the rounding
; overflow byte (rob).
; The stack pointer, after popping the buffer address and the number base, is
; copied to another register where the floating-point number is virtually
; popped, and the register is placed in the return stack frame for correct
; restoration of the stack at the end of the routine. This enables free use
; of the stack during processing without having to consider special cases of
; stack use, for example when there are no integer digits and the fraction has
; leading zeroes.

; Rstack frame usage:

;  [r15+32]  - r12
;  [r15+24]  - r11
;  [r15+16]  - data stack pointer
;  [r15+8]   - bsn exponent
;  [r15]     - quad shift count

; Register usage

;    r12 - integer quadsize / rdigs fraction digit counter
;    r11 - bsn base address
;    r10 - quad size
;    r9  - 2*qsz-1 / fraction digit count
;    r8  - number base
;    rdi - scratch / addressing
;    rsi - scratch / addressing / temporary stack pointer
;    rdx - scratch index / division & multiplication
;    rcx - shifting / counter
;    rbx - scratch
;    rax - scratch / division & multiplication

; Flags

;   0  - sign
;   1  - non-zero digit
;   2  - non-zero result
;   3  - overflow

head    "fl>bsn", nbco, hidden
flbsn:  dq  flbs0
textm
flbs0:  sub   r15, 32                   ; Create rstack frame
        mov   [r15+24], r12             ; Free up r12
        xor   rbp, rbp                  ; Zero flags register
        mov   r8, [r14]                 ; Get number base
        mov   r11, [r14+8]              ; Get buffer address
        add   r14, 16                   ; Pop top two stack items
        mov   r10, [qdsz0]              ; Get quadsize
        mov   r9, r10                   ; Copy system qsz
        shl   r9, 1                     ; Double it.
        lea   rdi, [r14+r9*8]           ; Pop number virtually
        mov   [r15+16], rdi             ; Save virtual stack pointer
        mov   rdx, [r14]                ; Get exponent
        mov   qword[r14], 0             ; Clear exponent cell
        btr   rdx, 63                   ; Test/clear sign bit
        jnc   flbs1
        bts   rbp, 0                    ; Set sign flag

flbs1:  cmp   rdx, 0                    ; See if exponent is zero
        jnz   flbs3                     ; Branch if not

; Number is zero. Install floating-point zero in bsn and finish.
; The bsn length for floating-point zero will be 32 for the header, plus 24
; for the integer, fraction, and exponent length cells, plus 4 for the zero
; integer, rounding overflow byte, zero fraction, and zero exponent - 59 bytes
; with 4 pad bytes for 64.

flbs2:  mov   qword[r11], 64            ; Install bsn length
        mov   qword[r11+8], bsno        ; Set object type to bsn
        mov   qword[r11+16], 5          ; Set number type to floating-point
        mov   [r11+24], r8              ; Install number base
        mov   qword[r11+32], 1          ; Install 1 for integer length
        mov   byte[r11+40], 0           ; Install single integer digit
        mov   byte[r11+41], 0           ; Install rounding overflow byte
        mov   qword[r11+42], 1          ; Install 1 for fraction length
        mov   byte[r11+50], 0           ; Install single fraction digit
        mov   qword[r11+51], 1          ; Install 1 for exponent length
        mov   byte[r11+59], 0           ; Install single exponent digit
        mov   dword[r11+60], -1         ; Install pad bytes
        jmp   flbs77

; Initialize bsn. Set length to 40 - 32 for header plus 8 for integer length.

flbs3:  mov   qword[r11], 40            ; Initialize bsn length
        mov   qword[r11+8], bsno        ; Set object type to bsn
        mov   qword[r11+16], 5          ; Set number type to floating-point
        mov   [r11+24], r8              ; Install number base
        mov   qword[r15+8], -1          ; Initialize exponent to -1

; Initialize temporary stack pointer to current stack pointer.

        mov   rsi, r14

; The total shift count is derived from the formula:
; exp = [64*(qsz-1)-1] - shift + bias
; giving:
; shift = bias - exp + 64*qsz - 65

        mov   qword[r15], -1            ; Initialize quad shift count to -1
        sub   r9, 1                     ; 2*qsz-1
        mov   rcx, 0x3FFFFFFFFFFFFFFF   ; Put exponent bias in register
        sub   rcx, rdx                  ; Subtract exponent
        sub   rcx, 65                   ; Subtract 65
        mov   rbx, r10                  ; Copy quad size
        shl   rbx, 6                    ; Multiply by 64
        add   rcx, rbx                  ; Add for total shift count
        bt    rcx, 63                   ; See if total shift count is negative
        jc    flbs6                     ; Branch if so

        mov   [r15], rcx                ; Copy total shift count
        shr   qword[r15], 6             ; Convert to quads
        and   rcx, 63                   ; Extract bit shift count
        jz    flbs12                    ; Branch if no bits to shift

; Shift number right by bit shift count.

        mov   rbx, r9                   ; Set count to 2*qsz-1
        cmp   rbx, 1                    ; See if count is 1 quad
        jz    flbs5                     ; Branch if so
flbs4:  mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, cl
        sub   rbx, 1                    ; Decrement index/count
        jnz   flbs4
flbs5:  shr   qword[r14+rbx*8], cl      ; Shift single quad

        jmp   flbs12

; If the total shift count is negative, this means that the integer part
; and the fractional part each occupy qsz quads. The shift count should be
; negated, and the number shifted to the left. If the shift count is 64,
; move quads left one cell. This case is merely to avoid including overflow
; in the re>fl routine. The only way it can overflow is when a mantissa
; of 8000000000000000 followed by 2*qsz-1 zeroes occurs. I will probably
; include an overflow check in re>fl and bsn>fl for this special case.

flbs6:  neg   rcx                       ; Negate shift count
        cmp   rcx, 64                   ; See if count is 64
        jnz   flbs9                     ; Branch if not

flbs7:  xor   rdx, rdx                  ; Clear index register
        mov   rbx, r9                   ; Set counter to 2*qsz-1
flbs8:  mov   rax, [r14+rdx*8+8]        ; Move quads left
        mov   [r14+rdx*8], rax
        add   rdx, 1
        sub   rbx, 1
        jnz   flbs8
        mov   qword[r14+rdx*8], 0       ; Clear low order quad
        jmp   flbs11

flbs9:  xor   rdx, rdx                  ; Clear index register
        mov   rbx, r9                   ; Use 2*qsz-1 for counter
flbs10: mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   flbs10
        shl   qword[r14+rdx*8], cl      ; Shift single quad

; The integer takes qsz quads. The temporary stack pointer has already been
; initialized for no leading zero quads. Set inner loop counter to qsz.

flbs11: mov   r12, r10                  ; Set inner loop counter to qsz
        jmp   flbs41                    ; Go process integer

; Integer takes qsz-quadshift-1 quads.

flbs12: mov   r12, r10                  ; Copy qsz
        sub   r12, 1                    ; Subtract 1

; If quadshift is qsz-1 or more, the integer part is zero.

        sub   r12, [r15]                ; Subtract quadshift
        jg    flbs40                    ; Process integer if greater

; Set integer part to zero and process fraction.

        mov   rbx, 1                    ; Put integer length in register
        btr   rbp, 0                    ; Test and reset sign flag
        jnc   flbs13                    ; Jump if not negative
        neg   rbx                       ; Negate length
flbs13: mov   [r11+32], rbx             ; Install 1st string length
        mov   byte[r11+40], 0           ; Install single integer digit
        mov   byte[r11+41], 0           ; Install rounding overflow byte
        add   qword[r11], 2             ; Add 2 to bsn length
        lea   rdi, [r11+42]             ; Advance to 2nd string addr
        mov   r12, [rdgs0]              ; Get rdigs
        add   r12, 1                    ; Add 1 for integer digit
        mov   [r11+42], r12             ; Install in fraction length
        add   [r11], r12                ; Add to bsn size
        add   qword[r11], 8             ; Add fraction length cell

; Before processing it is necessary to determine the number of lead quads
; belonging to the fraction. This is given by the quadshift+1-qsz with one
; lead quad already existing in the zeroed exponent cell. Any additional lead
; quads will then be provided. Remember that the popped stack pointer has been
; saved in the return stack frame.
;
; Note: As many as (2*qsz-1) quads could be processed, but because floating
; point input processing currently involves first converting the input bsn
; to a real number and then to floating-point, the fraction will never be more
; than qsz quads.

        mov   rdx, [r15]                ; Get quadshift
        add   rdx, 1                    ; Add 1
        sub   rdx, r10                  ; Subtract qsz
        jnz   flbs14                    ; Branch if there are lead quads

; Offset temporary stack pointer to fraction and go process.

        lea   rsi, [r14+8]
        jmp   flbs16

; Subtract 1 for exponent cell. If no additional lead quads are needed,
; the temporary stack pointer is already set to the zeroed exponent cell.

flbs14: sub   rdx, 1                    ; Subtract 1 for exponent cell
        jz    flbs16                    ; Branch if zero

flbs15: sub   r14, 8                    ; Provide additional lead quads
        mov   qword[r14], 0
        sub   rdx, 1
        jnz   flbs15
        mov   rsi, r14                  ; Set temporary stack pointer

; Process fractional part with zero integer part. The temporary stack pointer
; is already in rsi. The number of digits developed should be two more than
; rdigs, since one digit will be used for the integer part and another
; for rounding. The fraction length will be rdigs+1 unless rounding carries
; into the integer part, in which case the fraction length will be reduced
; to rdigs, and the bsn size decremented by 1.

flbs16: add   r12, 1                    ; Add 1 for rounding
        sub   r14, 8                    ; Clear stack space and
        mov   qword[r14], 1             ; seed power calculation
        mov   rdx, r10
        sub   rdx, 1
        jz    flbs18
flbs17: sub   r14, 8
        mov   qword[r14], 0
        sub   rdx, 1
        jnz   flbs17

flbs18: btr   rbp, 1                    ; Clear non-zero digit flag
        xor   r9, r9                    ; Clear for digit count

; In the first stage of processing we must keep track of the exponent and flag
; non-zero digits in order to trap underflow, but as soon as a non-zero digit
; is encountered, no further testing is necessary, so we go to the next stage.
; Underflow occurs when there are no digits developed by the time the rdigs+1
; limit is reached or the pob calculation overflows.

flbs19: xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear for carry
        mov   rcx, r10                  ; Copy qsz

flbs20: mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; High order and carry
        jnc   flbs21                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit for next pass
flbs21: mov   [rsi+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   flbs20                    ; Loop for qsz

        cmp   rdx, 0                    ; See if digit is zero
        jnz   flbs22                    ; Branch if not

        sub   qword[r15+8], 1           ; Decrement exponent
        add   r12, 1                    ; Increment rdigs
        jmp   flbs23

flbs22: bts   rbp, 1                    ; Set non-zero digit flag
        mov   [rdi+r9+8], dl            ; Install digit in bsn
        add   r9, 1                     ; Increment digit count

; Calculate next power of the base.

flbs23: xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear for carry
        mov   rcx, r10                  ; Copy qsz

flbs24: mov   rax, [r14+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add digit/high order
        jnc   flbs25                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit to high order
flbs25: mov   [r14+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   flbs24                    ; Loop for qsz

; Throw underflow regardless of whether there was a digit found, since
; last digit is likely to be unreliable.

        bt    qword[r14], 63            ; Test high order bit
        jc    flbs76                    ; Throw underflow
        test  rdx, rdx                  ; Check for overflow
        jnz   flbs76                    ; Throw underflow

        sub   r12, 1                    ; Decrement rdigs+1
        jz    flbs26                    ; Branch if rdigs+1 exhausted

        btr   rbp, 1                    ; Test/clear non-zero digit flag
        jc    flbs27                    ; Branch to 2nd stage if flag was set

        jmp   flbs19                    ; Else continue processing

; If the rdigs+1 count is exhausted, see if a digit was developed beforehand.

flbs26: btr   rbp, 1                    ; Test/clear non-zero digit flag
        jnc   flbs76                    ; Throw underflow

; If a digit was developed before rdigs+1 was exhausted, use it to round
; the next-to-last digit. If that digit rounds down, throw underflow.
; If it rounds up there will be a 1 in the lowest order of the fraction.
; (This is really splitting hairs!)

        mov   rbx, r8                   ; Copy number base
        shr   rbx, 1                    ; Halve number base
        cmp   [rdi+r9+7], bl            ; Compare digit with base/2
        jc    flbs76                    ; Round down. Throw underflow
        mov   byte[rdi+r9+6], 1         ; Else install 1 in previous digit
        jmp   flbs38                    ; and go finish

; During the 2nd stage of fraction processing, it is only necessary to monitor
; the non-zero multiplicand condition to see if the fraction can be expressed
; exactly in binary.

flbs27: xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear for carry
        mov   rcx, r10                  ; Copy qsz

flbs28: mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add high order and carry
        jnc   flbs29                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit for next pass
flbs29: mov   [rsi+rcx*8-8], rax        ; Install result on stack
        test  rax, rax                  ; See if quad is zero
        jz    flbs30                    ; Jump if zero
        bts   rbp, 2                    ; Set non-zero result flag

flbs30: mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   flbs28                    ; Loop for qsz

        mov   [rdi+r9+8], dl            ; Install digit in bsn
        add   r9, 1                     ; Increment digit count

; Calculate next power of the base.

        xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear for carry
        mov   rcx, r10                  ; Copy qsz

flbs31: mov   rax, [r14+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add digit/high order
        jnc   flbs32                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit to high order
flbs32: mov   [r14+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   flbs31                    ; Loop for qsz

        bt    qword[r14], 63            ; Test high order bit
        jc    flbs33                    ; Exit if overflow
        test  rdx, rdx                  ; Check for overflow
        jnz   flbs33                    ; Exit if overflow

        sub   r12, 1                    ; Decrement rdigs
        jz    flbs34                    ; Finished if rdigs exhausted

        btr   rbp, 2                    ; Test non-zero result flag
        jnc   flbs38                    ; Exit early if clear
        jmp   flbs27                    ; Else continue processing

; If overflow occurred, test if there were any non-zero digits, and if not
; throw underflow on output. Otherwise, abandon last digit, increment exponent,
; and use next-to-last digit for rounding.

flbs33: sub   r9, 1                     ; Subtract one for last digit
        bts   rbp, 3                    ; Set overflow flag
        movzx rax, byte[rdi+r9+8]       ; Get next-to-last digit
        mov   rcx, r9                   ; Copy fraction digit count
        jmp   flbs35                    ; Go round

; If rdigs counter is exhausted, that means that there is one more digit
; than rdigs itself to use for rounding. The fraction length will be set
; to rdigs+1.

flbs34: mov   rcx, r9                   ; Copy for index/counter
        movzx rax, byte[rdi+rcx+7]      ; Get last digit
        mov   byte[rdi+rcx+7], 0        ; Zero last digit
        sub   rcx, 1                    ; Decrement counter

; Round fractional part to rdigs limit, or to next-to-last digit if overflow
; occurred.

flbs35: mov   rbx, r8                   ; Copy number base
        shr   rbx, 1                    ; Halve number base
        cmp   rbx, rax                  ; Compare digit with base/2
        jg    flbs37                    ; Round down (chop)

flbs36: add   byte[rdi+rcx+7], 1        ; Add 1 to digit
        cmp   r8b, [rdi+rcx+7]          ; Compare digit with number base
        jnz   flbs37                    ; If not equal, no carry
        mov   byte[rdi+rcx+7], 0        ; Clear digit, carry to next
        sub   rcx, 1                    ; Decrement digit count
        jnz   flbs36

; If loop falls through, install 1 in the integer byte and subtract 1 from
; the fraction length and the bsn length. Add 1 to the exponent.

        add   qword[r15+8], 1           ; Add 1 to fraction exponent
        mov   byte[r11+40], 1           ; Install 1 in integer digit
        sub   qword[r11+42], 1          ; Decrement fraction length
        sub   qword[r11], 1             ; Decrement bsn length

flbs37: mov   rsi, [r11]                ; Get bsn length so far
        lea   rsi, [r11+rsi]            ; Load address of exponent length
        btr   rbp, 3                    ; Test/clear overflow flag
        jnc   flbs70                    ; Branch if flag was clear

; If rdigs is greater than the number of developed digits, pad with zeroes
; to the rdigs limit.

flbs38: lea   rdi, [rdi+r9+8]           ; Load address of last developed digit
        mov   rdx, [rdgs0]              ; Get rdigs
        sub   r9, 1                     ; Subtract 1 for extra digit
        sub   rdx, r9                   ; Find number of zeroes
        jz    flbs70                    ; Go process exponent if none

flbs39: mov   byte[rdi], 0              ; Pad with zeroes
        add   rdi, 1                    ; to rdigs limit
        sub   rdx, 1
        jnz   flbs39
        jmp   flbs70                    ; Go process exponent

; Process integer part. The entire integer must be processed, even if rdigs+1
; is less than the number of integer digits, since the lower order digits are
; generated first. Afterward, Rounding can take place from the digit beyond
; the rdigs+1 limit and all remaining digits zeroed.
; Once the integer is processed, if the exponent is rdigs or more, there is
; no need to process the fraction, since the integer will be normalized
; on output to have a single digit to the left of the radix point.

flbs40: lea   rsi, [r14+8]              ; Normal stack pointer offset is one quad

flbs41: xor   rdx, rdx                  ; Clear high order division register
        xor   rcx, rcx                  ; Clear digit counter
flbs42: mov   rdi, rsi                  ; Set/reset temporary stack pointer
        mov   rbx, r12                  ; Set/reset inner loop counter
flbs43: mov   rax, [rdi]                ; Get first/next stack quad
        add   rdi, 8                    ; Increment pointer
        div   r8                        ; Divide by number base
        mov   [rdi-8], rax              ; Return to stack
        test  rax, rax                  ; Test for zero quotient
        jz    flbs44                    ; Jmp if quotient is zero
        bts   rbp, 2                    ; Set non-zero quotient flag
flbs44: sub   rbx, 1                    ; Decrement counter
        jnz   flbs43                    ; Loop for qsz count
        mov   [r11+rcx+40], dl          ; Install digit in bsn
        add   rcx, 1                    ; Increment index/digit counter
        xor   rdx, rdx                  ; Clear rdx
        btr   rbp, 2                    ; Test and clear zero-quotient flag
        jnc   flbs45                    ; Done if quotient is zero
        jc    flbs42                    ; Else continue processing

flbs45: mov   byte[r11+rcx+40], 0       ; Install rounding overflow byte
        add   qword[r11], 1             ; Add 1 to bsn size
        mov   rbx, rcx                  ; Copy string length
        sub   rbx, 1                    ; Minus 1 for exponent
        mov   [r15+8], rbx              ; Save exponent in rstack frame
        add   rbx, 1                    ; Add 1 for string length
        btr   rbp, 0                    ; Test and reset sign flag
        jnc   flbs46                    ; Jump if not negative
        neg   rbx                       ; Else negate string length

flbs46: mov   [r11+32], rbx             ; Install 1st string length
        add   [r11], rcx                ; Add length to bsn size

; Compare the number of developed digits to rdigs+1. If rdigs+1 is greater,
; develop the difference in fraction digits. If they are equal, we're done.
; If rdigs+1 is less, round from rdigs+2 and ignore remaining digits.

        mov   r9, [rdgs0]               ; Get rdigs
        add   r9, 1                     ; Add 1
        cmp   rcx, r9                   ; Compare with number of digits
        jc    flbs48                    ; Branch if rdigs+1 is greater

; The number of integer digits is less than or equal to rdigs+1. There is no
; fractional part.

        add   qword[r11], 9             ; Add fraction length and byte
        mov   qword[r11+rcx+41], 1      ; Set fraction length to 1
        mov   byte[r11+rcx+49], 0       ; Install 0 fraction byte

; See if rdigs+1 is equal to number of integer digits.

        cmp   rcx, r9                   ; See if equal
        jz    flbs70                    ; Go process exponent if so

; Number of integer digits is greater than rdigs+1. Round from rdigs+2,
; ignore remaining digits, and process exponent.

        mov   rax, rcx                  ; Find location of rounding digit
        sub   rax, r9
        lea   rsi, [r11+rax+40]         ; Load address of rounding digit
        mov   rbx, r8                   ; Copy number base
        shr   rbx, 1                    ; Halve number base
        cmp   bl, [rsi-1]               ; Compare digit with base/2
        jg    flbs70                    ; Round down (chop) and process exponent

        xor   rdx, rdx                  ; Clear index register
        mov   rbx, rcx                  ; Copy digit count for counter
flbs47: add   byte[rsi+rdx], 1          ; Add 1 to LS digit
        cmp   r8b, [rsi+rdx]            ; Compare digit with number base
        jnz   flbs70                    ; No carry, go process exponent
        mov   byte[rsi+rdx], 0          ; Clear digit, carry to next
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement digit count
        jnz   flbs47                    ; Loop for digit count

; If loop falls through, install 1 in integer MS digit position, but leave
; the integer length the same.

        mov   byte[rsi+rdx+40], 1       ; Install 1 digit
        jmp   flbs70                    ; Go process exponent

; If the number of digits is less than rdigs, process as many fraction digits
; as rdigs+1 minus the number of integer digits. The temporary stack pointer
; offset is set to 8*(integer quad count + 1).

flbs48: mov   [r15+8], rcx              ; Save string length as exponent+1
        sub   qword[r15+8], 1           ; Subtract 1 for actual exponent
        lea   rdi, [r11+rcx+41]         ; Load address of 2nd string
        cmp   r12, r10                  ; See if integer and fraction parts are equal
        jz    flbs49                    ; Branch if so

        lea   rsi, [r14+r12*8+8]        ; Set fraction pointer
        cmp   r10, 1                    ; See if qsz is 1
        jnz   flbs50                    ; Continue if not

        sub   rsi, 8                    ; Back up fraction pointer
        jmp   flbs50                    ; Continue

flbs49: lea   rsi, [r14+r12*8]          ; Advance to fraction

flbs50: mov   r12, [rdgs0]              ; Get rdigs
        add   r12, 1                    ; Add 1 for single integer digit
        sub   r12, rcx                  ; Subtract integer digit count
        mov   [rdi], r12                ; Install fraction length
        add   [r11], r12                ; Add to bsn size
        add   qword[r11], 8             ; Add length cell to bsn size
        add   r12, 1                    ; Add 1 for rounding

; Clear stack space and seed power calculation.

        mov   r9, rcx                   ; Copy integer digit count
        mov   rdx, r10                  ; Clear stack space and
        neg   rdx                       ; seed power calculation
        lea   r14, [r14+rdx*8]
        neg   rdx
        mov   qword[r14+rdx*8-8], 1
        sub   rdx, 1
        jz    flbs52
flbs51: mov   qword[r14+rdx*8-8], 0
        sub   rdx, 1
        jnz   flbs51

; Seed pob calculation with base**n, where n is the number of integet digits.

flbs52: xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx
        mov   rcx, r10                  ; Copy qsz
flbs53: mov   rax, [r14+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add digit/high order
        jnc   flbs54                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit to high order
flbs54: mov   [r14+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   flbs53                    ; Loop for qsz

        sub   r9, 1
        jnz   flbs52

        xor   r9, r9                    ; Clear for digit count
flbs55: xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear for carry
        mov   rcx, r10                  ; Copy qsz
flbs56: mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; High order and carry
        jnc   flbs57                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit for next pass
flbs57: mov   [rsi+rcx*8-8], rax        ; Install result on stack
        test  rax, rax                  ; See if quad is zero
        jz    flbs58                    ; Jump if zero
        bts   rbp, 2                    ; Set non-zero result flag

flbs58: mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   flbs56                    ; Loop for qsz

        mov   [rdi+r9+8], dl            ; Install digit in bsn
        add   r9, 1                     ; Increment digit count

; Calculate next power of base.

        xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx
        mov   rcx, r10                  ; Copy qsz

flbs59: mov   rax, [r14+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add digit/high order
        jnc   flbs60                    ; Jump if no carry
        add   rdx, 1                    ; Add carry bit to high order
flbs60:  mov   [r14+rcx*8-8], rax       ; Install result on stack
        mov   rbx, rdx                  ; Copy high order to rbx
        sub   rcx, 1                    ; Decrement counter
        jnz   flbs59                    ; Loop for qsz

        bt    qword[r14], 63            ; Test high order bit
        jc    flbs61                    ; Exit if overflow
        test  rdx, rdx                  ; Check for overflow
        jnz   flbs61                    ; Exit if overflow

        sub   r12, 1                    ; Decrement rdigs
        jz    flbs62                    ; Finished if rdigs exhausted

        btr   rbp, 2                    ; Test non-zero result flag
        jnc   flbs68                    ; Exit early if clear
        jmp   flbs55                    ; Else continue processing

; If overflow occurred, abandon last digit, and use next-to-last digit
; for rounding

flbs61: sub   r9, 2                     ; Subtract two for last two digits
        bts   rbp, 3                    ; Set overflow flag
        movzx rax, byte[rdi+r9+8]       ; Get next-to-last digit
        mov   rcx, r9                   ; Copy fraction digit count
        jmp   flbs63                    ; Go round

; If rdigs counter is exhausted, that means that there is one more digit
; than rdigs itself to use for rounding. The fraction length will be set
; to rdigs.

flbs62: mov   rcx, r9                   ; Copy for index/counter
        movzx rax, byte[rdi+rcx+7]      ; Get last digit
        mov   byte[rdi+rcx+7], 0        ; Zero last digit
        sub   rcx, 1                    ; Decrement counter

; Round fractional part to rdigs limit, or to next-to-last digit if overflow
; occurred.

flbs63: mov   rbx, r8                   ; Copy number base
        shr   rbx, 1                    ; Halve number base
        cmp   rbx, rax                  ; Compare digit with base/2
        jg    flbs67                    ; Round down (chop)

flbs64: add   byte[rdi+rcx+7], 1        ; Add 1 to digit
        cmp   r8b, [rdi+rcx+7]          ; Compare digit with number base
        jnz   flbs67                    ; If not equal, no carry
        mov   byte[rdi+rcx+7], 0        ; Clear digit, carry to next
        sub   rcx, 1                    ; Decrement digit count
        jnz   flbs64

; If loop falls through, propagate carry into integer part.

        mov   rsi, r11                  ; Get bsn address
        mov   rcx, [rsi+32]             ; Get string length
        test  rcx, rcx                  ; See if negative
        jns   flbs65                    ; Branch if not
        neg   rcx                       ; Else negate

flbs65: xor   rdx, rdx                  ; Clear index register
flbs66: add   byte[rsi+rdx+40], 1       ; Add 1 to LS digit
        cmp   r8b, [rsi+rdx+40]         ; Compare digit with number base
        jnz   flbs67                    ; If not equal, no carry
        mov   byte[rsi+rdx+40], 0       ; Clear digit, carry to next
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement digit count
        jnz   flbs66                    ; Loop for digit count

; If loop falls through, install 1 in rounding overflow byte, decrement
; the fraction length and bsn size, and increment the exponent. Note that
; the exponent will be positive, since there are integer digits.

        mov   byte[rsi+rdx+40], 1       ; Install 1 digit
        sub   qword[rsi+rdx+41], 1      ; Decrement fraction length
        sub   qword[rsi], 1             ; Decrement bsn size
        add   qword[r15+8], 1           ; Increment exponent

flbs67: btr   rbp, 3                    ; Test/clear overflow flag
        jnc   flbs70                    ; Go process exponent if flag was clear

; If rdigs is greater than the number of developed digits, pad with zeroes
; to the rdigs limit.

flbs68: lea   rdi, [rdi+r9+8]           ; Load address of last developed digit
        mov   rdx, [rdgs0]              ; Get rdigs
        sub   rdx, r9                   ; Find number of zeroes
        jz    flbs70                    ; Go process exponent if none

flbs69: mov   byte[rdi], 0              ; Pad with zeroes
        add   rdi, 1                    ; to rdigs limit
        sub   rdx, 1
        jnz   flbs69

; Process exponent.

flbs70: mov   rsi, [r11]                ; Get bsn length so far
        lea   rsi, [r11+rsi]            ; Load address of exponent length
        mov   rax, [r15+8]              ; Get exponent from rstack frame
        bt    rax, 63                   ; Test sign bit
        jnc   flbs71
        bts   rbp, 0                    ; Set sign flag
        neg   rax                       ; Negate exponent

flbs71: xor   rdx, rdx                  ; Clear high order division register
        xor   rcx, rcx                  ; Clear index register

flbs72: div   r8                        ; Divide by base
        mov   [rsi+rcx+8], dl           ; Install digit in bsn
        test  rax, rax                  ; Test for zero
        jz    flbs73                    ; Finished
        xor   rdx, rdx                  ; Clear remainder
        add   rcx, 1                    ; Increment index/digit count
        jmp   flbs72                    ; Loop

flbs73: add   rcx, 1                    ; Length is 1 more than index
        mov   rbx, rcx                  ; Copy string length
        btr   rbp, 0                    ; Test/clear sign flag
        jnc   flbs74                    ; Jump if not negative
        neg   rbx                       ; Else negate string length

flbs74: mov   [rsi], rbx                ; Install string length
        add   [r11], rcx                ; Add length to bsn size
        add   qword[r11], 8             ; Add exponent length cell size
        mov   rbx, [r11]                ; Get bsn size
        and   rbx, 7                    ; Determine pad bytes
        jz    flbs77                    ; Branch if none needed
        neg   rbx
        add   rbx, 8
        add   [r11], rbx                ; Add pad bytes to bsn size
        lea   rsi, [rsi+rcx+8]          ; Set pointer past exponent string

flbs75: mov   byte[rsi], -1             ; Pad bsn to 64-bit boundary
        add   rsi, 1
        sub   rbx, 1
        jnz   flbs75
        jmp   flbs77

flbs76: mov   r14, [r15+16]             ; Restore virtual stack pointer
        mov   r12, [r15+24]             ; Restore r12
        add   r15, 32                   ; Pop return stack

        throwm 55                       ; Throw underflow on output

flbs77: mov   r14, [r15+16]             ; Restore virtual stack pointer
        sub   r14, 8                    ; Push bsn addr
        mov   [r14], r11
        mov   r12, [r15+24]             ; Restore r12
        add   r15, 32                   ; Pop return stack
        nextm
datam

; bsn>ascii - ( addr1 --- addr2 )
; Convert a byte-string number at addr1 to a counted ascii string in the hld
; buffer and return the buffer address (addr2).

head    "bsn>ascii",nbco,hidden
bsasc:  dq  bsas0
textm
bsas0:  mov   rsi, [r14]                ; Get addr of BSN
        lea   rdi, [hld0]               ; Get hld addr
        lea   r8, [nof0]                ; Get base addr of number output filter
        mov   r9, [rsi+16]              ; Get number type
        mov   rbx, [rsi+32]             ; Get 1st string length
        add   rsi, 32                   ; Offset to 1st string
        xor   rcx, rcx                  ; Clear for output string length
        test  rbx, rbx                  ; See if 1st string length is negative
        jns   bsas1                     ; Branch if positive
        neg   rbx                       ; Else negate length
        mov   byte[rdi+8], 45           ; Prepend minus sign
        add   rcx, 1                    ; Increment output string length

bsas1:  mov   r11, rbx                  ; Save copy of 1st string length

        cmp   r9, 5                     ; Test for floating-point number
        jz    bsas4                     ; Branch if floating-point

        cmp   r9, 3                     ; Test for real number
        jnz   bsas2                     ; Branch if not real

; The following test applies only if the number is real. Test whether an extra
; digit has accrued to the integer part due to rounding. If so, install
; the first digit in the buffer, increment the output string length,
; and then continue.

        cmp   byte[rsi+rbx+8], 0        ; Test rounding overflow byte
        jz    bsas2                     ; Branch if zero

        movzx rax, byte[rsi+rbx+8]      ; Get first digit
        mov   al, [r8+rax]              ; Get ascii value
        mov   [rdi+rcx+8], al           ; Install in output string
        add   rcx, 1                    ; Increment index/output string length

bsas2:  movzx rax, byte[rsi+rbx+7]      ; Get first/next digit
        mov   al, [r8+rax]              ; Get ascii value
        mov   [rdi+rcx+8], al           ; Install in output string
        add   rcx, 1                    ; Increment index/output string length
        sub   rbx, 1                    ; Decrement digit count
        jnz   bsas2                     ; Loop until zero

        cmp   r9, 1                     ; See if single precision
        jz    bsas19                    ; Done if single precision

        cmp   r9, 4                     ; See if rational number
        jz    bsas3                     ; Branch if rational

        mov   byte[rdi+rcx+8], 46       ; Append radix point
        add   rcx, 1                    ; Increment output string length

        cmp   r9, 3                     ; See if real number
        jz    bsas15                    ; Continue if real

        jmp   bsas19                    ; Done if multi-precision

bsas3:  mov   byte[rdi+rcx+8], 47       ; Append slash
        add   rcx, 1                    ; Increment output string length
        lea   rsi, [rsi+r11+8]          ; Load address of 2nd string length
        mov   rbx, [rsi]                ; Get 2nd string length
        jmp   bsas18

; Process floating-point bsn. If the number of integer digits is not 1,
; there is no need to test for zero. If the single integer digit is zero, we
; must make sure that the rounding overflow byte is also zero before deciding
; that the integer part is zero. If the integer part is zero, the number
; of fraction digits will already be rdigs+1. If the integer part is not zero,
; the integer and fractional parts will combine to make rdigs+1 digits.

bsas4:  cmp   r11, 1                    ; See if integer length is 1
        jnz   bsas10                    ; Branch if not
        movzx rax, byte[rsi+8]          ; Get integer digit
        cmp   rax, 0                    ; See if integer is zero
        jnz   bsas5                     ; Branch if not
        movzx rax, byte[rsi+9]          ; Get rounding overflow byte
        cmp   rax, 0                    ; Test if zero
        jz    bsas6                     ; Branch if so

        mov   al, [r8+rax]              ; Translate to ascii
        mov   [rdi+rcx+8], al           ; Install as integer digit
        add   rcx, 1                    ; Increment hld index
        mov   byte[rdi+rcx+8], 46       ; Append radix point
        add   rcx, 1                    ; Increment hld index
        movzx rax, byte[rsi+8]          ; Get integer digit
        mov   al, [r8+rax]              ; Translate to ascii
        mov   [rdi+rcx+8], al           ; Install as integer digit
        add   rcx, 1                    ; Increment hld index
        add   rsi, 10                   ; Advance to fraction string length
        mov   rdx, [rsi]                ; Get fraction length
        xor   rbx, rbx                  ; Zero index register
        jmp   bsas9                     ; Go process fraction

bsas5:  mov   al, [r8+rax]              ; Translate to ascii
        mov   [rdi+rcx+8], al           ; Install as integer digit
        add   rcx, 1                    ; Increment hld index
        mov   byte[rdi+rcx+8], 46       ; Append radix point
        add   rcx, 1                    ; Increment hld index
        add   rsi, 10                   ; Advance to fraction string length
        mov   rdx, [rsi]                ; Get fraction length
        xor   rbx, rbx                  ; Zero index register
        jmp   bsas9                     ; Go process fraction

; If the integer is zero, the fraction can't be a single digit unless it is
; also zero.

bsas6:  add   rsi, 10                   ; Advance to fraction string length
        mov   r11, [rsi]                ; Get fraction string length
        mov   rdx, r11                  ; Copy length
        cmp   r11, 1                    ; See if fraction length is 1
        jnz   bsas8                     ; Branch if not

; Set up to output floating-point zero

        mov   byte[rdi+rcx+8], 48       ; Install zero
        add   rcx, 1
        mov   byte[rdi+rcx+8], 46       ; Install radix point
        add   rcx, 1
        mov   rbx, [rdgs0]              ; Get rdigs
bsas7:  mov   byte[rdi+rcx+8], 48       ; Install rdigs zeroes
        add   rcx, 1
        sub   rbx, 1
        jnz   bsas7
        mov   byte[rdi+rcx+8], 94       ; Install caret
        add   rcx, 1
        mov   byte[rdi+rcx+8], 48       ; Install zero exponent
        add   rcx, 1
        jmp   bsas19

; Process fraction digits

bsas8:  xor   rbx, rbx                  ; Zero index register
        movzx rax, byte[rsi+rbx+8]      ; Get first fraction digit
        mov   al, [r8+rax]              ; Translate to ascii
        mov   [rdi+rcx+8], al           ; Install as integer digit
        add   rcx, 1                    ; Increment hld index
        add   rbx, 1                    ; Increment bsn index
        sub   rdx, 1                    ; Decrement digit count
        mov   byte[rdi+rcx+8], 46       ; Append radix point
        add   rcx, 1                    ; Increment hld index

; Continue processing fraction digits.

bsas9:  movzx rax, byte[rsi+rbx+8]      ; Get next digit
        mov   al, [r8+rax]              ; Get ascii value
        mov   [rdi+rcx+8], al           ; Install in output string
        add   rcx, 1                    ; Increment hld index/count
        add   rbx, 1                    ; Increment bsn index
        sub   rdx, 1                    ; Decrement digit count
        jnz   bsas9                     ; Loop until zero

        lea   rsi, [rsi+rbx+8]          ; Load address of exponent string
        jmp   bsas17                    ; Go process exponent

; If the integer part of a floating-point number is not zero, there are two
; cases. One, the length of the integer part is rdigs+1 or more. In this
; case, the integer is processed to the rdigs+1 limit, followed by the exponent.
; Two, the integer part is less than rdigs+1. The integer is developed,
; followed by the fraction, and then the exponent.
; First, test to see if the rounding overflow byte is zero, and if not,
; output the overflow digit separately.

bsas10: cmp   byte[rsi+rbx+8], 0        ; Test rob
        jz    bsas11                    ; Branch if zero

        movzx rax, byte[rsi+rbx+8]      ; Get first integer digit
        mov   al, [r8+rax]              ; Translate to ascii
        mov   [rdi+rcx+8], al           ; Install digit
        add   rcx, 1                    ; Increment hld index
        jmp   bsas12

bsas11: movzx rax, byte[rsi+rbx+7]      ; Get first integer digit
        mov   al, [r8+rax]              ; Translate to ascii
        mov   [rdi+rcx+8], al           ; Install digit
        sub   rbx, 1                    ; Decrement integer length
        add   rcx, 1                    ; Increment hld index

bsas12: mov   byte[rdi+rcx+8], 46       ; Append radix point
        add   rcx, 1                    ; Increment hld index

; Compare integer length with rdigs. If integer length is greater or equal,
; use rdigs for digit count.

        mov   rdx, [rdgs0]              ; Get rdigs
        cmp   r11, rdx                  ; Compare with integer length
        jc    bsas14                    ; Branch if rdigs is greater

bsas13: movzx rax, byte[rsi+rbx+7]      ; Get first/next digit
        mov   al, [r8+rax]              ; Get ascii value
        mov   [rdi+rcx+8], al           ; Install in output string
        add   rcx, 1                    ; Increment output index
        sub   rbx, 1                    ; Decrement bsn index
        sub   rdx, 1                    ; Decrement digit count
        jnz   bsas13                    ; Loop until zero

; Since all of our output digits are derived from the integer part,
; the fraction is zero. Load address of exponent - rsi + r11 + 1 for rob
; + 8 for integer length cell + 8 for fraction length cell + 1 for zero
; fraction digit = rsi + r11 + 18.

        lea   rsi, [rsi+r11+18]         ; Load address of 3rd string length
        jmp   bsas17

bsas14: movzx rax, byte[rsi+rbx+7]      ; next digit
        mov   al, [r8+rax]              ; Get ascii value
        mov   [rdi+rcx+8], al           ; Install in output string
        add   rcx, 1                    ; Increment output index
        sub   rbx, 1                    ; Decrement digit count
        jnz   bsas14                    ; Loop until zero

bsas15: lea   rsi, [rsi+r11+9]          ; Load address of 2nd string length
        mov   rdx, [rsi]                ; Get 2nd string length
        xor   rbx, rbx                  ; Clear bsn index register

bsas16: movzx rax, byte[rsi+rbx+8]      ; Get first/next digit
        mov   al, [r8+rax]              ; Get ascii value
        mov   [rdi+rcx+8], al           ; Install in output string
        add   rcx, 1                    ; Increment output string length
        add   rbx, 1                    ; Advance bsn pointer
        sub   rdx, 1                    ; Decrement digit count
        jnz   bsas16                    ; Loop until zero

        cmp   r9, 3                     ; See if real number
        jz    bsas19

        lea   rsi, [rsi+rbx+8]          ; Load address 3rd string length

; Process floating-point exponent

bsas17: mov   byte[rdi+rcx+8], 94       ; Append caret
        add   rcx, 1                    ; Increment output string length
        mov   rbx, [rsi]                ; Get 3rd string length
        test  rbx, rbx                  ; Test sign of exponent
        jns   bsas18                    ; Branch if positive

        neg   rbx                       ; Else negate length
        mov   byte[rdi+rcx+8], 45       ; Prepend minus sign
        add   rcx, 1                    ; Increment output string index/length

bsas18: movzx rax, byte[rsi+rbx+7]      ; Get first/next digit
        mov   al, [r8+rax]              ; Get ascii value
        mov   [rdi+rcx+8], al           ; Install in output string
        add   rcx, 1                    ; Increment output index
        sub   rbx, 1                    ; Decrement digit count
        jnz   bsas18                    ; Loop until zero

bsas19: mov   [rdi], rcx                ; Install output string length
        mov   [r14], rdi                ; Return hld address
        nextm
datam

; char <c> - ( --- char ) - Parse a character in the input stream and put
;                    its ascii value on the stack.

; : char   bl source (char) ;

head    "char", hlfo
char:   dq  docl0
        dq  blsp,srcat,pchar,semis

; (char) - ( char addr n --- char ) - Given a delimiter character,
; a buffer address, and a buffer size, returns the ascii value
; of the first non-delimiter character and advances >IN to point
; past the next delimiter.
; Since it doesn't rely on `(dcword)`, the mechanism for detecting an error
; is different. If the input stream is exhausted before a non-delimiter is
; found, it returns -1. If the input stream is exhausted before reaching
; the next delimiter, >IN is set to the buffer size plus 1.

head    "(char)", inpo, hidden
pchar:  dq  pchr0
textm
pchr0:  mov   rdx, [r14]                ; Get number of characters in buffer
        mov   rsi, [r14+8]              ; Get buffer address
        mov   rax, [r14+16]             ; Get delimiter character
        mov   rbx, [scin0]              ; Get >IN offset
        sub   rdx, rbx                  ; Subtract >IN offset from buffer size
        ja    pchr1                     ; If not at end of buffer, continue

        mov   r8, -1                    ; Else error
        jmp   pchr4

pchr1:  cmp   [rsi+rbx], al             ; Scan for non-delimiter
        jnz   pchr2                     ; Non-delimiter found
        add   rbx, 1                    ; Increment >IN
        sub   rdx, 1                    ; Decrement buffer size
        jnz   pchr1                     ; Loop for buffer size

; If loop falls through, buffer is exhausted before non-delimiter encountered.

        mov   r8, -1                    ; Return error flag
        jmp   pchr4                     ; No non-delimiter found

pchr2:  movzx r8, byte[rsi+rbx]         ; Save ascii value of first non-delimiter
        add   rbx, 1                    ; Increment >IN
pchr3:  cmp   [rsi+rbx], al             ; Scan for delimiter
        jz    pchr5                     ; Delimiter found
        add   rbx, 1                    ; Increment >IN
        sub   rdx, 1                    ; Decrement buffer size
        jnz   pchr3                     ; Loop for buffer size

; If loop falls through, buffer is exhausted before delimiter found,
; but in this case there is no error.

        jmp   pchr6

pchr4:  throwm 46

pchr5:  add   rbx, 1                    ; Advance >IN past delimiter
pchr6:  mov   [scin0], rbx              ; Save new >IN pointer
        add   r14, 16                   ; Pop top two stack entries
        mov   [r14], r8                 ; Return ascii value or error
        nextm
datam

; dctword - ( --- addr ) Parse the next delimited word in the input stream to the
; top of the dictionary in the form of a potential dictionary entry and return its
; name field address - the address of the word as a counted string. If the input
; stream is exhausted, the address returned is the current dictionary pointer,
; which contains 0.
; Uses a table of characters instead of a single delimiter. While the table could
; include any ASCII characters, for the current purposes of Forthx64 it contains
; only the space, newline, and tab characters. This makes it unnecessary to provide
; a space at the end of a line in order for lines not to be run together. It also
; prevents tabs from interfering with interpretation, although it is recommended
; that text files use only soft tabs (emulated by spaces), available in most text
; editor programs.

; : dctword   dlmtbl @ source (dctword) ;

head    "dctword", hlfo
dctwrd: dq  docl0
        dq  dlmtbl,qat,srcat,dcwrd,semis

; (dctword) - ( dlmtbl addr1 n --- addr2 ) - Given the address of a table of
; characters to skip (dlmtbl), the address of a buffer (addr1), and the number of
; characters the buffer contains, (dctword) begins at the >IN offset and parses the
; next word between delimiters, or between a delimiter and the end of the input,
; to the top of the dictionary, returns its NFA on the stack, and updates >IN.
; If the buffer is empty, the address returned is the current dictionary pointer
; which contains zero. Otherwise, the shell of a dictionary entry is created in
; which nothing but the name field is complete and the address of this name field
; is returned on the stack and saved in the system variable, latest. The new CFA
; is left in the first link field so that compilation routines won't have to
; recalculate the number of padding bytes to continue with the new word definition.

; Register usage

;    r9  - temporary for new NFA
;    r8  - dlmtbl base address
;    rdi - dictionary pointer
;    rsi - buffer base address
;    rdx - buffer character count
;    rcx - parsed-word character count
;    rbx - >IN offset
;    rax - current character

head    "(dctword)", inpo, hidden
dcwrd:  dq  dcwd0
textm
dcwd0:  mov   rdx, [r14]                ; Get buffer character count
        mov   rsi, [r14+8]              ; Get buffer address
        mov   r8, [r14+16]              ; Get base addr of dlmtbl
        add   r14, 16                   ; Pop two stack items
        mov   rdi, [dspo0]              ; Get dictionary pointer
        lea   r9, [rdi+32]              ; Load new NFA
        mov   [r14], r9                 ; Put NFA on stack
        mov   rbx, [scin0]              ; Get >IN offset
        sub   rdx, rbx                  ; Subtract >IN offset from chr count
        jna   dcwd7                     ; Buffer exhausted, exit

; Scan for non-delimiter.

; Note that not clearing rax results in a subtle bug!
; The register is used as an index into the dlmtbl table, but the index
; is installed as a byte, so there may be garbage in the upper part
; of the register unless it is cleared. This caused a segmentation error
; in the following sequence of instructions:
; 3/23 ra>re cr .re

        xor   rax, rax                  ; Clear for indexing
dcwd1:  mov   al, [rsi+rbx]             ; Get first/next byte from buffer
        cmp   [r8+rax], al              ; Compare with dlmtbl entry
        jnz   dcwd2                     ; Non-delimiter found
        add   rbx, 1                    ; Increment >IN
        sub   rdx, 1                    ; Decrement buffer chr count
        jnz   dcwd1                     ; Loop for count

; If loop falls through, buffer is exhausted before non-delimiter is
; encountered.

        jmp   dcwd7                     ; No non-delimiter found

; Character destination is 40 bytes past base address to make room
; for header.

dcwd2: mov   [ltst0], r9                ; Put NFA in latest
        xor   rcx, rcx                  ; Zero character count
dcwd3:  add   rbx, 1                    ; Increment >IN
        mov   [rdi+rcx+40], al          ; Move character to destination
        add   rcx, 1                    ; Increment word chr count
        sub   rdx, 1                    ; Decrement buffer chr count
        jz    dcwd5

        mov   al, [rsi+rbx]             ; Get next buffer character
        cmp   [r8+rax], al              ; Compare with dlmtbl entry
        jz    dcwd4                     ; Leave loop if delimiter found

        jmp   dcwd3                     ; Loop

dcwd4:  add   rbx, 1                    ; Advance >IN past delimiter
dcwd5:  mov   [scin0], rbx              ; Save new >IN pointer
        mov   [rdi+32], rcx             ; Install length quad
        mov   rdx, rcx                  ; Copy character count
        and   rdx, 7                    ; See how many blanks to add
        jz    dcwd8                     ; No padding needed
        neg   rdx
        add   rdx, 8

dcwd6:  mov   byte[rdi+rcx+40], 32      ; Pad word to 64-bit boundary
        add   rcx, 1                    ; Increment count/index
        sub   rdx, 1                    ; Decrement counter
        jnz   dcwd6                     ; Loop for pad-byte count
        jmp   dcwd8

dcwd7:  mov   qword[rdi+32], 0          ; Install 0 in NF
        jmp   dcwd9

dcwd8:  lea   rsi, [rdi+rcx+40]         ; Load address of new code field
        mov   [rdi], rsi                ; Put CFA in 1st link field

dcwd9:  nextm
datam

; csword  - ( char --- addr ) "counted-string word"
; This is a special version of word used for compiling strings to the
; dictionary. It does not create the header shell; it simply places a
; counted string at the current dsp location, pads it with blanks to the
; 8-byte boundary and advances the dsp to point past the compiled string.
; If there are no words left in the input buffer, or if a null is
; encountered as the first non-delimiter throws "missing delimiter" error.
; If no non-delimiter is found, throws "no non-delimiter found".
; To prevent running together of the delimiter and the next word in the
; input buffer, it must ensure that either the input is exhausted or the
; next character after the delimiter is not a valid ASCII character.
; Otherwise it throws an error.

; : csword   source (csword) ;

head    "csword", hlfo
csword: dq  docl0
        dq  srcat,cswrd,semis

; (csword) - ( char addr n --- addr )

; Register usage

;    r8  - delimiter character
;    rdi - dictionary pointer
;    rsi - buffer address
;    rdx - buffer character count
;    rcx - parsed-word character count
;    rbx - >IN offset

head    "(csword)", inpo, hidden
cswrd:  dq  cswd0
textm
cswd0:  mov   rdx, [r14]                ; Get number of characters in buffer
        mov   rsi, [r14+8]              ; Get buffer address
        mov   r8, [r14+16]              ; Get delimiter character
        add   r14, 16                   ; Pop two stack items
        mov   rdi, [dspo0]              ; Get dictionary pointer
        mov   [r14], rdi                ; Put destination addr on stack
        mov   rbx, [scin0]              ; Get >IN offset
        sub   rdx, rbx                  ; Subtract >IN offset from buffer chr count
        jna   cswd6                     ; End of buffer, exit

; Scan for delimiter while moving characters to destination

        xor   rcx, rcx                  ; Zero character count
cswd1:  mov   al, [rsi+rbx]             ; Get first/next character
        cmp   al, r8b                   ; Compare with delimiter
        jz    cswd2                     ; Exit loop if equal

        add   rbx, 1                    ; Increment >IN
        mov   [rdi+rcx+8], al           ; Move byte to destination
        add   rcx, 1                    ; Increment char count
        sub   rdx, 1                    ; Decrement buffer chr count
        jnz   cswd1                     ; Loop for buffer count

; If loop falls through, no delimiter found, throw error

        throwm 71

cswd2:  add   rbx, 1                    ; Advance >IN past delimiter
        cmp   rdx, 1                    ; See if delimiter was last char
        jz    cswd3                     ; Continue if so

        mov   r9, [asct0]               ; Get ASCII table address
        xor   rax, rax                  ; Clear for index
        mov   al, [rsi+rbx]             ; Get char after delimiter
        cmp   byte[r9+rax], -1          ; See if valid ASCII
        jz    cswd3                     ; Continue if not

        throwm 72

cswd3:  cmp   rcx, 0                    ; See if delimiter is 1st char
        jnz   cswd4

        throwm 73

cswd4:  mov   [scin0], rbx              ; Save new >IN pointer
        mov   [rdi], rcx                ; Install length quad
        mov   rdx, rcx                  ; Copy character count
        and   rdx, 7                    ; See how many blanks to add
        jz    cswd7                     ; No padding needed
        neg   rdx
        add   rdx, 8

cswd5:  mov   byte[rdi+rcx+8], 32       ; Pad word to 64-bit boundary
        add   rcx, 1                    ; Increment count/index
        sub   rdx, 1                    ; Decrement counter
        jnz   cswd5                     ; Loop for pad-byte count
        jmp   cswd7

cswd6:  mov   qword[rdi], 0             ; Install 0 in NF
        jmp   cswd8

cswd7:  lea   rsi, [rdi+rcx+8]          ; Load new dictionary pointer address
        mov   [dspo0], rsi              ; Update dictionary pointer

cswd8:  nextm
datam

; azword  - ( chr --- ) "asciiz word"
; This is a special version of word used for compiling counted asciiz
; strings to the dictionary. It does not create the header shell; it simply
; places a displacement preceded string at the current dsp location, pads
; it with nulls to the 8-byte boundary, and advances the dsp to point past
; the compiled displacement string. If the string ends on an 8-byte boundary,
; a quad of nulls will be appended. If there are no words left in the input
; buffer, or if a null is encountered as the first non-delimiter, the address
; that (azword) leaves on the stack contains zero. To prevent running together
; of the delimiter and the next word in the input buffer, ensure that either
; the input is exhausted or the next character after the delimiter is not a
; valid ASCII character. Otherwise throw "delimiter runs together with
; following input".

; : azword   source (azword) ;

head    "azword", hlfo
azword: dq  docl0
        dq  srcat,azwrd,semis

; (azword)

head    "(azword)", inpo, hidden
azwrd:  dq  azwd0
textm
azwd0:  mov   rdx, [r14]                ; Get buffer chr count.
        mov   rsi, [r14+8]              ; Get buffer addr.
        mov   r8, [r14+16]              ; Get delimiter character
        add   r14, 16                   ; Pop two stack items
        mov   rdi, [dspo0]              ; Get dictionary pointer
        mov   [r14], rdi                ; Put destination addr on stack
        mov   rbx, [scin0]              ; Get >IN offset
        sub   rdx, rbx                  ; Subtract >IN offset from buffer chr count
        jna   azwd6                     ; Buffer exhausted

; Scan for delimiter while moving characters to dictionary

        xor   rcx, rcx                  ; Zero character count
azwd1:  mov   al, [rsi+rbx]             ; Get first/next character
        cmp   al, r8b                   ; Compare with delimiter
        jz    azwd2                     ; Exit loop if equal

        add   rbx, 1                    ; Increment >IN
        mov   [rdi+rcx+16], al          ; Move byte to destination
        add   rcx, 1                    ; Increment char count
        sub   rdx, 1                    ; Decrement buffer chr count
        jnz   azwd1                     ; Loop for buffer count

; If loop falls through, no delimiter found, throw "missing delimiter".

        throwm 71

azwd2:  add   rbx, 1                    ; Advance >IN past delimiter
        cmp   rdx, 1                    ; See if delimiter was last char
        jz    azwd3                     ; Continue if so

        mov   r9, [asct0]               ; Get ASCII table address
        xor   rax, rax                  ; Clear for index
        mov   al, [rsi+rbx]             ; Get char after delimiter
        cmp   byte[r9+rax], -1          ; See if valid ASCII
        jz    azwd3                     ; Continue if not

        throwm 72

azwd3:  cmp   rcx, 0                    ; See if delimiter was 1st char
        jnz   azwd4                     ; branch if not

        throwm 73

azwd4:  mov   [scin0], rbx              ; Save new >IN pointer
        mov   [rdi+8], rcx              ; Install length quad
        mov   rdx, rcx                  ; Copy character count
        and   rdx, 7                    ; See how many nulls to add
        jz    azwd7                     ; Quad of pad bytes needed

        neg   rdx
        add   rdx, 8

azwd5:  mov   byte[rdi+rcx+16], 0       ; Pad word to 64-bit boundary
        add   rcx, 1                    ; Increment index/count
        sub   rdx, 1                    ; Decrement counter
        jnz   azwd5                     ; Loop for pad-byte count
        jmp   azwd8

azwd6:  mov   qword[rdi], 0             ; Install 0 in NF
        jmp   azwd9                     ; Jump to exit

azwd7:  mov   qword[rdi+rcx+16], 0      ; Install zero quad
        add   rcx, 8                    ; Add 8 to displacement for zero quad

azwd8:  add   rcx, 16                   ; Add 16 for displacement and length cells
        mov   [rdi], rcx                ; Install displacement
        lea   rsi, [rdi+rcx]            ; Load new dsp address
        mov   [dspo0], rsi              ; Update dsp

azwd9:  nextm
datam

; cmtword - ( chr --- ) Ignore input up to supplied delimiter. Advance >IN past
; delimiter. If delimiter is not found before the end of input, throw "missing
; delimiter". To prevent running together of the delimiter and the next word
; in the input buffer, ensure that either the input is exhausted or the next
; character after the delimiter is not a valid ASCII character. Otherwise throw
; "delimiter runs together with following input".

head    "cmtword", hlfo
cmtwrd: dq  docl0
        dq  srcat,cmwrd,semis

; (cmtword)

head    "(cmtword)", inpo, hidden
cmwrd:  dq  cmwd0
textm
cmwd0:  mov   rdx, [r14]                ; Get source character count
        mov   rsi, [r14+8]              ; Get buffer address
        mov   r8, [r14+16]              ; Get delimiter character
        add   r14, 24                   ; Pop the stack
        mov   rbx, [scin0]              ; Get >IN offset
        mov   rbp, rbx                  ; Save copy
        sub   rdx, rbx                  ; Subtract from chr count
        jna   cmwd5                     ; If buffer exhausted, exit

; Scan for delimiter.

cmwd1:  cmp   [rsi+rbx], r8b            ; Compare 1st/next char
        jz    cmwd2                     ; Leave loop if found
        add   rbx, 1                    ; Increment >IN
        sub   rdx, 1                    ; Decrement count
        jnz   cmwd1                     ; Loop

; If loop falls through, throw "missing delimiter".

        throwm 71

cmwd2:  add   rbx, 1                    ; Advance past delimiter
        cmp   rdx, 1                    ; See if delimiter is last char
        jz    cmwd3                     ; Continue if so

        mov   r9, [asct0]               ; Get ASCII table address
        xor   rax, rax                  ; Clear for index
        mov   al, [rsi+rbx]             ; Get char after delimiter

; Note: valid ASCII could include space!

        cmp   byte[r9+rax], -1          ; See if valid ASCII
        jz    cmwd3                     ; Continue if not

        throwm 72

cmwd3:  mov   rcx, rbx
        sub   rcx, rbp
        cmp   rcx, 1                    ; See if delimiter was 1st char
        jnz   cmwd4                     ; Branch if not

        throwm 73

cmwd4:  mov   [scin0], rbx              ; Save new >IN pointer

cmwd5:  nextm
datam

; fileword -  ( char --- addr ) This special word scans the input buffer for
; a non-delimiter character, clears the auxiliary buffer, parses a file pathname
; to the buffer, then parses from the end of the pathname string to the first /,
; or to the beginning of the string if there is no /, and places this string in
; the name field of a new header shell in the dictionary. It then moves the
; parsed pathname to the pathname slot in the file structure shell as a counted
; asciiz string. It updates `>in` and `latest`.

; : fileword   source (fileword) ;

head    "fileword", hlfo
filwrd: dq  docl0
        dq  srcat,fiwrd,semis

; (fileword)

; Register usage
;
;    r8  - delimiter character
;    rdi - destination buffer address
;    rsi - input buffer
;    rdx - input buffer character count
;    rcx - parsed-word character count
;    rbx - >IN offset
;    rax - current character

head    "(fileword)", inpo, hidden
fiwrd:  dq  fiwd0
textm
fiwd0:  mov   rdx, [r14]                ; Get input buffer character count
        mov   rsi, [r14+8]              ; Get input buffer address
        mov   r8, [r14+16]              ; Get delimiter character
        mov   rdi, [r14+24]             ; Get destination buffer address
        add   r14, 24                   ; Pop three stack items
        mov   rbx, [scin0]              ; Get >IN offset
        sub   rdx, rbx                  ; Subtract >IN offset from buffer size
        jna   fiwd17                    ; End of buffer, exit

; Scan for non-delimiter.

        xor   rax, rax                  ; Clear for byte data
fiwd1:  mov   al, [rsi+rbx]             ; Get first/next byte from input
        cmp   r8b, al                   ; Compare with delimiter
        jnz   fiwd2                     ; Non-delimiter found

        add   rbx, 1                    ; Increment >IN
        sub   rdx, 1                    ; Decrement buffer character count
        jnz   fiwd1                     ; Loop for buffer character count

; If loop falls through, buffer is exhausted before non-delimiter encountered.

        jmp   fiwd17                    ; No non-delimiter found

; Clear destination buffer if it is not empty.

fiwd2:  mov   rax, [rdi-8]              ; Get number of characters in buffer
        cmp   rax, 0                    ; See if none
        jz    fiwd5                     ; Skip if none

        mov   rcx, rax                  ; Copy character count
        and   rax, 7                    ; See how much to add
        jz    fiwd3                     ; Branch if no bytes to add

        neg   rax
        add   rax, 8
        add   rcx, rax                  ; Add rounding bytes

fiwd3:  shr   rcx, 3                    ; Convert to quad count
        add   rcx, 1                    ; Add 1 for buffer pointer
fiwd4:  mov   qword[rdi+rcx*8-16], 0    ; Null buffer pointer and contents
        sub   rcx, 1                    ; Decrement counter
        jnz   fiwd4

fiwd5:  xor   rcx, rcx                  ; Zero character count
fiwd6:  mov   al, [rsi+rbx]             ; Get first/next buffer character
        cmp   r8b, al                   ; Compare with dlmtbl entry
        jz    fiwd7                     ; Leave loop if delimiter found

        add   rbx, 1                    ; Increment >IN
        mov   [rdi+rcx], al             ; Move character to destination
        add   rcx, 1                    ; Increment destination chr count
        sub   rdx, 1                    ; Decrement input chr count
        jnz   fiwd6                     ; Loop for buffer count

        jmp   fiwd8

fiwd7:  add   rbx, 1                    ; Advance >IN past delimiter
fiwd8:  mov   [scin0], rbx              ; Save new >IN pointer
        mov   [rdi-8], rcx              ; Install axb0 char count
        mov   rbx, rcx                  ; Save copy of count
        mov   rsi, rdi                  ; Auxiliary buffer is new source
        mov   r8, 47                    ; Ascii for /

; Scan from end of auxiliary buffer until / is found or character count
; is exhausted. If last character of string is the delimiter throw error.

        cmp   [rsi+rcx-1], r8b          ; If last char is delimiter,
        jz    fiwd18                    ; throw error

fiwd9:  cmp   [rsi+rcx-1], r8b          ; Compare char with delimiter
        jz    fiwd10                    ; Exit loop if equal
        sub   rcx, 1                    ; Decrement string length
        jnz   fiwd9                     ; Loop until zero

fiwd10: mov   rdx, rbx                  ; Copy for source index
        sub   rbx, rcx                  ; Find number of chars past delimiter
        mov   rcx, rbx                  ; Save copy for counter

        mov   rdi, [dspo0]              ; Dictionary is new destination
        lea   r9, [rdi+32]              ; Load new NFA
        mov   [r14], r9                 ; Put NFA on stack
        mov   [r9], rbx                 ; Put length in 1st cell
        mov   [ltst0], r9               ; Put temporary NFA in latest

; Move filename to dictionary.

fiwd11: mov   al, [rsi+rdx-1]           ; Move filename to dictionary
        mov   [rdi+rcx+39], al
        sub   rdx, 1                    ; Decrement source index
        sub   rcx, 1                    ; Decrement destination index
        jnz   fiwd11

; Pad filename to eight-byte boundary with blanks.

        mov   rcx, rbx                  ; Copy count
        and   rbx, 7                    ; See how many blanks to add
        jz    fiwd13                    ; No padding needed
        neg   rbx
        add   rbx, 8

fiwd12: mov   byte[rdi+rcx+40], 32      ; Pad word to 64-bit boundary
        add   rcx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement counter
        jnz   fiwd12                    ; Loop for pad-byte count

fiwd13: lea   r9, [rdi+rcx+40]          ; Load address of new code field
        mov   [rdi], r9                 ; Put CFA in 1st link field

; Move pathname to proper place in file structure.

        lea   r9, [r9+72]               ; Load address of pathname

        mov   rbx, [rsi-8]              ; Copy path length to structure
        mov   [r9], rbx
        mov   rdx, rbx                  ; Save copy of length
fiwd14: mov   rax, [rsi+rbx-1]          ; Move pathname to structure
        mov   [r9+rbx+7], rax
        sub   rbx, 1
        jnz   fiwd14

        mov   rbx, rdx                  ; Copy counter
        and   rdx, 7                    ; See how many nulls to add
        jz    fiwd16                    ; Quad of pad bytes needed
        neg   rdx
        add   rdx, 8

fiwd15: mov   byte[rdi+rbx], 0          ; Pad word to 64-bit boundary
        add   rbx, 1                    ; Increment index/count
        sub   rdx, 1                    ; Decrement counter
        jnz   fiwd15                    ; Loop for pad-byte count
        jmp   fiwd19

fiwd16: mov   qword[rdi+rbx], 0         ; Install zero quad
        jmp   fiwd19                    ; Branch to end

fiwd17: mov   rdi, [dspo0]              ; Get dsp
        lea   rdi, [rdi+32]
        mov   qword[rdi], 0             ; Install 0 in NF
        mov   [r14], rdi
        jmp   fiwd19

; Throw "filename cannot end with /".

fiwd18: throwm 62

fiwd19: nextm
datam

; bufword - ( addr1 n --- c-addr ) - Clear the destination buffer (addr1),
; skip leading delimiters, and move up to n characters from the source to the
; destination until the one of the delimiters in the table is encountered
; or the input is exhausted. Place the number of characters moved in the
; destination buffer's character count cell and return the buffer address.
; Update >IN. If there are no words left in the input buffer, or if a null
; is encountered as the first non-delimiter, exit with the destination buffer
; address pointing to zero.

; : bufword   dlmtbl @ source (bufword) ;

head    "bufword", hlfo
bufwrd: dq  docl0
        dq  dlmtbl,qat,srcat,buwrd,semis

; (bufword)

; Register usage

;    r8  - delimiter character
;    rdi - destination buffer address
;    rsi - source buffer address
;    rdx - source character count
;    rcx - parsed-word character count
;    rbx - >IN offset

head    "(bufword)", inpo, hidden
buwrd:  dq  buwd0
textm
buwd0:  mov   rdx, [r14]                ; Get source character count
        mov   rsi, [r14+8]              ; Get source buffer address
        mov   r8, [r14+16]              ; Get base address of dlmtbl
        add   r14, 24                   ; Pop 3 items
        mov   rdi, [r14]                ; Get destination buffer address

; Clear destination buffer.

        mov   rax, [rdi-8]              ; Get number of characters in buffer
        cmp   rax, 0                    ; See if none
        jz    buwd3                     ; Skip if none

        mov   rcx, rax                  ; Copy character count
        and   rax, 7                    ; See how much to add
        jz    buwd1                     ; Branch if no bytes to add

        neg   rax
        add   rax, 8
        add   rcx, rax                  ; Add rounding bytes

buwd1:  shr   rcx, 3                    ; Convert to quad count
        add   rcx, 1                    ; Add 1 for buffer pointer
buwd2:  mov   qword[rdi+rcx*8-16], 0    ; Null buffer pointer and contents
        sub   rcx, 1                    ; Decrement counter
        jnz   buwd2

buwd3:  mov   rbx, [scin0]              ; Get >IN offset
        sub   rdx, rbx                  ; Subtract >IN offset from buffer size
        jna   buwd9                     ; End of buffer, exit

        xor   rax, rax                  ; Clear for indexing
buwd4:  mov   al, [rsi+rbx]             ; Get first/next byte from buffer
        cmp   [r8+rax], al              ; Compare with dlmtbl entry
        jnz   buwd5                     ; Non-delimiter found
        add   rbx, 1                    ; Increment >IN
        sub   rdx, 1                    ; Decrement buffer chr count
        jnz   buwd4                     ; Loop for count

; If loop falls through, input buffer is exhausted before non-delimiter
; is encountered.

        jmp   buwd9                     ; No non-delimiter found

; Scan for delimiter while moving characters to destination.

buwd5:  xor   rcx, rcx                  ; Zero character count/index
buwd6:  add   rbx, 1                    ; Increment >IN
        mov   [rdi+rcx], al             ; Move byte to destination
        add   rcx, 1                    ; Increment char count
        sub   rdx, 1                    ; Decrement source chr count
        jz    buwd8                     ; Exit if count exhausted

        mov   al, [rsi+rbx]             ; Get next character
        cmp   [r8+rax], al              ; Compare with dlmtbl entry
        jz    buwd7                     ; Exit if delimiter found

        jmp   buwd6                     ; Loop

buwd7:  add   rbx, 1                    ; Advance >IN past delimiter
buwd8:  mov   [scin0], rbx              ; Save new >IN pointer
        mov   [rdi-8], rcx              ; Install destination length quad

buwd9:  nextm
datam

; dlmword - ( addr1 addr2 n char --- c-addr ) - Clear the destination buffer
; (addr1) and move n characters from the source (addr2) to the destination
; until the delimiter (char) is encountered. Place the number of characters
; moved in the destination buffer's character count cell and leave it's
; address on the stack. Update >IN.
; If there are no words left in the input buffer, or if a null is encountered
; as the first non-delimiter, exit with the destination buffer address pointing
; to zero. If the closing delimiter is not found, update destination character
; count and throw "missing delimiter".
; Used for parsing a string from the input buffer to a standard buffer
; in the form of a counted string.

; : dlmword    source (dlmword) ;

head    "dlmword", hlfo
dlmwrd: dq  docl0
        dq  srcat,dlwrd,semis

; (dlmword)

; Register usage

;    r8  - delimiter character
;    rdi - destination buffer address
;    rsi - source buffer address
;    rdx - source character count
;    rcx - parsed-word character count
;    rbx - >IN offset

head    "(dlmword)", inpo, hidden
dlwrd:  dq  dlwd0
textm
dlwd0:  mov   rdx, [r14]                ; Get source character count
        mov   rsi, [r14+8]              ; Get source buffer address
        mov   r8, [r14+16]              ; Get delimiter character
        add   r14, 24                   ; Pop 3 items
        mov   rdi, [r14]                ; Get destination buffer address

; Clear destination buffer.

        mov   rax, [rdi-8]              ; Get number of characters in buffer
        cmp   rax, 0                    ; See if none
        jz    dlwd3                     ; Skip if none

        mov   rcx, rax                  ; Copy character count
        and   rax, 7                    ; See how much to add
        jz    dlwd1                     ; Branch if no bytes to add

        neg   rax
        add   rax, 8
        add   rcx, rax                  ; Add rounding bytes

dlwd1:  shr   rcx, 3                    ; Convert to quad count
        add   rcx, 1                    ; Add 1 for buffer pointer
dlwd2:  mov   qword[rdi+rcx*8-16], 0    ; Null buffer pointer and contents
        sub   rcx, 1                    ; Decrement counter
        jnz   dlwd2

dlwd3:  mov   rbx, [scin0]              ; Get >IN offset
        sub   rdx, rbx                  ; Subtract >IN offset from buffer size
        jna   dlwd8                     ; End of buffer, exit

; Scan for delimiter while moving characters to destination.

        xor   rcx, rcx                  ; Zero character count/index
dlwd4:  mov   al, [rsi+rbx]             ; Get first/next character
        cmp   al, r8b                   ; Compare with delimiter
        jz    dlwd5                     ; Exit loop if found

        add   rbx, 1                    ; Increment >IN
        mov   [rdi+rcx], al             ; Move byte to destination
        add   rcx, 1                    ; Increment char count
        sub   rdx, 1                    ; Decrement source chr count
        jnz   dlwd4                     ; Loop for count

; If count exhausted before delimiter found, update destination character count,
; and throw 'missing delimiter'.

        mov   [rdi-8], rcx              ; Install destination length quad

        throwm 71

dlwd5:  cmp   rcx, 0                    ; See if delimiter is 1st char
        jnz   dlwd6                     ; Continue if not

        throwm 73

dlwd6:  mov   [rdi-8], rcx              ; Install destination length quad
        add   rbx, 1                    ; Advance >IN past delimiter
        cmp   rdx, 1                    ; See if delimiter is last char
        jz    dlwd7                     ; Continue if so

        mov   r9, [asct0]               ; Get ASCII table address
        xor   rax, rax                  ; Clear for index
        mov   al, [rsi+rbx]             ; Get char after delimiter
        cmp   byte[r9+rax], -1          ; See if valid ASCII
        jz    dlwd7                     ; Continue if not

        throwm 72

dlwd7:  mov   [scin0], rbx              ; Save new >IN pointer

dlwd8:  nextm
datam

; parse <text> - ( chr --- c-addr n - Given a delimiter character, parses
;          characters to the parse area until the delimiter is encountered
;          or the end of the buffer is reached. Returns the location of the
;          parsed string and its length.

; : parse   source (parse) ;

head    "parse", hlfo
pars:   dq  docl0
        dq  srcat,ppars,semis

; (parse) - ( chr addr n --- addr n ) - Given a delimiter character, a buffer
; address, and a buffer size, parses characters to the parse area (auxiliary
; buffer) until the delimiter is encountered or the end of the buffer is
; reached. Returns the location of the parsed string. If the first character
; encountered is the delimiter, or if the end of the buffer is already reached,
; the returned character count is zero. Otherwise update `>in`.
; To prevent running together of the delimiter and the next word in the
; input buffer, it must ensure that either the input is exhausted or the
; next character after the delimiter is not a valid ASCII character.
; Otherwise it throws an error.

; Register usage

;    r8  - delimiter
;    rdi - destination address
;    rsi - source buffer address
;    rdx - buffer character count
;    rcx - parsed-word character count
;    rbx - >IN offset
;    rax - parsed characters

head    "(parse)", txto, hidden
ppars:  dq  pprs0
textm
pprs0:  mov   rdx, [r14]                ; Get source character count
        mov   rsi, [r14+8]              ; Get source address
        mov   r8, [r14+16]              ; Get delimiter character
        add   r14, 8                    ; Pop one stack item
        lea   rdi, [axb0]               ; Get destination address
        mov   [r14+8], rdi              ; Put destination addr on stack

; Clear destination buffer.

        mov   rax, [rdi-8]              ; Get number of characters in buffer
        cmp   rax, 0                    ; See if none
        jz    pprs3                     ; Skip if none

        mov   rcx, rax                  ; Copy character count
        and   rax, 7                    ; See how much to add
        jz    pprs1                     ; Branch if no bytes to add

        neg   rax
        add   rax, 8
        add   rcx, rax                  ; Add rounding bytes

pprs1:  shr   rcx, 3                    ; Convert to quad count
        add   rcx, 1                    ; Add 1 for buffer pointer
pprs2:  mov   qword[rdi+rcx*8-16], 0    ; Null buffer pointer and contents
        sub   rcx, 1                    ; Decrement counter
        jnz   pprs2

pprs3:  mov   rbx, [scin0]              ; Get >IN offset
        sub   rdx, rbx                  ; Subtract >IN offset from buffer chr count
        jna   pprs8                     ; End of buffer, exit

        xor   rcx, rcx                  ; Zero parsed-word character count
pprs4:  mov   al, [rsi+rbx]             ; Get first/next character from source
        cmp   al, r8b                   ; Compare with delimiter
        jz    pprs5                     ; Delimiter found

        mov   [rdi+rcx], al             ; Move character to parse area
        add   rbx, 1                    ; Increment >IN
        add   rcx, 1                    ; Increment character count
        sub   rdx, 1                    ; Decrement buffer size
        jnz   pprs4                     ; Loop for buffer size

; If loop falls through, throw "missing delimiter".

        mov   [rdi-8], rcx              ; Update buffer character count

        throwm 71

pprs5:  cmp   rcx, 0                    ; See if delimiter is 1st char
        jnz   pprs6                     ; Continue if not

        throwm 73

pprs6:  mov   [rdi-8], rcx              ; Update buffer character count
        add   rbx, 1                    ; Advance >IN past delimiter
        cmp   rdx, 1                    ; See if delimiter is last char
        jz    pprs7                     ; Continue if so

        mov   r9, [asct0]               ; Get ASCII table address
        xor   rax, rax                  ; Clear for index
        mov   al, [rsi+rbx]             ; Get char after delimiter
        cmp   byte[r9+rax], -1          ; See if valid ASCII
        jz    pprs7                     ; Continue if not

        throwm 72

pprs7:  mov   [scin0], rbx              ; Save new >IN pointer

pprs8:  mov   [r14], rcx                ; Put character count on stack
        nextm
datam

; find - ( c-addr --- c-addr 0 | xt 1 | xt -1 ) Given the address of a sought
; word (latest), returns the CFA of a word if it is found in the dictionary,
; and a minus one if the word is not immediate, or one if it is immediate.
; Otherwise, it leaves the original address on the stack along with a zero flag.
; If the braid flag is set, uses the ascii-based hash table to find the correct
; link.

; : find   dctword (find) ;

head    "find", hlfo
find:   dq  docl0
        dq  dctwrd,pfind,semis

; (find)

; Register usage:

;    r12 - Offset reset register for hashing
;    r11 - Offset to NFA/Object type field
;    r10 - Vocabulary link
;    r9  - sought-word address
;    r8  - link addressing
;    rdi - dictionary word pointer
;    rsi - sought-word pointer
;    rdx - quad register
;    rcx - counter
;    rbx - hashing offset register
;    rax - word length

head    "(find)", inpo, hidden
pfind:  dq  pfnd0
textm
pfnd0:  sub   r15, 8                    ; Free up r12
        mov   [r15], r12
        lea   rbp, [vhtb0]              ; Load base address of hash table
        mov   rsi, [r14]                ; Get sought-word addr
        mov   rax, [rsi]                ; Get length
        add   rax, 8                    ; Add 8 for length quad
        mov   rdx, rax                  ; Copy length
        shr   rax, 3                    ; Convert to quad counter
        and   rdx, 7                    ; See if there are trailing bytes
        jz    pfnd1                     ; Branch if not
        add   rax, 1                    ; Add 1 for trailing bytes

pfnd1:  xor   r12, r12                  ; Zero byte register
        mov   r12b, [rsi+8]             ; Get first letter of name
        mov   r12b, [rbp+r12]           ; Get offset from table
        lea   r10, [cnxt0]              ; Get context address
        jmp   pfnd6                     ; Jump to vocabulary loop

pfnd2:  lea   r8, [r8+rbx*8+8]          ; Get addr of last link in strand
pfnd3:  mov   r8, [r8]                  ; Get first/next link
        cmp   r8, 0                     ; Check for zero link
        jz    pfnd6                     ; Word not found in this vocabulary
        lea   rdi, [r8+r11]             ; Offset to NFA
        mov   rsi, [r14]                ; Set/reset sought-word pointer
        mov   rcx, rax                  ; Set/reset counter
        xor   r9, r9                    ; Set/reset index
pfnd4:  mov   rdx, [rsi+r9*8]           ; Get sought word quad
        cmp   rdx, [rdi+r9*8]           ; Compare with dictionary entry
        jnz   pfnd3                     ; If no match, get next link
        add   r9, 1                     ; Increment index
        sub   rcx, 1                    ; Decrement counter
        jnz   pfnd4                     ; Loop

; If loop falls through, match found.

        bt    qword[rdi-8], 62          ; See if word is hidden
        jnc   pfnd5                     ; Branch if not
        bt    qword[flgs0], 9           ; Test system HIDE bit
        jc    pfnd7                     ; Word not found if set

pfnd5:  lea   rdi, [rdi+r9*8]           ; Load CFA of found word
        mov   [r14], rdi                ; Return CFA of found word
        mov   rdx, -1                   ; Return minus one flag
        bt    qword[r8+r11-8], 63       ; Test immediate flag
        jnc   pfnd8                     ; Return -1 if not
        neg   rdx                       ; Else return 1
        jmp   pfnd8

pfnd6:  mov   r10, [r10]                ; Get first/next vlink
        cmp   r10, 0                    ; Test for zero link
        jz    pfnd7                     ; Word not found if zero

        xor   rbx, rbx                  ; Zero offset register
        mov   r11, 24                   ; Init NFA offset for single strand
        mov   r8, r10                   ; Copy vlink
        cmp   qword[r10+16], -1         ; Test first braid strand cell
        jle   pfnd2                     ; Branch if not braided

        mov   rbx, r12                  ; Set/reset offset register
        mov   r11, 32                   ; Reinitialize NFA offset
        jmp   pfnd2                     ; Loop

pfnd7:  mov   rdx, 0                    ; Return zero flag
pfnd8:  sub   r14, 8                    ; Make room for flag
        mov   [r14], rdx                ; Put flag on stack
        mov   r12, [r15]                ; Restore r12
        add   r15, 8
        nextm
datam

; ?found

head    "?found"
qfound: dq  qfnd0
textm
qfnd0:  cmp   qword[r14], 0             ; Test stack result
        jnz   qfnd1                   ; OK if not zero

        throwm 1

qfnd1:  add   r14, 8                    ; Pop stack
        nextm
datam

; ( - Comment delimiter - ignore input until ) is encountered or input stream
; is exhausted. Excludes parentheses in comments.

; : (   41 cmtword ; immediate

head    "(", -hlfo
paren:  dq  docl0
        dq  lit,41,cmtwrd,semis

; { - Comment delimiter - ignore input until } is encountered or input stream
; is exhausted. Designed to allow parentheses in comments. Excludes curly brackets
; in comments.

; : {   125 cmtword ; immediate

head    "{", -hlfo
cbkt:   dq  docl0
        dq  lit,125,cmtwrd,semis

; \ - Comment delimiter - ignore input until the end of a line as delineated
;    by the newline character.

; : \   10 cmtword ; immediate

head    "\", -hlfo
bksl:   dq  docl0
        dq  lit,10,cmtwrd,semis

; .( - Output the following text up to the ) while compiling.

; : .(   axb0 41 dlmword 8- count strout ; immediate

head    ".(", -hlfo
dotpar: dq  docl0
        dq  axbn,lit,41,dlmwrd
        dq  eighm,count,strout,semis

; .{ - Output the following text up to the } while compiling.
; Designed to allow parentheses in compiler comments.
; Excludes curly brackets in comments.

; : .{   axb0 125 dlmword 8- count strout ; immediate

head    ".{", -hlfo
dotclb: dq  docl0
        dq  axbn,lit,125,dlmwrd
        dq  eighm,count,strout,semis

; vocabulary <name> - create a new vocabulary

head    "vocabulary", hlfo
vocab:  dq  docl0
        dq  dfine,lit,brvo,objcom,pcomm,dovc0
        dq  voclnk,qat,here,voclnk,stor,comma
        dq  zero,comma,zero,comma
        dq  mone,comma,here,lit,504
        dq  dupl,brot,erase,allot,oszcom,semis

; If forthx is at the top of the chain, set the also flag so that
; the newly named vocabulary does not replace it.
; This version of dovoc will not allow duplicate vocabularies
; in the chain. If an attempt is made to add the first vocabulary
; in the chain again, nothing happens. If the named vocabulary occurs
; later in the chain, the duplicate will be unlinked and then relinked
; to replace the first vocabulary in the chain if the also flag is clear,
; or added to the chain if the also flag is set.
; If the duplicate vocabulary is the Root vocabulary, it will be made
; the only one in the chain, and all others will be unlinked.
textm
dovc0:  mov   rsi, [cnxt0]              ; Get vlink from context
        mov   r8, rsi                   ; Make copy
        lea   rbp, [vlink1]             ; Load address of vlink1
        cmp   r8, rbp                   ; See if forthx is on top
        jnz   dovc1                     ; Branch if not
        bts   qword[flgs0], 7           ; Else set also flag

dovc1:  lea   rdi, [r12+16]             ; Load address of new vlink
        cmp   r8, rdi                   ; See if already first
        jz    dovc8                     ; Do nothing if so

        cmp   qword[r8], 0              ; See if context is Root
        jz    dovc5                     ; Branch if so

dovc2:  cmp   [r8], rdi                 ; See if next link is equal
        jz    dovc3
        cmp   qword[r8], 0              ; Test for zero link
        jz    dovc4                     ; Branch if zero
        mov   r8, [r8]                  ; Get next vlink
        jmp   dovc2                     ; Loop

dovc3:  mov   r9, r8                    ; Save address of current vlink
        mov   r8, [r8]                  ; Go to matching vocabulary
        cmp   qword[r8], 0              ; See if next link is zero
        jz    dovc6                     ; Branch if so

        mov   rbx, [r8]                 ; Get old vlink
        mov   [r9], rbx                 ; Install old vlink in previous vocab

dovc4:  mov   r8, rsi                   ; Copy vlink from context
        bt    qword[flgs0], 7           ; Test also flag
        jc    dovc5                     ; Branch if flag set

        mov   r8, [rsi]                 ; Get next link

dovc5:  mov   [rdi], r8                 ; Install link in new vocabulary
        mov   [cnxt0], rdi              ; Install new vocabulary in context
        jmp   dovc8

; Zero all links in chain and put Root base address in context.

dovc6:  mov   [cnxt0], rdi              ; Install Root wid in context

dovc7:  mov   rdi, [rsi]                ; Get next wid
        cmp   rdi, 0                    ; See if zero
        jz    dovc8                     ; Exit if so
        mov   qword[rsi], 0             ; Install zero link
        mov   rsi, rdi
        jmp   dovc7

dovc8:  btr   qword[flgs0], 7           ; Clear also flag
        nextm
datam

; nb-vocab - create a non-braidable vocabulary

head    "nb-vocabulary", hlfo
nbvoc:  dq  docl0
        dq  dfine,lit,nbvo,objcom,pcomm,dovc0
        dq  voclnk,qat,here,voclnk,stor,comma
        dq  zero,comma,zero,comma
        dq  mtwo,comma,oszcom,semis

; Root - Only vocabulary. Non-braidable vocabulary prototype.

head    "Root", nbvo
Root:   dq  dovc0
rtlnk:  dq  0
vlink0: dq  0                           ; Vocabulary stack link
        dq  rootlnk-24                  ; Single-thread
        dq  -2                          ; Flag for non-braidable vocabulary

; definitions - Set current to context

head    "definitions"
defs:   dq  defs0
textm
defs0:  mov   rdx, [cnxt0]              ; Get context
        mov   [crnt0], rdx              ; Put context in current
        nextm
datam

; only - Make Root the only vocabulary in the chain

head    "only", vcbo
only:   dq  only0
textm
only0:  mov   rsi, [cnxt0]              ; Get context

only1:  mov   rdi, rsi                  ; Make copy
        cmp   qword[rdi], 0             ; Test for zero link
        jz    only3                     ; Exit if zero
        mov   rsi, [rdi]                ; Get next link
        mov   qword[rdi], 0             ; Zero current link
        jmp   only1

only3:  mov   [cnxt0], rdi
        nextm
datam

; also - Set flag to add named vocabulary to chain. When not set, vocabulary
;       replaces the top entry. Flag is cleared by dovc0.

head    "also", vcbo
also:   dq  also0
textm
also0:  bts   qword[flgs0], 7           ; Set also flag
        nextm
datam

; previous - Drop the top vocabulary chain entry

head    "previous", vcbo
prevs:  dq  prev0
textm
prev0:  mov   rsi, [cnxt0]              ; Get vlink from context
        cmp   qword[rsi], 0             ; See if context is Root
        jz    prev1                     ; Exit if so

        mov   rdi, [rsi]                ; Get next vlink
        mov   [cnxt0], rdi              ; Install in context
        mov   qword[rsi], 0             ; Zero current link

prev1:  nextm
datam

; marker - Save a snapshot of the current dictionary and vocabulary
; configuration to restore when it is envoked.
; The layout of the saved information is as follows:

; | dsp | context | current | voc-link | file-link | buffer-link
; | voc1 base address | voc1 stack link | voc1 linear link | voc1 braid flag
; | voc1 hash table (if present) ...
; | voc2 base address | voc2 stack link | voc2 linear link | voc2 braid flag
; | voc2 hash table (if present) ...
; | 0 | Zero marks the end of the saved information.

; The braid flag cell will be the first entry in the hash table if it
; is present. The order of the vocabulary information will follow
; the vocabulary stack from top to bottom.

head    "marker", hlfo
mark:   dq  docl0
        dq  dspo,qat,savcur
        dq  dfine,lit,mrko,objcom,pcomm,domk0
        dq  mrkcom,oszcom,semis

; domk - Restore the saved vocabulary structure. If a saved vocabulary
; is braided and the current version of it is not braided, it will have
; to be rebraided using the saved linear link. If a saved vocabulary is not
; braided and the current version is braided, the hash table will have to be
; cleared and the braid links zeroed.
textm
domk0:  lea   rsi, [r11+8]              ; Get address of 1st cell
        mov   rdx, [rsi]                ; Get saved dsp
        mov   [dspo0], rdx              ; Restore dsp
        mov   rdx, [rsi+8]              ; Get saved context
        mov   [cnxt0], rdx              ; Restore context
        mov   rdx, [rsi+16]             ; Get saved current
        mov   [crnt0], rdx              ; Restore current
        mov   rdx, [rsi+24]             ; Get saved voc-link
        mov   [vlnk0], rdx              ; Restore voc-link
        mov   rdx, [rsi+32]             ; Get saved file-link
        mov   [flnk0], rdx              ; Restore saved file-link
        mov   rdx, [rsi+40]             ; Get saved buffer-link
        mov   [bulk0], rdx              ; Restore saved buffer-link

        add   rsi, 48                   ; Advance pointer past file-link cell
        mov   rdi, [rsi]                ; Get first vocabulary base address
        add   rsi, 8                    ; Advance pointer

domk1:  mov   rdx, [rsi]                ; Get saved vocabulary stack link
        mov   [rdi], rdx                ; Restore link
        add   rsi, 8                    ; Advance pointers
        add   rdi, 8
        mov   rdx, [rsi]                ; Get saved last word link
        mov   r8, rdx                   ; Save copy in case needed
        mov   [rdi], rdx                ; Restore link
        add   rsi, 8                    ; Advance pointers
        add   rdi, 8
        mov   rdx, [rsi]                ; Get saved braid flag
        mov   rcx, [rdi]                ; Get present braid flag
        mov   [rdi], rdx                ; Restore saved braid flag
        add   rsi, 8                    ; Advance pointers
        add   rdi, 8
        cmp   rdx, 0                    ; See if braided
        jns   domk3                     ; Branch if so

; If saved vocabulary is not braided, it will be necessary to determine
; if it has been subsequently braided and, if so, zero the hash table
; and the braid links.

        cmp   rcx, 0                    ; See if present braid flag is set
        js    domk8                     ; Branch if so

; Saved version of vocabulary is not braided, but current version is.
; Clear hash table and braid links.

; Zero hash table

        xor   rax, rax                  ; Clear index register
%rep    63
        mov   qword[rdi+rax*8], 0
        add   rax, 1
%endrep

; Zero braid links

domk2:  cmp   qword[r8], 0              ; Test for zero link
        jz    domk8                     ; Exit if zero
        mov   qword[r8-8], 0            ; Zero braid link
        mov   r8, [r8]                  ; Go to previous word
        jmp   domk2                     ; Loop

; If saved vocabulary is braided, see if it is now unbraided, and if so,
; rebraid it using the saved linear link.

domk3:  cmp   rcx, 0                    ; See if now unbraided
        jns   domk7                     ; Branch if not

        add   rsi, 63*8                 ; Advance marker pointer past hash table
        mov   qword[rdi-8], 0           ; Clear restored braid flag

        mov   r9, [sctc0]               ; Get scratch area base address
        lea   rbp, [vhtb0]              ; Load hash table base address

; Zero scratch area

        xor   rax, rax                  ; Clear index register
%rep    64
        mov   qword[r9+rax*8], 0
        add   rax, 1
%endrep

        lea   rdi, [rdi-16]             ; Load vocabulary base address
        xor   rax, rax                  ; Clear register for byte offset
        jmp   domk5

domk4:  mov   r8, [r8+8]                ; Get first/next linear link
        cmp   r8, 0                     ; Test for zero link
        jz    domk8                     ; Done if zero

domk5:  sub   r8, 8                     ; Offset to auxiliary link field
        mov   al, [r8+40]               ; Get first byte of name
        mov   al, [rbp+rax]             ; Get offset from table
        cmp   qword[rdi+rax*8], 0       ; See if voc hash entry is zero
        jnz   domk6                     ; Branch if not
        mov   [rdi+rax*8], r8           ; Else install in hash table
        mov   [r9+rax*8], r8            ; and in scratch area
        jmp   domk4

domk6:  mov   rbx, [r9+rax*8]           ; Get scratch area entry
        mov   [r9+rax*8], r8            ; Replace it with current entry
        mov   [rbx], r8                 ; Install new link
        jmp   domk4

domk7:

; Restore hash table

%rep    63
        mov   rdx, [rsi]
        mov   [rdi], rdx
        add   rsi, 8
        add   rdi, 8
%endrep

domk8:  mov   rdi, [rsi]                ; Get next vocabulary base address
        add   rsi, 8                    ; Advance pointer
        cmp   rdi, 0                    ; Finished if address is zero
        jnz   domk1                     ; Else loop
        nextm
datam

; base-system - ( --- ) Restore the dictionary and vocabulary structure
; to the startup configuration. This functions in the same way as a marker,
; but is slightly different in that executing it does not obliterate it.
; It's code field contains different code than a marker since it only has
; to restore the Root and forthx vocabularies and zero the forthx hash
; table and braid links if it has been braided.

head    "base-system"

bsesys: dq  bsys0
        dq  dsp0,vlink1,vlink1,vocln0,filk0,0
        dq  forthx+16,vlink0,lastlnk-24,-1
        dq  Root+16,0,rootlnk-24,-2
textm
bsys0:  lea   rsi, [r11+8]              ; Get address of 1st cell
        mov   rdx, [rsi]                ; Get saved dsp
        mov   [dspo0], rdx              ; Restore dsp
        mov   rdx, [rsi+8]              ; Get saved context
        mov   [cnxt0], rdx              ; Restore context
        mov   rdx, [rsi+16]             ; Get saved current
        mov   [crnt0], rdx              ; Restore current
        mov   rdx, [rsi+24]             ; Get saved voc-link
        mov   [vlnk0], rdx              ; Restore voc-link
        mov   rdx, [rsi+32]             ; Get saved file-link
        mov   [flnk0], rdx              ; Restore saved file-link
        mov   rdx, [rsi+40]             ; Get saved buffer-link
        mov   [bulk0], rdx              ; Restore saved buffer-link

        add   rsi, 48                   ; Advance pointer past voc-link cell
        mov   rdi, [rsi]                ; Get first vocabulary base address
        add   rsi, 8                    ; Advance pointer

        mov   rdx, [rsi]                ; Get saved vocabulary stack link
        mov   [rdi], rdx                ; Restore link
        add   rsi, 8                    ; Advance pointers
        add   rdi, 8
        mov   rdx, [rsi]                ; Get saved last word link
        mov   [rdi], rdx                ; Restore link
        mov   r8, rdx                   ; Save copy of last word link
        add   rsi, 8                    ; Advance pointers
        add   rdi, 8
        mov   rcx, [rdi]                ; Get current braid flag
        mov   rdx, [rsi]                ; Get saved braid flag
        mov   [rdi], rdx                ; Restore flag
        add   rsi, 8                    ; Advance pointers
        add   rdi, 8
        cmp   rcx, 0                    ; See if forthx was braided
        js    bsys2                     ; Branch if not braided

; Zero hash table if braided

%rep    63
        mov   qword[rdi], 0
        add   rdi, 8
%endrep

; Zero braid links

bsys1:  cmp   qword[r8], 0              ; Test for zero link
        jz    bsys2                     ; Exit if zero
        mov   qword[r8-8], 0            ; Zero braid link
        mov   r8, [r8]                  ; Go to previous word
        jmp   bsys1                     ; Loop

bsys2:  mov   rdi, [rsi]                ; Get next vocabulary base address
        add   rsi, 8                    ; Advance pointer
        mov   rdx, [rsi]                ; Get saved vocabulary stack link
        mov   [rdi], rdx                ; Restore link
        add   rsi, 8                    ; Advance pointers
        add   rdi, 8
        mov   rdx, [rsi]                ; Get saved last word link
        mov   [rdi], rdx                ; Restore link
        add   rsi, 8                    ; Advance pointers
        add   rdi, 8
        mov   rdx, [rsi]                ; Get saved braid flag
        mov   [rdi], rdx                ; Restore flag
        nextm
datam

; entries

head    "entries", oupo
entrs:  dq  ntrs0
textm
ntrs0:  mov   rdi, [crnt0]              ; Get link from current
        add   rdi, 8                    ; Offset to base address
        xor   rcx, rcx                  ; Clear count register
ntrs1:  mov   rdi, [rdi]                ; Get first/next link
        cmp   rdi, 0                    ; Check for zero
        jz    ntrs2                     ; Exit if zero
        add   rcx, 1                    ; Increment count
        jmp   ntrs1
ntrs2:  sub   r14, 8                    ; Push count to stack
        mov   [r14], rcx
        nextm
datam

; braid - ( wid --- ) Establish ascii-based braid in wordlist whose wid
;         is on the stack. Error if wordlist is empty, already braided,
;         or unbraidable.

head    "braid", vcbo
braid:  dq  brad0
textm
brad0:  mov   rsi, [r14]                ; Get wid (vlink addr)
        add   r14, 8                    ; Pop stack
        cmp   qword[rsi+16], -1         ; Test braid flag
        jz    brad2                     ; Branch if flag set

        cmp   qword[rsi+16], -2         ; See if not braidable
        jz    brad1                     ; Branch if so

        throwm 75                       ; Already braided

brad1:  throwm 76                       ; Not braidable

brad2:  cmp   qword[rsi+8], 0           ; See if empty
        jnz   brad3                     ; Braid if not

        throwm 77                       ; Empty

; Zero scratch area

brad3:  mov   rbx, [sctc0]              ; Get scratch area base address
        lea   rbp, [vhtb0]              ; Get hash table base address
        mov   rcx, 65                   ; Clear 65 quads
brad4:  mov   qword[rbx+rcx*8-8], 0
        sub   rdx, 0
        jnz   brad4

        mov   qword[rsi+16], 0          ; Zero braid flag
        lea   r8, [rsi+8]               ; Offset to voc base address
        mov   rsi, [rsi+8]              ; Get last link
        xor   rax, rax                  ; Clear register for byte offset

        jmp   brad6

brad5:  mov   rsi, [rsi+8]              ; Get next linear link
        cmp   rsi, 0                    ; Test for zero link
        jz    brad8                     ; Done if zero

brad6:  sub   rsi, 8                    ; Offset to auxiliary link field
        mov   al, [rsi+40]              ; Get first byte of name
        mov   al, [rbp+rax]             ; Get offset from table
        cmp   qword[r8+rax*8], 0        ; See if voc hash entry is zero
        jnz   brad7                     ; Branch if not
        mov   [r8+rax*8], rsi           ; Else install in hash table
        mov   [rbx+rax*8], rsi          ; and in scratch area
        jmp   brad5

brad7:  mov   rdi, [rbx+rax*8]          ; Get scratch area entry
        mov   [rbx+rax*8], rsi          ; Replace it with current entry
        mov   [rdi], rsi                ; Install new link
        jmp   brad5

brad8:  nextm
datam

; unbraid - ( vid --- ) Return wordlist to unbraided state. Error if wordlist
;          is not braided.

head    "unbraid", vcbo
ubrad:  dq  ubrd0
textm
ubrd0:  mov   rsi, [r14]                ; Get vid (base address)
        add   r14, 8                    ; Pop stack
        cmp   qword[rsi+16], 0          ; Test braid flag
        jns   ubrd1                     ; Branch if braided

        throwm 78                       ; Wordlist is not braided

ubrd1:  mov   qword[rsi+16], -1         ; Install not braided flag
        lea   rdi, [rsi+24]             ; Offset past flag

; Zero hash table

%rep    63
        mov   qword[rdi], 0
        add   rdi, 8
%endrep

        mov   rdi, [rsi+8]              ; Get 1st linear link

; Zero braid links

ubrd3:  cmp   qword[rdi], 0             ; Test for zero link
        jz    ubrd4                     ; Exit if zero
        mov   qword[rdi-8], 0           ; Zero braid link
        mov   rdi, [rdi]                ; Go to previous word
        jmp   ubrd3                     ; Loop

ubrd4:  nextm
datam

; ?braided - ( wid --- 0 | -1 ) Return a flag indicating whether the given
;         wordlist is braided.

head    "?braided", vcbo
qbrad:  dq  qbrd0
textm
qbrd0:  mov   rsi, [r14]                ; Get wid of vocabulary
        cmp   qword[rsi+16], -1         ; See if braid flag set
        setg  al                        ; Set if not
        neg   al
        movsx rdx, al
        mov   [r14], rdx
        nextm
datam

; ?braidable - ( wid --- 0 | -1 ) Return a flag indicating whether the given
;         wordlist is braidable.

head    "?braidable", vcbo
qbrbl:  dq  qbrb0
textm
qbrb0:  mov   rsi, [r14]                ; Get wid of vocabulary
        cmp   qword[rsi+16], -2         ; See if non-braidable flag set
        setnz al                        ; Set if not
        neg   al
        movsx rdx, al
        mov   [r14], rdx
        nextm
datam

; hashtest - ( wid chr --- braid link | 1 | -1 ) Given a wordlist id
;            and a character, returns the corresponding vocabulary
;            hash table entry, or -1 for an invalid character,
;            or 1 for unbraided wordlist.

head    "hashtest", vcbo, hidden
hasht:  dq  hsht0
textm
hsht0:  mov   rax, [r14]                ; Get character from stack
        mov   rdi, [r14+8]              ; Get wid
        add   r14, 8                    ; Pop 1 item from stack
        cmp   qword[rdi+16], -1         ; See if braided
        jg    hsht1                     ; Branch if greater

        mov   rbx, 1                    ; Return not-braided flag
        jmp   hsht4

hsht1:  cmp   ah, 0                     ; See if single byte
        jnz   hsht2                     ; Error if not
        lea   rbp, [vhtb0]              ; Load hash table base address
        mov   al, [rbp+rax]             ; Get offset from table
        cmp   al, -1                    ; See if entry is -1
        jnz   hsht3                     ; Branch if not

hsht2:  mov   rbx, -1                   ; Return -1
        jmp   hsht4

hsht3:  mov   rbx, [rdi+rax*8+8]        ; Return vocabulary link

hsht4:  mov   [r14], rbx                ; Return result
        nextm
datam

; list-braid

; : list-braid   0 cr context @ key dup >a hashtest dup
;                 0< if ." Invalid character" 2drop
;                 else dup
;                 1 = if ." Vocabulary not braided" 2drop
;                 else ?dup
;                 0= if ." No entries beginning with " a@ emit drop
;                 else begin dup 24 + 62 (btst) ?hide and not if
;                 dup 32 + count ?strout 2 ?spaces swap 1+ swap then
;                 @ ?dup 0= until 3 spaces . ." entries"
;                 then then then a> drop space ;

head    "list-braid", hlfo
lstbrd: dq  docl0
        dq  zero,cr,cont,qat,key,dupl,toa
        dq  hasht,dupl,zless,izbrn,lstbr1
        pdtqm "Invalid character"
        dq  ddrop,ebran,lstbr7
lstbr1: dq  dupl,one,equal,izbrn,lstbr2
        pdtqm "Vocabulary not braided"
        dq  ddrop,ebran,lstbr7
lstbr2: dq  dupnz,zequ,izbrn,lstbr3
        pdtqm "No entries beginning with "
        dq  rat,emit,drop,ebran,lstbr7
lstbr3: dq  dupl,twfp,lit,62,pbtst
        dq  qhid,andf,notf,izbrn,lstbr5
        dq  dupl,ttwp,count,qstout,two,qspacs
        dq  swp,onep,swp
lstbr5: dq  qat,dupnz,zequ,uzbrn,lstbr3
        dq  three,spaces,dtdec
        qdtqm " entries"
lstbr7: dq  froma,drop,space,semis

; ?hide - Return boolean value of HIDE - flags bit #9

head    "?hide"
qhid:   dq  qhid0
textm
qhid0:  bt    qword[flgs0], 9
        setc  al
        neg   al
        movsx rax, al
        sub   r14,8
        mov   [r14], rax
        nextm
datam

; hide-all - Set the HIDE bit in the system flags quad so that hidden words
; are not found by (find) or shown in the word listing.

head    "hide-all"
hidall: dq  hdal0
textm
hdal0:  bts   qword[flgs0], 9
        nextm
datam

; reveal-all - Clear the HIDE bit in the system flags quad so that hidden
; words are found by (find) and shown in the word listing.

head    "reveal-all"
revall: dq  rval0
textm
rval0:  btr   qword[flgs0], 9
        nextm
datam

; Find the first link field address of the first object in a vocabulary.

head    "first-object-link-field", objo, hidden
fobjl:  dq  fobl0
textm
fobl0:  mov   rsi, [cnxt0]              ; Get context VBA
        lea   rsi, [rsi+8]              ; Offset to single link thread
fobl1:  mov   rdi, [rsi]                ; Get first/next link
        cmp   rdi, 0                    ; Check for zero
        jz    fobl2                     ; Exit if zero
        mov   rsi, rdi                  ; Copy new link
        jmp   fobl1                     ; Loop

fobl2:  sub   rsi, 8                    ; Offset to 1st link field
        sub   r14, 8
        mov   [r14], rsi
        nextm
datam

; here - Put the current dsp on the stack.

head    "here", cmpo
here:   dq  here0
textm
here0:  mov   rdi, [dspo0]              ; Get dsp
        sub   r14, 8
        mov   [r14], rdi                ; Push to stack
        nextm
datam

; cells - ( n --- #bytes ) Return the size in bytes of n cells.

head    "cells", cmpo
cells:  dq  cels0
textm
cels0:  shl   qword[r14], 3
        nextm
datam

; cell+ - ( a-addr1 --- a-addr2 ) Add the size in bytes of a cell
;         to addr1 to give addr2.

head    "cell+", cmpo
cellp:  dq  celp0
textm
celp0:  add   qword[r14], 8
        nextm
datam

; [defined] <name> - ( --- flag ) True flag if word that follows in the input stream
; is in the dictionary

; : [defined]   find nip if -1 else 0 then ; immediate

head    "[defined]", -hlfo
bdefd:  dq  docl0
        dq  find,nip,zbran,xbde1
        dq  mone,bran,xbde2
xbde1:  dq  zero
xbde2:  dq  semis

; [undefined] <name> - ( --- flag ) False flag if word that follows in the input stream
; is in the dictionary.

; : [undefined]   find nip if 0 else -1 then ; immediate

head    "[undefined]", -hlfo
budef:  dq  docl0
        dq  find,nip,zbran,bude1
        dq  zero,bran,bude2
bude1:  dq  mone
bude2:  dq  semis

; [if] - ( flag --- )

; : [if]   0= if postpone [else] then ; immediate

head    "[if]", -hlfo
brif:   dq  docl0
        dq  nzbran,brif1
        dq  brels
brif1:  dq  semis

; [else] - ( --- )

; : [else]  1 begin dctword count dup
;             while 2dup s" [if]" compare 0=
;               if 2drop 1+
;               else 2dup s" [else]" compare 0=
;                 if 2drop 1- dup
;                   if 1+ then
;                 else s" [then]" compare 0=
;                   if 1- then then then
;               ?dup 0=
;               if exit then
;             repeat 3drop ; immediate

head    "[else]", -hlfo
brels:  dq  docl0
        dq  one
brels1: dq  dctwrd,count,dupl,zbran,brels6
        dq  ddup
        psqtm "[if]"
        dq  compa,nzbran,brels2
        dq  ddrop,onep,bran,brels5
brels2: dq  ddup
        psqtm "[else]"
        dq  compa,nzbran,brels4
        dq  ddrop,onem,dupl,zbran,brels3
        dq  onep
brels3: dq  bran, brels5
brels4: psqtm "[then]"
        dq  compa,nzbran,brels5
        dq  onem
brels5: dq  dupnz,nzbran,brels1
        dq  dexit
brels6: dq  tdrop
brels7: dq  semis

; [then] - ( --- )

; : [then]   ;

head    "[then]", cmpo
brthn:  dq  bthn0
textm
bthn0:
        nextm
datam

; ' - Look for a word in the dictionary
;    and, if found, return its CFA

; : '   find ?found ;

head    "'", hlfo
tick:   dq  docl0,find,qfound,semis

; >body - ( CFA --- PFA ) This is the Forth 2012 Standard version
; of the word below.

; : >body   8+ ;

head    ">body", hlfo
tbody:  dq  docl0
        dq  eighp,semis

; cfa>pfa - ( CFA --- PFA ) Given the Code Field Address of a dictionary entry,
; return its Parameter Field Address.

head    "cfa>pfa", stco
cftpf:  dq  cfpf0
textm
cfpf0:  add   qword[r14], 8
        nextm
datam

; cfa>nfa - ( CFA --- NFA ) Given the Code Field Address of a dictionary entry,
; return its Name Field Address. This procedure looks for a quad preceding the
; CFA that has a blank upper byte. This must be the length, since the other quads
; in a name have all bytes filled.

head    "cfa>nfa", stco
cftnf:  dq  cfnf0
textm
cfnf0:  mov   rdi, [r14]
cfnf1:  sub   rdi, 8
        cmp   byte[rdi+7], 0
        jnz   cfnf1
        mov   [r14], rdi
        nextm
datam

; cfa>ota - ( CFA --- OTA ) Given the Code Field Address of a dictionary entry,
; return its Object Type Address.

head    "cfa>ota", stco
cftota: dq  cfot0
textm
cfot0:  mov   rdi, [r14]
cfot1:  sub   rdi, 8
        cmp   byte[rdi+7], 0
        jnz   cfot1
        sub   rdi, 8
        mov   [r14], rdi
        nextm
datam

; cfa>osa - ( CFA --- OSA ) Given the Code Field Address of a dictionary entry,
; return its Object Size Address.

head    "cfa>osa", stco
cftosa: dq  cfos0
textm
cfos0:  mov   rdi, [r14]
cfos1:  sub   rdi, 8
        cmp   byte[rdi+7], 0
        jnz   cfos1
        sub   rdi, 16
        mov   [r14], rdi
        nextm
datam

; cfa>lfa - ( CFA - LFA ) Given the Code Field Address of a dictionary entry,
; return its Link Field Address. This is Link2 in the header.

head    "cfa>lfa", stco
cftlf:  dq  cflf0
textm
cflf0:  mov   rdi, [r14]
cflf1:  sub   rdi, 8
        cmp   byte[rdi+7], 0
        jnz   cflf1
        sub   rdi, 24
        mov   [r14], rdi
        nextm
datam

; lfa>nfa - ( LFA --- NFA ) Given the Link Field Address of a dictionary entry,
; return its Name Field Address.

head    "lfa>nfa", stco
lftnf:  dq  lfnf0
textm
lfnf0:  add   qword[r14], 24
        nextm
datam

; nfa>cfa - ( NFA --- CFA ) Given the Name Field Address of a dictionary entry,
; return its Code Field Address.

head    "nfa>cfa", stco
nftcf:  dq  nfcf0
textm
nfcf0:  mov   rdi, [r14]                ; Get name field address
        mov   rdx, [rdi]                ; Get character count
        mov   rcx, rdx                  ; Make copy
        and   rdx, 7                    ; See how much to add
        jz    nfcf1                     ; Branch if no bytes to add
        neg   rdx
        add   rdx, 8
        add   rcx, rdx
nfcf1:  add   rcx, 8                    ; Add for length cell
        add   [r14], rcx                ; Add rounded length + 8
        nextm
datam

; obtype@ - Given the OTA of a dictionary entry, return its object id.
; Note that a double word is zero-extended to 64 bits when moved
; into a register.

head    "obtype@", objo
obtat:  dq  otat0
textm
otat0:  mov   rdi, [r14]                ; Get OTA
        mov   edx, [rdi]                ; Get low order double word
        mov   [r14], rdx                ; Return object type
        nextm
datam

; findobj - ( obj# --- addr ) Chain through object type list until
;          passed object type number is found and return the object
;          name address. Throw error if number is out of range.

head    "findobj", objo
fndobj: dq  fdob0
textm
fdob0:  mov   rdx, [r14]                ; Get object number
        cmp   rdx, tnum                 ; Throw error if object #
        jnc   fdob2                     ; out of range.

        mov   rdi, [oblk0]              ; Get first object type link
fdob1:  cmp   qword[rdi], 0             ; Test for zero link
        jz    fdob3                     ; Last object type in list
        cmp   [rdi+24], rdx             ; Compare object type numbers
        jz    fdob3                     ; Branch on match
        mov   rdi, [rdi]                ; Get previous link
        jmp   fdob1                     ; Loop

fdob2: throwm 45


fdob3:  add   rdi, 32                   ; Offset to counted string
        mov   [r14], rdi                ; Put object type address on stack
        nextm
datam

; show-obtype - Return the object type name of the following dictionary word.
; ( show-obtype <name> --- <object type> )

; : show-obtype   space 60 emit ' cfa>ota obtype@ findobj count type 62 emit ;

head    "show-obtype", hlfo
shobtp: dq  docl0
        dq  space,lit,60,emit
        dq  tick,cftota,obtat,fndobj,count,strout
        dq  lit,62,emit,semis

; ?immediate - Return a true flag if the following word is immediate, else
; return a false flag.
; ( ?immediate <name> --- true | false )

; : ?immediate   ' >otype @ 63 btst slip ;

head    "?immediate", hlfo
qimm:   dq  docl0,tick,cftota,qat,lit,63,btstf,slip,semis

; ?hidden - Return a true flag if the following word is hidden, else
; return a false flag.
; ( ?hidden <name> --- true | false )

; : ?hidden   ' >otype @ 62 btst slip ;

head    "?hidden", hlfo
qhidn:  dq  docl0,tick,cftota,qat,lit,62,btstf,slip,semis

; hide - Set the hide bit the following definition so that if the system HIDE
; flag is set, it cannot be found by (find) and does not appear in the the
; word listing.
; ( hide <name> --- )

; : hide   ' >otype dup @ 62 bset swap ! ;

head    "hide", hlfo
hide:   dq  docl0,tick,cftota,dupl,qat,lit,62,bsetf,swp,stor,semis

; reveal - Clear the hide bit in the following definition so that it can be
; found by (find) and appears in the the word listing.
; ( reveal <name> --- )

; ; reveal   ?hide dup >a if reveal-all then
;            ' cfa>ota dup @ 62 bclr swap !
;            a> if hide-all then ;

head    "reveal", hlfo
reve:   dq  docl0,qhid,dupl,toa,izbrn,reve1
        dq  revall
reve1:  dq  tick,cftota,dupl,qat,lit,62,bclrf,swp,stor
        dq  froma,izbrn,reve2,hidall
reve2:  dq  semis

; Compiler definitions

; !csp

head    "!csp", cmpo
scsp:   dq  scsp0
textm
scsp0:  mov   [cspo0], r14              ; Save stack pointer in csp
        nextm
datam

; ?csp - See if initial compilation stack pointer is the same at
; the end of compilation. Throw "definition not finished" if not.
; Throw "compilation only, use in definition", if not compiling.

head    "?csp"
qcsp:   dq  qcsp0
textm
qcsp0:  bt    qword[flgs0], 1           ; Test STATE Flag
        jc    qscp1                     ; OK if flag set

        throwm 5

qscp1:  cmp   [cspo0], r14
        jz    qcsp2

        throwm 8                        ; Throw definition not finished

qcsp2:  nextm
datam

; cs-pick - ( s[n+1] s[n] s[n-1] ... s[0] n --- s[n+1] s[n] s[n-1] ... s[0] s[n] )
; Copy the nth single-quad to the top. Zero based.
; Same as `pick`.

head    "cs-pick", stko
cspck:  dq  cspk0
textm
cspk0:  bt    qword[flgs0], 1           ; Test STATE Flag
        jc    cspk1                     ; OK if flag set

        throwm 5                        ; Error if not compiling

cspk1:  mov   rdx, [r14]
        mov   rcx, [r14+rdx*8+8]
        mov   [r14], rcx
        nextm
datam

; cs-roll - ( x[u] x[u-1] ... x[0] u --- x[u-1] ... x[0] x[u] )
; Extract the nth stack item to the top and close the resulting gap.
; Do nothing if argument is zero or negative.
; Same as `roll`.

head    "cs-roll", stko
csrol:  dq csrl0
textm
csrl0:  bt    qword[flgs0], 1           ; Test STATE Flag
        jc    csrl1                     ; OK if flag set

        throwm 5                        ; Error if not compiling

csrl1:  mov   rdx, [r14]
        add   r14, 8
        cmp   rdx, 0
        jle   csrl3

        mov   rbx, [r14+rdx*8]
csrl2:  mov   rax, [r14+rdx*8-8]
        mov   [r14+rdx*8], rax
        sub   rdx, 1
        jnz   csrl2

        mov   [r14], rbx
csrl3:  nextm
datam

; state@ - Return boolean value of STATE - flags bit #0.

head    "state@", cmpo
stat:   dq  stat0
textm
stat0:  bt    qword[flgs0], 1
        setc  al
        neg   al
        movsx rdx, al
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; ?comp

head    "?comp"
qcomp:  dq  qcmp0
textm
qcmp0:  bt    qword[flgs0], 1           ; Test STATE Flag
        jc    qcmp1                     ; OK if flag set

        throwm 5                        ; Throw not compiling

qcmp1:  nextm
datam

; [ - Enter interpretation state. Clear STATE flag. This is an immediate word.

head    "[", -cmpo
lbrac:  dq  lbrc0
textm
lbrc0:  btr   qword[flgs0], 1
        nextm
datam

; ] - Enter compilation state. Set STATE flag. This is an immediate word.

head    "]", cmpo
rbrac:  dq  rbrc0
textm
rbrc0:  bts   qword[flgs0], 1
        nextm
datam

; immediate - Immediate words have the high bit of the object
;            type field set.

head    "immediate", cmpo
immed:  dq  immd0
textm
immd0:  mov   rdi, [nwnt0]              ; Get newentry
        bts   qword[rdi-8], 63          ; Set high bit of object type
        nextm
datam

; hidden - Set the hide bit the word just created so it doesn't appear
; in the words listing and can't be found with a dictionary search.

head    "hidden", cmpo
hiden:  dq  hidn0
textm
hidn0:  mov   rdi, [nwnt0]              ; Get newentry
        bts   qword[rdi-8], 62          ; Set the hide bit of object type
        nextm
datam

; ['] - Compile the execution token of the following word as a literal.

head    "[']", -hlfo
btick:  dq  docl0
        dq  qcomp,find,qfound,lite,semis

; postpone - Find word in dictionary. If the word is immediate, compile it.
;           Otherwise, compile (compile) followed by the execution token
;           of the word.

head    "postpone", -hlfo
postp:  dq  docl0
        dq  qcomp,find,dupl,qfound,zless,zbran,postp1
        dq  pcomm,pcomm
postp1: dq  comma,semis

; compile, - Append execution token on the stack to the word being compiled.
; Used in the place of `,` while compiling. Using `,` for this purpose is not portable.
; In the case of Forthx64, it is identical to `,`, but issues an error message if not
; compiling.

head    "compile,", cmpo
compc:  dq  cpcm0
textm
cpcm0:  bt    qword[flgs0], 1           ; Test STATE Flag
        jc    cpcm1                     ; OK if flag set

        throwm 5                        ; Error if not compiling

cpcm1:  mov   rdi, [dspo0]              ; Get dictionary pointer
        mov   rcx, [r14]                ; Pop stack item
        add   r14, 8
        mov   [rdi], rcx                ; Compile word at dsp address
        add   qword[dspo0], 8           ; Advance dictionary pointer
        nextm
datam

; (,) - puts the quad following the IP in the current dictionary pointer location.
; Used with precompiled code.

head    "(,)", cmpo, hidden
pcomm:  dq  pcom0
textm
pcom0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rsi, [r12]                ; Get contents of next IP address
        add   r12, 8                    ; Advance IP
        mov   [rdi], rsi                ; Install at dsp location
        add   qword[dspo0], 8           ; Advance dsp
        nextm
datam

; (compile) - Same action as (,), but issue an error message if not compiling.

head    "(compile)", cmpo, hidden
pcomp:  dq  pcmp0
textm
pcmp0:  bt    qword[flgs0], 1           ; Test STATE Flag
        jc    pcmp1                     ; OK if flag set

        throwm 5                        ; Error if not compiling

pcmp1:  mov   rdi, [dspo0]              ; Get dsp
        mov   rsi, [r12]                ; Get contents of next IP address
        add   r12, 8                    ; Advance IP
        mov   [rdi], rsi                ; Install at dsp location
        add   qword[dspo0], 8           ; Advance dsp
        nextm
datam

; allot - If n is greater than zero, reserve n address units of data space.
; If n is less than zero, release | n | address units of data space.
; If n is zero, leave the data-space pointer unchanged. Three possible error
; conditions exist - there is nothing on the stack, there is not enough room
; in the dictionary, or a negative value would release memory belonging
; to the precompiled dictionary.

head    "allot", cmpo
allot:  dq  alot0
textm
alot0:  lea   rdi, [dstack0]            ; Make sure there is a value
        cmp   rdi, r14                  ; on the stack
        jnz   alot1

        throwm 69

alot1:  mov   rax, [r14]                ; Pop stack value
        add   r14, 8
        mov   rdx, [dspo0]              ; Get data space pointer
        lea   rbx, [dsp0]               ; Get initial dsp
        bt    rax, 63                   ; See if value is negative
        jnc   alot2                     ; Branch if not

        add   rdx, rax                  ; Subtract from dsp
        cmp   rdx, rbx                  ; Compare original dsp
        jnc   alot3                     ; Branch if OK

        throwm 36

alot2:  sub   rdx, rbx                  ; Subtract initial dsp
        mov   rcx, dictsz               ; Get # of quads allocated for dictionary
        shl   rcx, 3                    ; Find # of bytes
        sub   rcx, rdx                  ; Subtract number of bytes used
        cmp   rcx, rax                  ; Compare stack value
        jnc   alot3                     ; Branch if there is room

        throwm 35

alot3:  add   [dspo0], rax              ; Add value to dsp
        nextm
datam

; header - Code to create a header for a new dictionary entry from the counted
; string left by `dctword` at the top of the dictionary and link it to the current
; vocabulary. The dictionary pointer will be left pointing to the CFA
; of the new word, which has been left in the first link field by `dctword`.
; As it is written now, vclnk, will clear the first link field after
; obtaining the new CFA from it.

namem   "header"
header: dq  hedr0
txtnm
hedr0:  mov   rdi, [r14]                ; Get 'pnfa'
        add   r14, 8                    ; Pop stack
        mov   [nwnt0], rdi              ; Update newentry
        mov   qword[rdi-8], 1           ; Install default object id
        mov   rsi, [dspo0]              ; Get current dsp
        add   rsi, 16                   ; Offset past link fields
        mov   [obsz0], rsi              ; Save to calculate object size
        mov   rsi, [rdi-32]             ; Get CFA of new word
        mov   [dspo0], rsi              ; Update dictionary pointer
        nextm
datam

; define - Create header for new defining word, and link it to the dictionary.
; This is used by the system for precompiled low-level defining words.
; It does not provide a default code field routine.

head    "define", hlfo, hidden
dfine:  dq  docl0
        dq  find,zbran,dfine1
        dq  four,itperr
        dq  lates,qat,bran,dfine2
dfine1: dq  dupl,qat,nzbran,dfine2
        dq  lit,46,throw
dfine2: dq  header,vclnk,semis

; create - Create header for new word, the default code field routine for
; create is dovar to place the address of the first cell past the CFA on
; the stack.

head    "create", hlfo
creat:  dq  docl0
        dq  find,zbran,xxf1
        dq  four,itperr
        dq  lates,qat,bran,xxf2
xxf1:   dq  dupl,qat,nzbran,xxf2
        dq  lit,46,throw
xxf2:   dq  header,vclnk,pcomm,vari0,semis

; create, - Create header for new high-level defining word. The 1st cell of the
; parameter field will contain the address of the high-level code.
; Installs the dfdo object type and the dods0 code-field routine. Reserves the
; 1st cell of the parameter field for the high-level code address.
; Requires `does>` to install address of high-level code in newly defined word.

head    "create,", -hlfo
crtcm:  dq  docl0
        dq  qcol,nzbran,crtcm1
        dq  lit,9,throw
crtcm1: dq  stdos,pcomm,crtcm2,semis

crtcm2: dq  docl0
        dq  find,zbran,crtcm3
        dq  four,itperr
        dq  lates,qat,bran,crtcm4
crtcm3: dq  dupl,qat,nzbran,crtcm4
        dq  lit,46,throw
crtcm4: dq  stcol,header
        dq  lit,dfdo,objcom,pcomm,dods0
        dq  zero,comma,semis
textm

; Put the PFA of the child on the stack and arrange to nest the execution
; of the high-level code following `does>`. Note that the PFA placed on the
; stack is the address after the address of the high-level code, which is not
; considered part of the parameter field.

dods0:  sub   r15, 8
        mov   [r15], r12                ; Put incr IP on RS
        add   r11, 8                    ; Increment WP
        mov   r12, [r11]                ; Get pointer to high-level code
        add   r11, 8                    ; Point to PFA of child
        sub   r14, 8
        mov   [r14], r11                ; Put PFA on DS
        mov   r11,[r12]                 ; Execute next macro
        add   r12,8
        jmp   [r11]
datam

; does> - Place the address of the high-level code in the 1st cell of the parameter
; field of the defined word and install its object size.

head    "does>", -hlfo
does:   dq  docl0
        dq  qcol,nzbran,does1
        dq  lit,9,throw
does1:  dq  cldos,pcomm,does2,semis

does2:  dq  docl0
        dq  vclnk,oszcom,endcol,ddoes,semis

ddoes:  dq  ddos0
textm
ddos0:  mov   rdi, [nwnt0]              ; Get newentry
        mov   rdx, [rdi]                ; Get character count
        mov   rcx, rdx                  ; Make copy
        and   rdx, 7                    ; See how much to add
        jz    ddos1                     ; Branch if no bytes to add

        neg   rdx
        add   rdx, 8
        add   rcx, rdx

; Here we add 8 for the length cell and 8 for code field to get to the 1st
; cell of the parameter field of the defined object. The address of the
; high-level code is installed here.

ddos1:  lea   rdi, [rdi+rcx+16]         ; Add for CFA+8
        mov   rsi, [r15]                ; Address is on return stack
        add   r15, 8                    ; Pop the return stack
        mov   [rdi], rsi                ; Install address of high-level code
        nextm
datam

; ?exec

head    "?exec"
qexec:  dq  qexc0
textm
qexc0:  bt    qword[flgs0], 1           ; Test STATE flag
        jnc   qexc1                     ; OK if flag clear

        throwm 6                        ; Throw not executing

qexc1:  nextm
datam

; : - begin a colon definition

head    ":", -hlfo
colon:  dq  docl0
        dq  qexec,scsp
        dq  find,zbran,xxg1
        dq  four,itperr
        dq  lates,qat,bran,xxg2
xxg1:   dq  dupl,qat,nzbran,xxg2
        dq  lit,46,throw
xxg2:   dq  stcol,header
        dq  pcomm,docl0,rbrac,semis
docol:  dq  docl0
textm
docl0:  sub   r15, 8                    ; Push current IP to return stack
        mov   [r15], r12
        lea   r12, [r11+8]              ; Replace it with this definition's IP
        nextm
datam

; ; - end colon definition

head    ";", -hlfo
semi:   dq  docl0
        dq  qcsp,pcomp,semis
        dq  lbrac,vclnk,oszcom,endcol,semis
semis:  dq  semi0
textm
semi0:  mov   r12, [r15]                ; Pop previous IP from return stack
        add   r15, 8
        nextm
datam

; code: - begin a code definition. Compiles a pointer to the code. Leaves base
; address of system variables before the code length, where it will be available
; to the code module at r11-16.

head    "code:", -hlfo
ccoln:  dq  docl0
        dq  qexec,scsp
        dq  find,zbran,xcc1
        dq  four,itperr
        dq  lates,qat,bran,xcc2
xcc1:   dq  dupl,qat,nzbran,xcc2
        dq  lit,46,throw
xcc2:   dq  stcol,header,here,eighp
        dq  eighp,eighp,comma,lit,sysvar0
        dq  comma,rbrac,semis

; endcode - end code definition

head    "endcode", -hlfo
ecod:   dq  docl0
        dq  qcsp,lbrac,vclnk
        dq  oszcom,endcol,semis

; cs, ( addr n --- ) Compile a string literal of length n at address
; as a counted string at the current dictionary location.

head    "cs,", cmpo
cscom:  dq  cscm0
textm
cscm0:  mov   rdx, [r14]                ; Get source character count
        mov   rsi, [r14+8]              ; Get buffer address
        add   r14, 16                   ; Pop the stack
        cmp   rdx, 0                    ; Exit if length is zero
        jz    cscm4

        mov   rdi, [dspo0]              ; Get dictionary pointer
        mov   [rdi], rdx                ; Install character count
        add   rdi, 8                    ; Advance pointer
        xor   rcx, rcx                  ; Initialize index
        mov   rbx, rdx                  ; Copy char count

cscm1:  mov   al, [rsi+rcx]             ; Move string to dictionary
        mov   [rdi+rcx], al
        add   rcx, 1
        sub   rbx, 1
        jnz   cscm1

        mov   rdx, rcx                  ; Copy character count
        and   rdx, 7                    ; See how many blanks to add
        jz    cscm3                     ; No padding needed
        neg   rdx
        add   rdx, 8

cscm2:  mov   byte[rdi+rcx], 32         ; Pad word to 64-bit boundary
        add   rcx, 1                    ; Increment count/index
        sub   rdx, 1                    ; Decrement counter
        jnz   cscm2                     ; Loop for pad-byte count

cscm3:  lea   rsi, [rdi+rcx]            ; Load new dictionary pointer address
        mov   [dspo0], rsi              ; Update dictionary pointer

cscm4:  nextm
datam

; ."

head    '."', -hlfo
dotq:   dq  docl0
        dq  pcomp,pdotq,dbqt,csword,drop,semis

; s" - When compiling, move the string delimited by double quotes to the dictionary
; as a counted string. At runtime put the address and length of the string on the
; stack. When interpreting put the delimited string in a temporary buffer (axb0)
; and return it address and length to the stack. The existence of the string is
; transitory, since the next execution of s" will overwrite it in the buffer.

head    's"', -hlfo
strq:   dq  docl0
        dq  stat,nzbran,strq1
        dq  axbn,dbqt,dlmwrd
        dq  dupl,eighm,qat,bran,strq2
strq1:  dq  pcomp,pstrq,dbqt,csword,drop
strq2:  dq  semis
pstrq:  dq  pstq0
textm
pstq0:  mov   rbx, [r12]                ; Get string length
        add   r12, 8                    ; Offset past length
        sub   r14, 16                   ; Create stack space
        mov   [r14+8], r12              ; Return address of string
        mov   [r14], rbx                ; Return length of string
        mov   rcx, rbx                  ; Copy length
        and   rcx, 7                    ; Calculate offset past string
        jz    pstq1                     ; No additional bytes
        neg   rcx
        add   rcx, 8
        add   r12, rcx
pstq1:  add   r12, rbx                  ; Advance IP past string
        nextm
datam

; c" - Used only in colon definitions. Compiles the following string.
;     At runtime it puts the address of the counted string on the stack.

head    'c"', -hlfo
chrq:   dq  docl0
        dq  pcomp,pchrq,dbqt,csword,drop,semis
pchrq:  dq  pchq0
textm
pchq0:  mov   rbx, [r12]                ; Get string length
        sub   r14, 8                    ; Create stack space
        mov   [r14], r12                ; Return address of string
        add   r12, 8                    ; Offset past length
        mov   rcx, rbx                  ; Copy length
        and   rcx, 7                    ; Calculate offset past string
        jz    pchq1                     ; No additional bytes
        neg   rcx
        add   rcx, 8
        add   r12, rcx
pchq1:  add   r12, rbx                  ; Advance IP past string
        nextm
datam

; [char] - Compile the ascii value of the next character in the input stream
; as a literal.

; : [char]   char literal ; immediate

head    "[char]", -hlfo

bchar:  dq  docl0
        dq  qcomp,char,lite,semis

; sliteral - Compile the string whose address and length are on the stack.
; At runtime return the string's address and length.

head    "sliteral", -hlfo
slit:   dq  docl0
        dq  pcomp,pslit,cscom,semis
pslit:  dq  pslt0
textm
pslt0:  mov   rbx, [r12]                ; Get string length
        add   r12, 8                    ; Offset past length
        sub   r14, 16                   ; Create stack space
        mov   [r14+8], r12              ; Return address of string
        mov   [r14], rbx                ; Return length of string
        mov   rcx, rbx                  ; Copy length
        and   rcx, 7                    ; Calculate offset past string
        jz    pslt1                     ; No additional bytes
        neg   rcx
        add   rcx, 8
        add   r12, rcx
pslt1:  add   r12, rbx                  ; Advance IP past string
        nextm
datam

; literals - ( number case --- ) compile the number on the stack as a literal
; according to one of the following case numbers passed on the stack:

;   1 - 64-bit integer
;   2 - multi-precision integer
;   3 - real
;   4 - rational
;   5 - floating-point

; Note that these are the same as the number types specified in byte-string numbers.

head    "literals", -hlfo
lites:  dq  dlts0
        dq  lite,inlite,relite,ralite,fllite

; Special jump table routine for literals.

textm
dlts0:  mov   rdx, [r14]                ; Get index
        add   r14, 8                    ; Pop stack
        mov   r11, [r11+rdx*8]          ; Get corresponding vector
        jmp   [r11]                     ; Jump
datam

; file,  <filename> Place the contents of the file, preceded by the number
; of bytes read, at the current dictionary location and pad with zeroes to an
; 8-byte boundary. Advance the dictionary pointer.
; Intended for installing machine code pointed to by the code field
; of a dictionary entry.

head    "file,", hlfo
flecom: dq  docl0
        dq  axbn,bufwrd
        dq  rdonly,openf,dupl,toa
        dq  here,dupl,toa,eighp,
        dq  swp,lodfl,dupl,froma,stor
        dq  rute,eighp,allot,froma,closef,semis

; *** Program Control

; ?pair

head    "?pair"
qpair:  dq  qpar0
textm
qpar0:  mov   rdx, [r14]
        add   r14, 8
        cmp   [r14], rdx
        jz    qpar1

        throwm 7

qpar1:  add   r14, 8
        nextm
datam

; branch  - unconditional branch

head    "branch", hlfo, hidden
branch: dq  docl0
        dq  pcomp,bran,semis
bran:   dq  bran0
textm
bran0:  mov   r12, [r12]
        nextm
datam

; ?branch  - conditional branch

head    "?branch", hlfo, hidden
qbran:  dq  docl0
        dq  pcomp,zbran,semis
zbran:  dq  zbrn0
textm
zbrn0:  mov   rdx, [r14]
        add   r14, 8
        test  rdx, rdx
        jz    zbrn1
        add   r12, 8
        jmp   zbrn2
zbrn1:  mov   r12, [r12]
zbrn2:  nextm
datam

; do

; : do   (compile) ddo here 8 allot here 3 ; immediate

head    "do", -hlfo
_do     dq  docl0
        dq  pcomp,ddo,here,eight,allot
        dq  here,three,semis
ddo:    dq  xdo0
textm
xdo0:   mov   rdx, [r12]                ; Get exit addr
        add   r12, 8                    ; Advance Interpreter Pointer
        sub   r15, 8
        mov   [r15], rdx                ; Push exit addr to return stack.
        mov   rdx, 0
        bts   rdx,63                    ; Set "universal loop limit" in rdx
        sub   rdx, [r14+8]              ; Subtract limit, l-L
        sub   r15, 16                   ; Make room on return stack
        mov   [r15+8], rdx              ; Push transformed limit to stack
        add   rdx, [r14]                ; Add index to new limit, 1-L+l
        mov   [r15], rdx                ; Push transformed index to stack
        add   r14, 16                   ; Pop data stack
        nextm
datam

; ?do

; : ?do   (compile) xqdo here 8 allot here 3 ; immediate

head    "?do", -hlfo
qdo:    dq  docl0
        dq  pcomp,xqdo,here,eight,allot
        dq  here,three,semis
xqdo:   dq  xqdo0
textm
xqdo0:  mov   rdx, [r12]                ; Get exit addr
        add   r12, 8                    ; Advance Interpreter Pointer
        mov   rcx, [r14]                ; Get loop start
        cmp   [r14+8], rcx              ; Compare start with limit
        jnz   xqdo1                     ; Continue if not equal
        mov   r12, rdx                  ; Leave loop if equal
        jmp   xqdo2
xqdo1:  sub   r15, 8
        mov   rdx, 0
        bts   rdx,63                    ; Set "universal loop limit" in rdx
        sub   rdx, [r14+8]              ; Subtract limit, 1-L
        sub   r15, 16                   ; Make room on return stack
        mov   [r15+8], rdx              ; Push transformed limit to stack
        add   rdx, [r14]                ; Add index to new limit, 1-L+l
        mov   [r15], rdx                ; Push transformed index to stack
xqdo2:  add   r14, 16                   ; Pop data stack
        nextm
datam

; loop

; : loop   ?comp 3 ?pair (,) _loop , >resolve ; immediate

head    "loop", -hlfo
xloop:  dq  docl0
        dq  qcomp,three,qpair,pcomm,_loop
        dq  comma,frslv,semis
_loop   dq  loop0
textm
loop0:  add   qword[r15], 1             ; Increment loop counter.
        jno   loop1
        add   r15, 24
        add   r12, 8
        jmp   loop2
loop1:  mov   r12, [r12]
loop2:  nextm
datam

; +loop

; : +loop   ?comp 3 ?pair (,) xploop , >resolve ; immediate

head    "+loop", -hlfo
ploop:  dq  docl0
        dq  qcomp,three,qpair,pcomm,xploop
        dq  comma,frslv,semis
xploop: dq  ploo0
textm
ploo0:  mov   rdx, [r14]                ; Pop increment value
        add   r14, 8
        add   [r15], rdx                ; Increment loop counter.
        jno   ploo1
        add   r15, 24
        add   r12, 8
        jmp   ploo2
ploo1:  mov   r12, [r12]
ploo2:  nextm
datam

; unloop

; : unloop   (compile) unlp ; immediate

head    "unloop", -hlfo
unloop: dq  docl0
        dq  pcomp,unlp,semis
unlp:   dq  unlp0
textm
unlp0:  add   r15, 24                   ; Drop loop parameters
        nextm
datam

; leave - prematurely exit from loop

; : leave   (compile) xleave ; immediate

head    "leave", -hlfo
leav:   dq  docl0
        dq  pcomp,xleave,semis
xleave: dq  leav0
textm
leav0:  add   r15, 24                   ; Pop loop parameters from return stack
        mov   r12, [r15-8]              ; Put loop exit addr in Interpreter Pointer
        nextm
datam

; i - Return the current loop count

; : i   (compile) indx ; immediate

head    "i", -hlfo
_i      dq  docl0
        dq  pcomp,indx,semis
indx:   dq  indx0
textm
indx0:  mov   rdx, [r15]                ; Get index
        sub   rdx, [r15+8]              ; Subtract I-reference from index
        sub   r14, 8
        mov   [r14], rdx                ; Push result to data stack.
        nextm
datam

; j - Return the loop count of the next outer loop

; : j   (compile) jndx ; immediate

head    "j", -hlfo
_j      dq  docl0
        dq  pcomp,jndx,semis
jndx:   dq  jndx0
textm
jndx0:  mov   rdx, [r15+24]             ; Get index
        sub   rdx, [r15+32]             ; Subtract I-reference from index
        sub   r14, 8
        mov   [r14], rdx                ; Push result to data stack.
        nextm
datam

; k - Return the loop count of the next outer loop

; : k   (compile) kndx ; immediate

head    "k", -hlfo
_k      dq  docl0
        dq  pcomp,kndx,semis
kndx:   dq  kndx0
textm
kndx0:  mov   rdx, [r15+48]             ; Get index
        sub   rdx, [r15+56]             ; Subtract I-reference from index
        sub   r14, 8
        mov   [r14], rdx                ; Push result to data stack.
        nextm

datam

; if

; : if   (compile) izbrn >mark 2 ; immediate

head    "if", -hlfo
_if     dq   docl0
        dq  pcomp,izbrn,fmark
        dq  two,semis
izbrn:  dq  izbr0
textm
izbr0:  mov   rdx, [r14]
        add   r14, 8
        test  rdx, rdx
        jz    izbr1
        add   r12, 8
        jmp   izbr2
izbr1:  mov   r12, [r12]
izbr2:  nextm
datam

; else

; : else   ?comp 2 ?pair (,) bran >mark here rot ! 2 ; immediate

head    "else", -hlfo
_else   dq  docl0
        dq  qcomp,two,qpair,pcomm,ebran
        dq  fmark,here,rot,stor,two,semis
ebran:  dq  ebrn0
textm
ebrn0:  mov   r12, [r12]
        nextm
datam

; then

; : then   ?comp 2 ?pair >resolve ; immediate

head    "then", -hlfo
_then   dq  docl0
        dq  qcomp,two,qpair,frslv,semis

; begin

; : begin   ?comp <mark 1 ; immediate

head    "begin", -hlfo
_begin  dq  docl0
        dq  qcomp,bmark,one,semis

; again

; : again   ?comp 1 ?pair (,) abran <resolve ; immediate

head    "again", -hlfo
_again  dq  docl0
        dq  qcomp,one,qpair,pcomm,abran,brslv,semis
abran:  dq  abrn0
textm
abrn0:  mov   r12, [r12]
        nextm
datam

; until

; : until   ?comp 1 ?pair (,) zbran <resolve ; immediate

head    "until", -hlfo
_until  dq  docl0
        dq  qcomp,one,qpair,pcomm,uzbrn,brslv,semis
uzbrn:  dq  uzbr0
textm
uzbr0:  mov   rdx, [r14]
        add   r14, 8
        test  rdx, rdx
        jz    uzbr1
        add   r12, 8
        jmp   uzbr2
uzbr1:  mov   r12, [r12]
uzbr2:  nextm
datam

; while

; : while   ?comp 1 ?pair (,) wzbrn >mark 1 ; immediate

head    "while", -hlfo
_while  dq  docl0
        dq  qcomp,one,qpair,pcomm,wzbrn
        dq  fmark,one,semis
wzbrn:  dq  wzbr0
textm
wzbr0:  mov   rdx, [r14]
        add   r14, 8
        test  rdx, rdx
        jz    wzbr1
        add   r12, 8
        jmp   wzbr2
wzbr1:  mov   r12, [r12]
wzbr2:  nextm
datam

; repeat

; : repeat   ?comp 1 ?pair (,) rbran swap <resolve >resolve ; immediate

head    "repeat", -hlfo
_rept   dq  docl0
        dq  qcomp,one,qpair,pcomm,rbran
        dq  swp,brslv,frslv,semis
rbran:  dq  rbrn0
textm
rbrn0:  mov   r12, [r12]
        nextm
datam

; recurse

head    "recurse", -pgmo
_recur  dq  recr0
textm
recr0:  bt    qword[flgs0], 1           ; Test STATE Flag
        jc    recr1                     ; OK if flag set

        throwm 5                        ; Throw not compiling

recr1:  mov   rsi, [nwnt0]              ; Get NFA of word being defined
        mov   rdx, [rsi-32]             ; Get new CFA from 1st link field
        mov   rdi, [dspo0]              ; Get dsp
        mov   [rdi], rdx                ; Install execution token
        add   qword[dspo0], 8           ; Advance dsp
        nextm
datam

; exit - Return control to the calling definition.

; : exit   (compile) semis ; immediate

head    "exit", -hlfo
xexit:  dq  docl0
        dq  pcomp,dexit,semis
dexit:  dq  exit0
textm
exit0:  mov   r12, [r15]                ; Pop previous IP from return stack
        add   r15, 8
        nextm
datam

; The following words implement Will Baden's Ultimate Case Statement.

; case

; : case   dup ;

head    "case", hlfo
case:   dq  docl0
        dq  dupl,semis

; of

; : of   if (,) drop then ;

head    "of", -hlfo
xof:    dq  docl0
        dq  _if,pcomm,drop,semis

; =or   ( n flag n --- n flag )
;       Test if the top stack item is equal to the 3rd stack item, and or
;      the result flag with the second stack item. leaving the 3rd item
;      and the result flag on the stack.

head    "=or", pgmo
eqor:   dq  eqor0
textm
eqor0:  mov   rdx, [r14+16]             ; Get 3rd stack item
        cmp   rdx, [r14]                ; Compare with top item
        setz  dl                        ; Set flag to true if equal
        neg   dl
        movsx rdx, dl
        add   r14, 8                    ; Drop top stack item
        or    [r14], rdx                ; Or top two stack items
        nextm
datam

; defer

head    "defer", hlfo
defe:   dq  docl0
        dq  dfine,lit,dfro,objcom,pcomm,ddfr0
        dq  zero,comma,oszcom,semis
textm
ddfr0:  cmp   qword[r11+8], 0           ; See if in-line vector is zero
        jnz   ddfr1                     ; Branch if not

        throwm 15                       ; Throw uninitialized defer

ddfr1:  mov   r11, [r11+8]              ; Get vector
        jmp   [r11]                     ; Take vector
datam

; is - ( xt --- ) Set the execution token of a defer. Throw error if object
; is not a defer.

head    "is", hlfo
xis:    dq  docl0
        dq  tick,dupl,cftota,obtat
        dq  lit,dfro,ntequ,zbran,xis1
        dq  lit,64,throw
xis1:   dq  eighp,stor
        dq  semis

; radio - Create a radio structure with its first cell containing the number
; of vectors and its second cell containing either zero in the uninitialized
; state or the number of the current vector.
; ( number-of-vectors --- ).
;
; radio structure:
;
; | links and header | code field | number of vectors | 0 or current vector
; | vector 1 | ... | vector n |
;

head    "radio", hlfo
radio:  dq  docl0
        dq  dfine,lit,rado,objcom,pcomm,radi0
        dq  dupl,comma,zero,comma,estar,allot
        dq  oszcom,semis
textm
radi0:  cmp   qword[r11+16], 0          ; See if offset is zero
        jnz   radi1                     ; Branch if not

        throwm 16                       ; Throw uninitialized radio

radi1:  mov   r11, [r11+16]             ; Get current vector
        jmp   [r11]                     ; Take vector
datam

; punch - ( n --- ) Push radio button n.

head    "punch", hlfo
punch:  dq  docl0
        dq  tick,dupl,cftota,obtat
        dq  lit,rado,ntequ,zbran,punch1
        dq  lit,65,throw
punch1: dq  pnch,semis
pnch:   dq  pnch0
textm
pnch0:  mov   rdi, [r14]                ; Get CFA
        mov   rax, [r14+8]              ; Get index
        add   r14, 16                   ; Pop stack
        cmp   rax, 0                    ; See if index is 0
        jz    pnch1

        cmp   [rdi+8], rax              ; See if index is in bounds
        jnc   pnch2                     ; Branch if so

; Throw index out of bounds

pnch1:  throwm 14   

pnch2:  mov   rsi, [rdi+rax*8+16]       ; Get vector
        mov   [rdi+16], rsi             ; Install vector
        nextm
datam

; toggle - Create a 2-vectored radio structure.
; Although a toggle is a special instance of the radio structure,
; it has a different code field routine and object id.

head    "toggle", hlfo
toggl:  dq  docl0
        dq  two,dfine,lit,tglo,objcom,pcomm,togl0
        dq  dupl,comma,zero,comma,estar,allot
        dq  oszcom,semis
textm
togl0:  cmp   qword[r11+16], 0          ; See if offset is zero
        jnz   togl1                     ; Branch if not

        throwm 17                       ; Throw uninitialized toggle

togl1:  mov   rdx, [r11+16]             ; Get hash number
        mov   r11, [r11+rdx*8+16]       ; Get vector
        jmp   [r11]                     ; Take vector
datam

; flip - If the toggle vector number is 1 change it to 2,
;       if 2 make it 1. Throw 64 if object is not a toggle.

head    "flip", hlfo
xflip:  dq  docl0
        dq  tick,dupl,cftota,obtat
        dq  lit,tglo,ntequ,zbran,xflip1
        dq  lit,66,throw
xflip1: dq  flip,semis
flip:   dq  flip0
textm
flip0:  mov   rdi, [r14]                ; Get CFA
        add   r14, 8                    ; Pop stack
        cmp   qword[rdi+16], 1          ; See if vector is 1
        jnz   flip1                     ; Branch if not
        mov   qword[rdi+16], 2          ; Make it 2
        jmp   flip2                     ; Exit
flip1:  mov   qword[rdi+16], 1          ; Make it 1
flip2:  nextm
datam

; buffer: <name>  ( n --- ) Create a buffer of size n named `name` and having
; the following format:
; name | code | link | length | current pointer | data | bic# |
; The buffer size must be at least eight bytes and will be padded to an
; 8-byte boundary.
; The buffers created with this word form a linked list with the head
; contained in the system variable, buffer-link.

head    "buffer:", hlfo
bfcol:  dq  docl0
        dq  one,ckstk
        dq  dupl,eight,less,zbran,bfcol1
        dq  lit,42,throw
bfcol1: dq  dfine,lit,ubfo,objcom,pcomm,bfco0
        dq  bulnk,dupl,comma,zero,comma,rute
        dq  zallot,bicn,dcomma,oszcom,semis

; The bfco0 code-field routine places the address of the buffer data
; on the stack. It skips the cells containing the buffer size and current
; pointer.

textm
bfco0:  lea   rdx, [r11+32]             ; Get in-line address of data
        sub   r14, 8                    ; Push to stack
        mov   [r14], rdx
        nextm
datam

; clear-buffer ( addr1 --- addr1 ) Clears the buffer if it contains any data as
; determined by the current buffer pointer. Does nothing if the pointer is
; zero. Note that it does not pop the stack.

head    "clear-buffer"
clrbuf: dq  clbu0
textm
clbu0:  mov   rdi, [r14]                ; Get buffer address
        mov   rax, [rdi-8]              ; Get number of characters in buffer
        cmp   rax, 0                    ; See if none
        jz    clbu3                     ; Exit if none

        mov   rcx, rax                  ; Copy character count
        and   rax, 7                    ; See how much to add
        jz    clbu1                     ; Branch if no bytes to add

        neg   rax
        add   rax, 8
        add   rcx, rax                  ; Add rounding bytes

clbu1:  shr   rcx, 3                    ; Convert to quad count
        add   rcx, 1                    ; Add 1 for buffer pointer
clbu2:  mov   qword[rdi+rcx*8-16], 0    ; Null buffer pointer and contents
        sub   rcx, 1                    ; Decrement counter
        jnz   clbu2

clbu3:  nextm
datam

; zrobuf ( addr --- ) Initialize the buffer at addr
; by filling it with zero and clearing the buffer pointer.
; Note that this definition relies on the buffer having
; the format | size | ptr | data | with the address
; pointing to the data field.
; Unlike the previous definition, the operator clears the entire
; buffer based on its size, rather than the number of characters
; it contains.

head    "zrobuf"
zrobuf: dq  zrbf0
textm
zrbf0:  mov   rdi, [r14]                ; Get buffer addr
        add   r14, 8                    ; Pop stack
        mov   rcx, [rdi-16]             ; Get buffer size
        shr   rcx, 3                    ; Convert to quad count
        add   rcx, 1                    ; Add 1 for buffer pointer
zrbf1:  mov   qword[rdi+rcx*8-8], 0     ; Null buffer and pointer
        sub   rcx, 1
        jnz   zrbf1
        nextm
datam

; initbuf ( char addr --- ) fill the buffer with char
; Note that this definition relies on the buffer having
; the format | size | ptr | data | with the address
; pointing to the data field.

head    "initbuf"
intbuf: dq  itbf0
textm
itbf0:  mov   rdx, [r14]                ; Get fill char
        mov   [r14+1], dl               ; Compose quad
        mov   [r14+2], dl               ; of fill chars
        mov   [r14+3], dl
        mov   [r14+4], dl
        mov   [r14+5], dl
        mov   [r14+6], dl
        mov   [r14+7], dl
        mov   rdx, [r14]                ; Get composed quad
        mov   rdi, [r14+8]              ; Get buffer addr
        add   r14, 16                   ; Pop stack
        mov   qword[rdi-8], 0           ; Zero buffer pointer
        mov   rcx, [rdi-16]             ; Get buffer size
        shr   rcx, 3                    ; Convert to quad count
itbf1:  mov   [rdi+rcx*8-8], rdx        ; Fill buffer with delimiter
        sub   rcx, 1
        jnz   itbf1
        nextm
datam

; file: - file: <path> Create a file structure with the following fields:
; name | code | link to previous file | file id | buffer address |
; file access method | file permissions | file status | file size |
; current postion pointer | length of pathname | pathname

head    "file:", hlfo
filcol: dq  docl0
        dq  axbn,blsp,filwrd
        dq  pfind,zbran,filc1
        dq  four,itperr
        dq  lates,qat,bran,filc2
filc1:  dq  dupl,qat,nzbran,filc2
        dq  lit,46,throw
filc2:  dq  fhead,vclnk,semis
fhead:  dq  fhed0

; fhead - Special header creation routine for creating the file structure.
; Since filwrd has installed the file pathname and set the dictionary
; pointer at the end of the pathname, this special code is required to
; establish the header.
textm
fhed0:  mov   rdi, [r14]                ; Get 'pnfa'
        add   r14, 8                    ; Pop stack
        mov   [nwnt0], rdi              ; Update newentry
        mov   qword[rdi-8], fsto        ; Install file object id

; Traverse to CFA.

        mov   rdx, [rdi]                ; Get name length
        mov   rcx, rdx                  ; Make copy
        and   rcx, 7                    ; See how much to add
        jz    fhed1                     ; Branch if no bytes to add
        neg   rcx
        add   rcx, 8
        add   rdx, rcx                  ; Add bytes
fhed1:  lea   rsi, [rdi+rdx+8]          ; Load CFA
        lea   rbp, [vari0]              ; Get address of code routine
        mov   [rsi], rbp                ; Install code routine
        add   rsi, 8                    ; Advance to file-link field
        mov   rdx, [flnk0]              ; Get current file-link
        mov   [rsi], rdx                ; Install link
        mov   [flnk0], rsi              ; Update file-link
        mov   qword[rsi+8], 0           ; Zero 7 quads
        mov   qword[rsi+16], 0
        mov   qword[rsi+24], 0
        mov   qword[rsi+32], 0
        mov   qword[rsi+40], 0
        mov   qword[rsi+48], 0
        mov   qword[rsi+56], 0
        add   rsi, 64                   ; Advance to pathname
        mov   rdx, [rsi]                ; Get length of pathname
        mov   rcx, rdx                  ; Make copy
        add   rsi, 8                    ; Advance past length
        and   rdx, 7
        jnz   fhed2

        add   rcx, 8                    ; Add 8 for quad of nulls
        jmp   fhed3

fhed2:  neg   rdx
        add   rdx, 8
        add   rcx, rdx

fhed3:  add   rsi, rcx                  ; Add pathname length
        mov   [dspo0], rsi              ; Update dsp
        lea   rdi, [rdi-16]             ; Load addr of object size field
        sub   rsi, rdi                  ; Subtract size field address
        mov   [rdi], rsi                ; Install object size
        nextm
datam

; path - ( file-name --- addr-of-path ) Given the filename, return the
; address of the asciiz string for the path.

head    "path", hsto
pathf:  dq  path0
textm
path0:  add   qword[r14], 72
        nextm
datam

; startup - Prototype file structure.
; Note: file path is a counted asciiz string

head    "startup", fsto
strtup: dq  vari0
filk0:  dq  0                           ; file-link
        dq  0                           ; fileid
        dq  fib0                        ; buffer address
        dq  0x42                        ; file access method
        dq  0664o                       ; file permissions
        dq  0                           ; file status
        dq  0                           ; file size
        dq  0                           ; current position pointer
        casczm "startup"                ; file path

; erase - ( addr n --- ) - Fill n bytes of memory starting at address with zero.

head    "erase"
erase:  dq  eras0
textm
eras0:  mov   rcx, [r14]                ; Get count
        mov   rdi, [r14+8]              ; Get start address
        add   r14, 16                   ; Pop stack
eras1:  mov   byte[rdi+rcx-1], 0        ; Fill memory with zeroes
        sub   rcx, 1                    ; Decrement count
        jnz   eras1                     ; Loop for count
        nextm
datam

; qerase - ( addr n --- ) - Fill n quads of memory starting at address with zero.

head    "qerase"
qerase: dq  qers0
textm
qers0:  mov   rcx, [r14]                ; Get count
        mov   rdi, [r14+8]              ; Get start address
        add   r14, 16                   ; Pop stack
qers1:  mov   qword[rdi+rcx*8-8], 0     ; Fill memory with zeroes
        sub   rcx, 1                    ; Decrement count
        jnz   qers1                     ; Loop for count
        nextm
datam

; blank

head    "blank"
blank:  dq  blnk0
textm
blnk0:  mov   rcx, [r14]                ; Get count
        mov   rdi, [r14+8]              ; Get start address
        add   r14, 16                   ; Pop stack
blnk1:  mov   byte[rdi+rcx-1], 32       ; Fill memory with spaces
        sub   rcx, 1                    ; Decrement count/index
        jnz   blnk1                     ; Loop for count
        nextm
datam

; fill

head    "fill"
fill:   dq  fill0
textm
fill0:  mov   rbx, [r14]                ; Get fill character
        mov   rcx, [r14+8]              ; Get count
        mov   rdi, [r14+16]             ; Get start address
        add   r14, 24                   ; Pop stack
fill1:  mov   [rdi+rcx-1], bl           ; Fill memory with character
        sub   rcx, 1                    ; Decrement count/index
        jnz   fill1                     ; Loop for count
        nextm
datam

; pad>8 - ( addr1 chr --- addr2) - If the supplied address is not an even multiple
; of eight bytes, make it so by padding it with chr and return the new address.

head    "pad>8"
padte:  dq  pdte0
textm
pdte0:  mov   rcx, [r14+8]              ; Get address
        mov   rdi, rcx                  ; Make copy
        mov   rbx, [r14]                ; Get pad character
        add   r14, 8                    ; Pop 1 stack item
        and   rcx, 7                    ; See how many chars to add
        jz    pdte2                     ; None needed
        neg   rcx
        add   rcx, 8
        add   [r14], rcx                ; Add number of pad bytes to address
pdte1:  mov   [rdi+rcx-1], bl           ; Pad address to 8-byte boundary
        sub   rcx, 1                    ; Decrement counter
        jnz   pdte1

pdte2:  nextm
datam

; cmove - ( c-addr1 c-addr2 u --- ) Move bytes in memory
;        from lower to higher address.

head    "cmove"
cmovd:  dq  cmvd0
textm
cmvd0:  mov   rcx, [r14]                ; Get number of bytes to move
        mov   rdi, [r14+8]              ; Get destination address
        mov   rsi, [r14+16]             ; Get source address
        add   r14, 24                   ; Pop stack
        lea   rdi, [rdi+rcx]            ; Offset to destination base addr
        lea   rsi, [rsi+rcx]            ; Offset to source base addr
        neg   rcx                       ; Create negative count
cmvd1:  mov   bl, [rsi+rcx]             ; Move bytes
        mov   [rdi+rcx], bl
        add   rcx, 1
        jnz   cmvd1
        nextm
datam

; cmove> - ( c-addr1 c-addr2 u --- ) Move bytes in memory
;         from higher to lower addresses.

head    "cmove>"
cmovu:  dq  cmvu0
textm
cmvu0:  mov   rcx, [r14]                ; Get number of bytes to move
        mov   rdi, [r14+8]              ; Get destination address
        mov   rsi, [r14+16]             ; Get source address
        add   r14, 24                   ; Pop stack
cmvu1:  mov   bl, [rsi+rcx-1]           ; Move bytes
        mov   [rdi+rcx-1], bl
        sub   rcx, 1
        jnz   cmvu1
        nextm
datam

; -trailing - ( c-addr u1 - c-addr u2 ) remove trailing blanks from string
;            and return the new length.

head    "-trailing"
dtrail: dq  dtrl0
textm
dtrl0:  mov   rcx, [r14]                ; Get character count
        mov   rdi, [r14+8]              ; Get start address
        cmp   rcx, 0                    ; Exit if count is zero
        jz    dtrl3
dtrl1:  cmp   byte[rdi+rcx-1], 32       ; See if byte is space
        jnz   dtrl2                     ; Exit if not
        sub   rcx, 1                    ; Decrement character count
        jnz   dtrl1                     ; Loop
dtrl2:  mov   [r14], rcx                ; Return length without blanks
dtrl3:  nextm
datam

; /string - ( c-addr1 u1 n --- c-addr2 u2 ) trim n characters from the beginning
;          of string at c-addr1 of length u1 and return the new address and length.

head    "/string"
slstr:  dq  slst0
textm
slst0:  mov   rcx, [r14]                ; Get number of bytes to trim
        add   r14, 8                    ; Pop one item
        add   [r14+8], rcx              ; Add number of trim chrs to address
        sub   [r14], rcx                ; Subtract trim chrs from length
        nextm
datam

; compare - ( c-addr1 u1 c-addr2 u2 --- n )

head    "compare"
compa:  dq  cmpr0

; Routine uses three track vectors.
; trak1 - u1=u3
; trak2 - u1<u2
; trak3 - u1>u2

textm
cmpr0:  mov   rdx, [r14]                ; Get u2
        mov   rdi, [r14+8]              ; Get c-addr2
        mov   rcx, [r14+16]             ; Get u1
        mov   rsi, [r14+24]             ; Get c-addr1
        add   r14, 24                   ; Pop three items
        cmp   rdx, rcx                  ; cmprre string lengths
        jnz   cmpr1                     ; Branch if u1<>u2
        lea   r9, [trak1]               ; Set vector to trak1
        mov   rbx, rcx                  ; Set counter to common length
        xor   rdx, rdx                  ; Zero index
        jmp   cmpr3                     ; Enter cmprre loop

cmpr1:  jc    cmpr2                     ; Branch if u1<u2
        lea   r9, [trak2]               ; Set vector to trak2
        mov   rbx, rdx                  ; Set counter to u2
        jmp   cmpr3                     ; Enter cmprre loop

cmpr2:  lea   r9, [trak3]               ; Set vector to trak3
        mov   rbx, rcx                  ; Set counter to u1

cmpr3:  mov   al, [rsi+rdx]             ; Compare characters
        cmp   al, [rdi+rdx]
        jnz   cmpr4                     ; Branch on mismatch
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   cmpr3                     ; Loop

        jmp   r9                        ; Take vector if loop falls through

trak1:  mov   qword[r14], 0             ; Return 0
        jmp   cmpr6

trak2:  mov   qword[r14], 1             ; Return 1
        jmp   cmpr6

trak3:  mov   qword[r14], -1            ; Return -1
        jmp   cmpr6

; Loop left before counter exhausted

cmpr4:  jc    cmpr5
        mov   qword[r14], 1
        jmp   cmpr6
cmpr5:  mov   qword[r14], -1

cmpr6:  nextm
datam

; search - ( c-addr1 u1 c-addr2 u2 --- c-addr3 u3 flag )
;  Given the address and length of a buffer containing the text to be
; searched (c-addr2 and u2) and the address and length of a pattern
; to match (c-addr1 and u1), search the text for a match. If a match
; is found, return its address (c-addr3), the number of characters
; remaining in the text buffer (u3), and a true flag.
; If no match is found, return the original text buffer address
; ( c-addr2), the original length (u2), and a false flag.
; This is an implementation of the Boyer-Moore-Horspool algorithm.

; Register usage

;   r9  - skip-table address
;   r8  - string length / counter / index
;   rbp - skip register
;   rdi - text buffer address
;   rsi - pattern buffer address
;   rdx - text buffer remaining size
;   rcx - skip value counter
;   rbx - index register
;   rax - byte register

head    "search"
srch:   dq  srch0
textm
srch0:  mov   r8, [r14]                 ; Get string length
        mov   al, r8b                   ; Compose a quad of bytes
        shl   rax, 8
        mov   al, r8b
        shl   rax, 8
        mov   al, r8b
        shl   rax, 8
        mov   al, r8b
        shl   rax, 8
        mov   al, r8b
        shl   rax, 8
        mov   al, r8b
        shl   rax, 8
        mov   al, r8b
        shl   rax, 8
        mov   al, r8b
        lea   r9, [stab0]               ; Get skip-table address
        mov   rcx, 32                   ; Initialize counter
srch1:  mov   [r9+rcx*8-8], rax         ; Fill 256 bytes with string length
        sub   rcx, 1
        jnz   srch1

        mov   rsi, [r14+8]              ; Get string address
        add   r14, 8                    ; Pop one item
        mov   rdx, [r14+8]              ; Get text buffer size
        mov   rdi, [r14+16]             ; Get text buffer address
        mov   qword[r14], 0             ; Initialize flag to zero

        mov   rcx, r8                   ; Copy pattern size
        sub   rcx, 1                    ; Make skip value index
        jz    srch6                     ; Branch if only 1 byte

; Build skip table for pattern.

        xor   rax, rax                  ; Clear byte register
        xor   rbx, rbx                  ; Clear index register
srch2:  mov   al, [rsi+rbx]             ; Get first/next string byte
        mov   [r9+rax], cl              ; Install skip value
        add   rbx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count/skip value
        jnz   srch2                     ; Loop

        lea   rcx, [r8-1]               ; Set index register
        xor   rbp, rbp                  ; Initialize skip register

; Get the text buffer byte corresponding to the last character
; of the pattern and save its skip value.

srch3:  mov   bpl, [rdi+rcx]            ; Get buffer byte
        mov   bpl, [r9+rbp]             ; Get skip value

        mov   rbx, r8                   ; Set pattern byte counter

srch4:  mov   al, [rdi+rbx-1]           ; Get first/next buffer byte
        cmp   al, [rsi+rbx-1]           ; Compare with string byte
        jnz   srch5                     ; Branch if no match

        sub   rbx, 1                    ; Decrement index
        jnz   srch4                     ; Loop

; If loop falls through, match is found

        jmp   srch9

srch5:  add   rdi, rbp                  ; Add skip to buffer address
        sub   rdx, rbp                  ; Subtract skip from buffer size
        jc    srch11                    ; No match, exit

        lea   rcx, [r8-1]               ; Reset counter
        jmp   srch3                     ; Loop

; If string length is 1, use simpler routine

srch6:  mov   al, [rsi]                 ; Get single string byte
        lea   rdi, [rdi+rdx]            ; Load end-of-buffer address
        neg   rdx                       ; Create negative pointer
srch7:  cmp   al, [rdi+rdx]
        jz    srch8
        add   rdx, 1
        jnz   srch7

; If loop falls through, character not found

        jmp   srch11

srch8:  lea   rdi, [rdi+rdx]            ; Load address of character
        neg   rdx                       ; Make offset positive

; Subtract pattern length from characters remaining, and if this is zero,
; set rdx to zero.

srch9:  sub   rdx, r8
        jnc   srch10

        xor   rdx, rdx

srch10: mov   qword[r14], -1            ; Return true flag
        mov   [r14+8], rdx              ; Return chars remaining
        mov   [r14+16], rdi             ; Return new buffer address
srch11: nextm
datam

stab0:
times 32 dq 0

; find" - ( c-addr1 --- c-addr2 u2 flag )
; Given the address of a buffer, search in the buffer for the string that follows
; in the input stream up to the next double quotation mark ("). If the string is
; found return its address in the buffer (c-addr2), the number of characters
; remaining in the buffer after the string (u2), and a true flag (-1).
; If the string is not found return the original buffer address and length,
; and a false flag (0).

head    'find"', hlfo
findq:  dq  docl0
        dq  dupl,eighm,qat,axbn,dbqt
        dq  dlmwrd,dupl,eighm,qat,srch
        dq  semis

; bar - output a vertical bar at the cursor position.

; : bar   124 emit ;

head    "bar", hlfo
bar:    dq  docl0,lit,124,emit,semis

; space - output a space at the cursor position.

; : space   bl emit ;

head    "space", hlfo
space:  dq  docl0,blsp,emit,semis

; spaces - ( n --- ) Output n spaces at the cursor postion.

; : spaces   pdchr @ >a bl pdchr ! padchrs a> pdchr ! ;

head    "spaces", hlfo
spaces: dq  docl0,pdchr,qat,toa
        dq  blsp,pdchr,stor
        dq  padcs,froma,pdchr,stor
        dq  semis

; type - ( addr cnt --- )

; : type   ?dup if over + swap do i c@ emit loop else drop then ;

head    "type", hlfo
typ:    dq  docl0,dupnz,izbrn,typ3
        dq  over,plus,swp,ddo,typ2
typ1:   dq  indx,cat,emit,_loop,typ1
typ2:   dq  ebran,typ4
typ3:   dq  drop
typ4:   dq  semis

; ascii>printable - determine whether a character is printable
; and if it is not, replace it with 0x2e - a dot. The default
; replacement character follows the code field.

head    "ascii>printable"
atprnt: dq  atpr0
        dq  0x2e
textm
atpr0:  mov   rdx, [r11+8]
        cmp   qword[r14], 0x21
        jc    atpr1
        cmp   qword[r14], 0x7f
        jc    atpr2
atpr1:  mov   [r14], rdx
atpr2:  nextm
datam

; count - ( addr --- addr+8 cnt )

head    "count"
count:  dq  cont0
textm
cont0:  mov   rdi, [r14]                ; Get string address
        mov   rcx, [rdi]                ; Get string length
        add   qword[r14], 8             ; Offset to string
        sub   r14, 8                    ; Push length
        mov   [r14], rcx
        nextm
datam

; Function to return the number of bytes occupied
; by a counted string

head    "strbytes"
strbyt: dq  sbyt0
textm
sbyt0:  mov   rdi, [r14]                ; Get string address
        mov   rcx, [rdi]                ; Get string length
        add   rcx, 8                    ; Add 8 for length cell
        mov   rbx, rcx                  ; Copy length
        and   rbx, 7                    ; Calculate offset past string
        jz    sbyt1                     ; No additional bytes
        neg   rbx
        add   rbx, 8
        add   rcx, rbx
sbyt1:  mov   [r14], rcx                ; Return byte offset past string
        nextm
datam

; .name - ( addr --- ) - Output the counted string at addr

; : .name   1 ckstk count ?strout space ;

head    ".name", hlfo
dtnam:  dq  docl0
        dq  one,ckstk
        dq  count,qstout,one,qspacs,semis

; .obtype - Given the OTA of a dictionary entry, output its object type.
; ( address --- )

; : .obtype   1 ckstk space 60 emit obtype@
;           findobj count strout 62 emit ;

head    ".obtype", hlfo
dtotyp: dq  docl0
        dq  one,ckstk
        dq  space,lit,60,emit
        dq  obtat,fndobj,count,strout
        dq  lit,62,emit,semis

; .ok - Output the 'ok' message

; : .ok   ." ok " ;

head    ".ok", hlfo
dtok:   dq  docl0
        pdtqm " ok "
        dq  semis

; >.stk - Show the contents of the stack in top-first order.

; : >.stk   cr ."  { " depth ?dup if 0 do i pick u. loop then ." }S" ;

head    ">.stk", hlfo
tdots:  dq  docl0
        dq  cr
        pdtqm " { "
        dq  depth,dupnz,izbrn,tdts2
        dq  zero,ddo,tdts2
tdts1:  dq  indx,pick,udot,_loop,tdts1
tdts2:  pdtqm "}S"
        dq  semis

; <.stk - Show the contents of the stack in bottom-first order.

; : <.stk   cr ."  S{ " depth ?dup if 1- 0 swap do i pick u. -1 +loop
;           then ." }" ;

head    "<.stk", hlfo
bdots:  dq  docl0
        dq  cr
        pdtqm " S{ "
        dq  depth,dupnz,izbrn,bdts2
        dq  onem,zero,swp,ddo,bdts2
bdts1:  dq  indx,pick,udot,mone,xploop,bdts1
bdts2:  pdtqm "}"
        dq  semis

; .stk - Display the contents of the stack in top-first or bottom-first
; order depending on how the vector is set.
; Note: This is a prototype for a 'toggle' - a word that contains two vectors,
; one of which is active. The phrase 'flip <word>' will make the inactive
; vector active and the active vector inactive. If the toggle is not
; initialized, an error message will be issued.

head    ".stk", tglo
dtstk:  dq  togl0
        dq  2,2
        dq  tdots
        dq  bdots

; >.astk - Show the contents of the auxiliary stack in top-first order.

; : >.astk   cr ."  { " depth ?dup if 0 do i apick u. loop then ." }A" ;

head    ">.astk", hlfo
tdota:  dq  docl0
        dq  cr
        pdtqm " { "
        dq  adepth,dupnz,izbrn,tdta2
        dq  zero,ddo,tdta2
tdta1:  dq  indx,apick,udot,_loop,tdta1
tdta2:  pdtqm "}A"
        dq  semis

; <.astk - Show the contents of the auxiliary stack in bottom-first order.

; : <.astk   cr ."  A{ " depth ?dup if 1- 0 swap do i apick u. -1 +loop
;           then ." }" ;

head    "<.astk", hlfo
bdota:  dq  docl0
        dq  cr
        pdtqm " A{ "
        dq  adepth,dupnz,izbrn,bdta2
        dq  onem,zero,swp,ddo,bdta2
bdta1:  dq  indx,apick,udot,mone,xploop,bdta1
bdta2:  pdtqm "}"
        dq  semis

; .astk - Display the contents of the auxiliary stack in top-first
; or bottom-first order depending on how the vector is set.
; If the toggle is not initialized, an error message will be issued.

head    ".astk", tglo
dtastk: dq  togl0
        dq  2,2
        dq  tdota
        dq  bdota

; .stks - Show the data stack display followed by
; the auxiliary stack display.

; : .stks   .stk .astk ;

head    ".stks", hlfo
dstks:  dq  docl0
        dq  dtstk,dtastk,semis

; okmsg - Set `msgout` to output 'ok' message on successful
; completion of interpret loop.

; : okmsg   1 punch msgout ;

head    "okmsg", hlfo
okmsg:  dq  docl0
        dq  one,lit,msgout,pnch,semis

; stkmsg - Set `msgout` to display data stack on successful
; completion of interpret loop.

; : stkmsg   2 punch msgout ;

head    "stkmsg", hlfo
stkmsg: dq  docl0
        dq  two,lit,msgout,pnch,semis

; stksmsg - Set `msgout` to display both the data stack
; and the auxilariy stack on successful completion
; of the interpret loop.

; : stksmsg   3 punch msgout ;

head    "stksmsg", hlfo
stksm:  dq  docl0
        dq  three,lit,msgout,pnch,semis

; nomsg - Set `msgout` to output no message.

; : nomsg   6 punch msgout ;

head    "nomsg", hlfo
nomsg:  dq  docl0
        dq  lit,6,lit,msgout,pnch,semis

; msgout - Message radio for successful completion of the interpret loop.
; For this radio, `noop` serves as a place-holder for entries not pre-compiled.

head    "msgout", rado
msgout: dq  radi0
        dq  7
        dq  dtok                        ; Default (`.ok`)
        dq  dtok                        ; `.ok`
        dq  dtstk                       ; `.stk`
        dq  dstks                       ; `.stks`
        dq  noop                        ; Reserved for `.fpstk`
        dq  noop                        ; Reserved for `.fpstks`
        dq  noop                        ; No output message
        dq  noop                        ; Available

; dump2 - ( addr n --- ) Dump n memory quadwords starting at addr in two
;       columns of quads and one column of ASCII translation.

; : dump2   cr 2 /mod swap >a ?dup
;           if
;               0 do dup hex.nlz space dup 2@ 2 0 do hex. loop
;               2 spaces dup 2@ 2 *.ascii 16 + cr loop
;               then
;           r>
;           if
;               dup hex.nlz space @ dup hex. 17 spaces 2 spaces .ascii cr
;           else drop then ;

head    "dump2", hlfo
dumpt:  dq  docl0
        dq  cr,two,slmod,swp,toa,dupnz,izbrn,dmpt4
        dq  zero,ddo,dmpt4
dmpt1:  dq  dupl,hxdnz,space,dupl,dqat,two
        dq  zero,ddo,dmpt3
dmpt2:  dq  hexdt,_loop,dmpt2
dmpt3:  dq  two,spaces,dupl,dqat,two
        dq  stdta,sixtp,cr,_loop,dmpt1
dmpt4:  dq  froma,izbrn,dmpt5
        dq  dupl,hxdnz,space,qat,dupl
        dq  hexdt,lit,17,spaces
        dq  two,spaces,dotasc
        dq  cr,bran,dmpt6
dmpt5:  dq  drop
dmpt6:  dq  semis

; dump4 - ( addr n --- ) Dump n memory quadwords starting at addr in four
;        columns of quads and one column of ASCII translation.

; : dump4   cr 4 /mod swap >a ?dup
;           if
;               0 do dup hex.nlz space dup 4@ 4 0 do hex. loop
;               2 spaces dup 4@ 4 *.ascii 32 + cr loop
;               then
;           a> ?dup
;           if
;               4 over - >a
;               over hex.nlz space >a dup a@ *@ a@ 0 do hex. loop
;               a> a> 0 do 17 spaces loop 2 spaces dup >a
;               *@ a> *.ascii cr
;               else drop then ;

head    "dump4", hlfo
dumpf:  dq  docl0
        dq  cr,four,slmod,swp,toa,dupnz,izbrn,dmpf4
        dq  zero,ddo,dmpf4
dmpf1:  dq  dupl,hxdnz,space,dupl,qqat,four
        dq  zero,ddo,dmpf3
dmpf2:  dq  hexdt,_loop,dmpf2
dmpf3:  dq  two,spaces,dupl,qqat,four
        dq  stdta,ttwp,cr,_loop,dmpf1
dmpf4:  dq  froma,dupnz,izbrn,dmpf9
        dq  four,over,minus,toa,over
        dq  hxdnz,space,toa,dupl,aat
        dq  strat,aat,zero,ddo,dmpf6
dmpf5:  dq  hexdt,_loop,dmpf5
dmpf6:  dq  froma,froma,zero,ddo,dmpf8
dmpf7:  dq  lit,17,spaces,_loop,dmpf7
dmpf8:  dq  two,spaces,dupl,toa
        dq  strat,froma,stdta
        dq  cr,bran,dmpf10
dmpf9:  dq  drop
dmpf10: dq  semis

; next-buffer - Get link to following buffer

head    "next-buffer"
nxtbuf: dq  nxtb0
textm
nxtb0:  mov  rdi, [r14]
        mov  rsi, [rdi-48]
        mov  [r14], rsi
        nextm
datam

; prev-buffer - Get link to previous buffer

head    "prev-buffer"
prvbuf: dq  prvb0
textm
prvb0:  mov  rdi, [r14]
        mov  rsi, [rdi-56]
        mov  [r14], rsi
        nextm
datam

; n>tib ( n --- addr ) Given the tib number return its address.
; If buffer number is not in bounds issue "buffer number out of bounds".

head    "n>tib"
ttib:   dq  ttib0
textm
ttib0:  mov   rcx, [r14]                ; Get buffer number
        cmp   rcx, 0                    ; See if zero
        jz    ttib1                     ; Throw error if so

        cmp   qword[ntib0], rcx         ; Compare with number of tibs
        jnc   ttib2                     ; Branch if in bounds

ttib1:  throwm 89

ttib2:  lea   rdi, [tib0]               ; Get addr of 1st buffer
ttib3:  sub   rcx, 1
        jz    ttib4
        mov   rdi, [rdi-48]             ; Chain through buffers for count
        jmp   ttib3
ttib4:  mov  [r14], rdi
        nextm
datam

; n>fib ( n --- addr ) Given the fib number return its address.
; If buffer number is not in bounds issue "buffer number out of bounds".

head    "n>fib"
tfib:   dq  tfib0
textm
tfib0:  mov   rcx, [r14]                ; Get buffer number
        cmp   rcx, 0                    ; See if zero
        jz    tfib1                     ; Throw error if so

        cmp   qword[nfib0], rcx         ; Compare with number of tibs
        jnc   tfib2                     ; Branch if in bounds

tfib1:  throwm 89

tfib2:  lea   rdi, [fib0]               ; Get addr of 1st buffer
tfib3:  sub   rcx, 1
        jz    tfib4
        mov   rdi, [rdi-48]             ; Chain through buffers for count
        jmp   tfib3
tfib4:  mov  [r14], rdi
        nextm
datam

; show-tibs ( --- ) List terminal input buffers with addresses in hex,
; buffer numbers in decimal, and 1st 40 bytes of contents in ASCII.

; : show-tibs   tib0 dup ntibs @ 0 do
;                 dup cr 8 .rhex space 24- 8@ slip 2 .rdec
;                 7 .rdec 5 *.ascii next-buffer dup
;               loop 2drop ;

head    "show-tibs", hlfo
shtbs:  dq  docl0
        dq  tibn,dupl,ntib,qat,zero,ddo,shtbs2
shtbs1: dq  dupl,cr,eight,dtrhx,space,twfm,oqat
        dq  slip,two,dtrdc,lit,7,dtrdc,lit,5
        dq  stdta,nxtbuf,dupl,_loop,shtbs1
shtbs2: dq  ddrop,space,semis

; show-fibs ( --- ) List file input buffers with addresses in hex,
; buffer numbers in decimal, and 1st 40 bytes of contents in ASCII.

; : show-fibs   fib0 dup nfibs @ 0 do
;                 dup cr 8 .rhex space 24- 8@ slip 2 .rdec
;                 7 .rdec 5 *.ascii next-buffer dup
;               loop 2drop ;

head    "show-fibs", hlfo
shfbs:  dq  docl0
        dq  fibn,dupl,nfib,qat,zero,ddo,shfbs2
shfbs1: dq  dupl,cr,eight,dtrhx,space,twfm,oqat
        dq  slip,two,dtrdc,lit,7,dtrdc,lit,5
        dq  stdta,nxtbuf,dupl,_loop,shfbs1
shfbs2: dq  ddrop,space,semis

; depth - Return the number of items on the stack.

head    "depth", stko
depth:  dq  dpth0
textm
dpth0:  lea   rdi, [dstack0]
        sub   rdi, r14
        shr   rdi, 3
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; adepth - Return the number of 64-bit items on the auxiliary stack
; to the data stack.

head    "adepth", stko
adepth: dq  adpt0
textm
adpt0:  lea   rdi, [astack0]
        sub   rdi, r13
        shr   rdi, 3
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; status

; : status   cr base @ ." base=" .dec space qsz@ ." qsz=" .dec space
;            rdigs @ ." rdigs=" .dec space depth ." depth=" .dec 
;            space adepth ." adepth=" .dec ;

head    "status", hlfo
stats:  dq  docl0
        dq  cr,base,qat
        pdtqm "base="
        dq  dtdec,space
        dq  qszat
        pdtqm "qsz="
        dq  dtdec,space
        dq  rdigs,qat
        pdtqm "rdigs="
        dq  dtdec,space
        dq  depth
        pdtqm "depth="
        dq  dtdec,space
        dq  adepth
        pdtqm "adepth="
        dq  dtdec,semis

; owords - List the dictionary by traversing from object to object by length
;         starting with the first defined word. This is mainly a test
;         of the integrity of the dictionary.

; : owords   forth-wordlist first-object-link-field cr
;            begin 16 + dup 16 + .name space dup @ + dup here = until 2drop ;

head    "owords", hlfo
owords: dq  docl0
        dq  lit,vlink1,fobjl,cr
oword1: dq  sixtp,dupl,sixtp,dtnam
        dq  one,qspacs,dupl,qat,plus,dupl,here,equal
        dq  uzbrn,oword1,ddrop,semis

; vocs - List defined vocabularies

; : vocs   cr voc-link @ begin dup 8- >name .name space @ dup 0= until drop ;

head    "vocs", hlfo
vocs:   dq  docl0
        dq  cr,voclnk,qat
vocs1:  dq  dupl,eighm,cftnf,dtnam,space
        dq  qat,dupl,zequ,uzbrn,vocs1
        dq  drop,semis

; files - List file structures

; : files   cr file-link @ begin dup 8- >name .name space @ dup 0= until
;           drop ;

head    "files", hlfo
fils:   dq  docl0
        dq  cr,flnk,qat
fils1:  dq  dupl,eighm,cftnf,dtnam,space
        dq  qat,dupl,zequ,uzbrn,fils1
        dq  drop,semis

; paths - List file structure names and paths

; : paths   file-link @ begin cr dup dup 8- >name ." filename: " .name
;                       2 spaces 64 + ." path: " .name @ dup
;                    0= until drop ;

head    "paths", hlfo
pths:   dq  docl0
        dq  flnk,qat
pths1:  dq  cr,dupl,dupl,eighm,cftnf
        pdtqm "filename: "
        dq  dtnam,two,spaces,sxtfp
        pdtqm "path: "
        dq  dtnam
        dq  qat,dupl,zequ,uzbrn,pths1
        dq  drop,semis

; c,

head    "c,", cmpo
ccomm:  dq  ccom0
textm
ccom0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rcx, [r14]                ; Get stack item
        add   r14, 8                    ; Pop stack
        mov   [rdi], cl                 ; Store at dsp location
        add   qword[dspo0], 1           ; Advance dsp
        nextm
datam

; w,

head    "w,", cmpo
wcomm:  dq  wcom0
textm
wcom0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rcx, [r14]                ; Get stack item
        add   r14, 8                    ; Pop stack
        mov   word[rdi], cx             ; Store at dsp location
        add   qword[dspo0], 2           ; Advance dsp
        nextm
datam

; dw,

head    "dw,", cmpo
dwcom:  dq  dwcm0
textm
dwcm0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rcx, [r14]                ; Get stack item
        add   r14, 8                    ; Pop stack
        mov   dword[rdi], ecx           ; Store at dsp location
        add   qword[dspo0], 4           ; Advance dsp
        nextm
datam

; c@ - Fetch a byte and zero-extend it to a quad on the stack.

head    "c@", memo
cat:    dq  chat0
textm
chat0:  mov   rdi, [r14]
        movzx rcx, byte[rdi]
        mov   [r14], rcx
        nextm
datam

; c! - Store a byte at the given address.

head    "c!", memo
cstor:  dq  csto0
textm
csto0:  mov   rdi, [r14]
        mov   rdx, [r14+8]
        mov   [rdi], dl
        add   r14, 16
        nextm
datam

; b@ - Fetch a byte and sign-extend it to a quad on the stack.

head    "b@", memo
bat:    dq  btat0
textm
btat0:  mov   rdi, [r14]
        movsx rcx, byte[rdi]
        mov   [r14], rcx
        nextm
datam

; b! - Store a byte at the given address. Same as c!?

head    "b!", memo
bstor:  dq  bsto0
textm
bsto0:  mov   rdi, [r14]
        mov   rdx, [r14+8]
        mov   [rdi], dl
        add   r14, 16
        nextm
datam

; uw@ - Fetch a word and zero-extend it to a quad on the stack.

head    "uw@", memo
uwat:   dq  uwat0
textm
uwat0:  mov   rdi, [r14]
        movzx rcx, word[rdi]
        mov   [r14], rcx
        nextm
datam

; w@ - Fetch a word and sign-extend it to a quad on the stack.

head    "w@", memo
wat:    dq  woat0
textm
woat0:  mov   rdi, [r14]
        movsx rcx, word[rdi]
        mov   [r14], rcx
        nextm
datam

; w! - Store a word at the given address.

head    "w!", memo
wstor:  dq  wsto0
textm
wsto0:  mov   rdi, [r14]
        mov   rdx, [r14]
        mov   [rdi], dx
        add   r14, 16
        nextm
datam

; udw@ - Fetch a double word and zero-extend it to a quad on the stack.
; Note that a 32-bit move into a register is automatically zero-extended
; to 64 bits.

head    "udw@", memo
udwat:  dq  udwa0
textm
udwa0:  mov   rdi, [r14]
        mov   ecx, [rdi]
        mov   [r14], rcx
        nextm
datam

; dw@ - Fetch a double word and sign-extend it to a quad on the stack.

head    "dw@", memo
dwat:   dq  dwat0
textm
dwat0:  mov   rdi, [r14]
        movsxd rcx, dword[rdi]
        mov   [r14], rcx
        nextm
datam

; dw! - Store a double word at the given address.

head    "dw!", memo
dwstor: dq  dwst0
textm
dwst0:  mov   rdi, [r14]
        mov   rdx, [r14+8]
        mov   [r14], edx
        add   r14, 16
        nextm
datam

; wswap - Swap the dwords in a stack entry

head    "wswap", stko
wswap:  dq  wswp0
textm
wswp0:  mov   rdx, [r14]
        rol   rdx, 32
        mov   [r14], rdx
        nextm
datam

; ,

head    ",", cmpo
comma:  dq  comm0
textm
comm0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rcx, [r14]                ; Get stack item
        add   r14, 8                    ; Pop stack
        mov   [rdi], rcx                ; Store at dsp location
        add   qword[dspo0], 8           ; Advance dsp
        nextm
datam

; literal - compile a literal

head    "literal", -hlfo
lite:   dq  docl0
        dq  pcomp,lit,comma,semis
lit:    dq  lite0
textm
lite0:  mov   rax, [r12]                ; Get in-line value
        add   r12, 8                    ; Advance IP past value
        sub   r14, 8                    ; Push value to stack
        mov   [r14], rax
        nextm
datam

; constant

head    "constant", hlfo
cons:   dq  docl0
        dq  one,ckstk
        dq  dfine,lit,cnso,objcom,pcomm,cons0
        dq  comma,oszcom,semis
textm
cons0:  mov   rdx, [r11+8]              ; Get in-line value
        sub   r14, 8                    ; Push it to stack
        mov   [r14], rdx
        nextm
datam

; value

head    "value", hlfo
valu:   dq  docl0
        dq  one,ckstk
        dq  dfine,lit,valo,objcom,pcomm,valu0
        dq  comma,oszcom,semis
textm
valu0:  mov   rdx, [r11+8]              ; Get in-line value
        sub   r14, 8                    ; Push it to stack
        mov   [r14], rdx
        nextm
datam

; to - ( xt --- ) Set a value. Throw error is object is not a value
; or if there is nothing on the stack.

head    "to", hlfo
toval:  dq  docl0
        dq  one,ckstk
        dq  tick,dupl,cftota,obtat
        dq  lit,valo,ntequ,zbran,tovl1
        dq  lit,67,throw
tovl1:  dq  eighp,stor
        dq  semis

; variable

head    "variable", hlfo
var:    dq  docl0
        dq  dfine,lit,varo,objcom,pcomm,vari0
        dq  zero,comma,oszcom,semis
textm
vari0:  lea   rdx, [r11+8]              ; Get in-line address of variable
        sub   r14, 8                    ; Push it to stack
        mov   [r14], rdx
        nextm
datam

; conarr - Create a constant array of n 64-bit elements. ( n --- ).
; Arrays are 1-based. Passed an element number from 1 to the maximum, returns
; the element to the stack. Throws an error if the index is out of bounds.
; If passed a negative number or zero, returns the array base address and the
; number of elements it contains.
;
; Array structure (header not shown):

; | code field | number of elements | elements ... |

head    "conarr", hlfo
cnar:   dq  docl0
        dq  dupl,onep,ckstk
        dq  dfine,lit,cnao,objcom,pcomm,cnar0
        dq  strcom,oszcom,semis
textm
cnar0:  mov   rax, [r14]                ; Get array index
        cmp   rax, 0
        jg    cnar1                     ; Branch if not zero or below

        lea   rdi, [r11+16]             ; Get array base address
        mov   [r14], rdi                ; Return to stack
        mov   rax, [r11+8]              ; Get number of elements
        sub   r14, 8
        mov   [r14], rax                ; Push to stack
        jmp   cnar3                     ; Branch to exit

cnar1:  cmp   [r11+8], rax              ; See if index is in bounds
        jnc   cnar2                     ; Branch if so

        throwm 14                       ; Else throw index out of bounds

cnar2:  sub   rax, 1                    ; Arrays are 1-based
        shl   rax, 3                    ; Multiply by eight
        mov   rbx, [r11+rax+16]         ; Get element
        mov   [r14], rbx                ; Return element
cnar3:  nextm
datam

; array - Create an array of n 64-bit elements. ( n --- ).
; Arrays are 1-based. Passed an element number from 1 to the maximum, returns the
; the address of that element. Throws an error if the index is out of bounds.
; If passed a negative number or zero, returns the array base address and the number
; of elements it contains.
;
; Array structure (header not shown):

; | code field | number of elements | elements ... |

head    "array", hlfo
arra:   dq  docl0
        dq  one,ckstk
        dq  dfine,lit,arro,objcom,pcomm,arra0
        dq  dupl,comma,here,over,estar,allot
        dq  swp,zero,qfill,oszcom,semis
textm
arra0:  mov   rax, [r14]                ; Get array index
        cmp   rax, 0
        jg    arra1                     ; Branch if not zero or below

        lea   rdi, [r11+16]             ; Get array base address
        mov   [r14], rdi                ; Return to stack
        mov   rax, [r11+8]              ; Get number of elements
        sub   r14, 8
        mov   [r14], rax                ; Push to stack
        jmp   arra3                     ; Branch to exit

arra1:  cmp   [r11+8], rax              ; See if index is in bounds
        jnc   arra2                     ; Branch if so

        throwm 14                       ; Else throw index out of bounds

arra2:  sub   rax, 1                    ; Arrays are 1-based
        shl   rax, 3                    ; Multiply by eight
        lea   rdi, [r11+rax+16]         ; Load address of element
        mov   [r14], rdi                ; Return address of element
arra3:  nextm
datam

; @

head    "@", memo
qat:    dq    quat0
textm
quat0:  mov   rdi, [r14]
        mov   rcx, [rdi]
        mov   [r14], rcx
        nextm
datam

; !

head    "!", memo
stor:   dq  stor0
textm
stor0:  mov   rdi, [r14]
        mov   rdx, [r14+8]
        mov   [rdi], rdx
        add   r14, 16
        nextm
datam

; +!

head    "+!", memo
plstor: dq  plst0
textm
plst0:  mov   rdi, [r14]
        mov   rdx, [r14+8]
        add   [rdi], rdx
        add   r14, 16
        nextm
datam

; >r - ( S: s --- ) ( R: --- s ) Pop data stack item and push it
; to the return stack.

head    ">r", stko
tor:    dq  tors0
textm
tors0:  mov   rdx, [r14]
        add   r14, 8
        sub   r15, 8
        mov   [r15], rdx
        nextm
datam

; r> - ( S: --- s ) ( R: s --- ) Pop return stack item and push it
; to the data stack.

head    "r>", stko
fromr:  dq  frmr0
textm
frmr0:  mov   rdx, [r15]
        add   r15, 8
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; r! - ( S: s --- s ) ( R: --- s ) Copy top data stack item to return stack.

head    "r!", stko
rsto:   dq  rsto0
textm
rsto0:  mov   rdx, [r14]
        sub   r15, 8
        mov   [r15], rdx
        nextm
datam

; r@ - ( S: --- s ) ( R: x --- s ) Copy top return stack item to data stack.

head    "r@", stko
rat:    dq  rsat0
textm
rsat0:  mov   rdx, [r15]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; >a - ( S: s --- ) ( A: --- s ) Pop data stack item and push it
; to the auxiliary stack.

head    ">a", stko
toa:    dq  toas0
textm
toas0:  mov   rdx, [r14]
        add   r14, 8
        sub   r13, 8
        mov   [r13], rdx
        nextm
datam

; a> - ( S: --- s ) ( A: s --- ) Pop auxiliary stack item and push it
; to the data stack.

head    "a>", stko
froma:  dq  frma0
textm
frma0:  mov   rdx, [r13]
        add   r13, 8
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; a! - ( S: s --- s ) ( A: --- s ) Copy top data stack item to auxiliary stack.

head    "a!", stko
asto:   dq  asto0
textm
asto0:  mov   rdx, [r14]
        sub   r13, 8
        mov   [r13], rdx
        nextm
datam

; a@ - ( S: --- s ) ( A: s --- s ) Copy top auxiliary stack item to data stack.

head    "a@", stko
aat:    dq  asat0
textm
asat0:  mov   rdx, [r13]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; adrop - ( A: s --- ) Discard the top single-quad item from the auxiliary
; stack.

head    "adrop", stko
adrop:  dq  adrp0
textm
adrp0:  add   r13, 8
        nextm
datam

; apick - ( n --- s[An] ) Copy the nth single-quad item from the auxiliary
; stack to the data stack. Zero based. Note that, like the standard `pick`,
; this operator does not check to see if the nth item exists.

head    "apick", stko
apick:  dq  apck0
textm
apck0:  mov   rdx, [r14]
        mov   rcx, [r13+rdx*8]
        mov   [r14], rcx
        nextm
datam

; axch - ( S: s[S0] n --- s[An] ) ( A: s[n+1] s[n] s[n-1] ... s[0] --- 
; s[n+1] s[S0] s[n-1] ... s[0] ) Swap the top single-quad stack entry
; with the auxiliary stack entry whose number is passed on the stack.
; Zero based.

head    "axch", stko
axch:   dq  axch0
textm
axch0:  mov   rdx, [r14]
        add   r14, 8
        mov   rcx, [r14]
        mov   rbx, [r13+rdx*8]
        mov   [r14], rbx
        mov   [r13+rdx*8], rcx
        nextm
datam

; areplace - ( S: s[S0] n --- ) ( A: s[n+1] s[n] s[n-1] ... s[0] --- 
; s[n+1] s[S0] s[n-1] ... s[0] )  Replace the nth single-quad auxiliary
; stack item with the single-quad item on top of the data stack.
; Zero based.

head    "areplace", stko
arepl:  dq  arpl0
textm
arpl0:  mov   rdx, [r14]
        mov   rcx, [r14+8]
        add   r14, 16
        mov   [r13+rdx*8], rcx
        nextm
datam

; drop - ( s --- )

head    "drop", stko
drop:   dq  drop0
textm
drop0:  add   r14, 8
        nextm
datam

; dup - ( s --- s s )

head    "dup", stko
dupl:   dq  dupl0
textm
dupl0:  mov   rdx, [r14]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; ?dup - ( s --- 0 | s s )

head    "?dup", stko
dupnz:  dq  dpnz0
textm
dpnz0:  mov   rdx, [r14]
        test  rdx, rdx
        jz    dpnz1

        sub   r14,8
        mov   [r14], rdx
dpnz1:  nextm
datam

; swap - ( s1 s2 --- s2 s1 )

head    "swap", stko
swp:    dq  swap0
textm
swap0:  mov   rdx, [r14]
        mov   rcx, [r14+8]
        mov   [r14+8], rdx
        mov   [r14], rcx
        nextm
datam

; over - ( s1 s2 --- s1 s2 s1 )

head    "over", stko
over:   dq  over0
textm
over0:  mov   rdx, [r14+8]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; tuck - ( s1 s2 --- s2 s1 s2 )

head    "tuck", stko
tuck:   dq  tuck0
textm
tuck0:  mov   rdx, [r14]
        mov   rcx, [r14+8]
        sub   r14, 8
        mov   [r14], rdx
        mov   [r14+8], rcx
        mov   [r14+16], rdx
        nextm
datam

; rot - ( s1 s2 s3 --- s2 s3 s1 )

head    "rot", stko
rot:    dq  rota0
textm
rota0:  mov   rax, [r14]                ; Get 1st entry
        mov   rbx, [r14+8]              ; Get 2nd entry
        mov   rcx, [r14+16]             ; Get 3rd entry
        mov   [r14], rcx                ; Replace 1st with 3rd
        mov   [r14+8], rax              ; Replace 2nd with 1st
        mov   [r14+16], rbx             ; Replace 3rd with 2nd
        nextm
datam

; brot - ( s1 s2 s3 --- s3 s1 s2 ) "back rote", reverse rot

head    "brot", stko
brot:   dq  brot0
textm
brot0:  mov   rax, [r14]                ; Get 1st entry
        mov   rbx, [r14+8]              ; Get 2nd entry
        mov   rcx, [r14+16]             ; Get 3rd entry
        mov   [r14], rbx                ; Replace 1st with 2nd
        mov   [r14+8], rcx              ; Replace 2nd with 3rd
        mov   [r14+16], rax             ; Replace 3rd with 1st
        nextm
datam

; slip - ( s1 s2 --- s2 )

head    "slip", stko
slip:   dq  slip0
textm
slip0:  mov   rdx, [r14]
        add   r14, 8
        mov   [r14], rdx
        nextm
datam

; nip - ANSI Standard synonym for slip.

head    "nip", stko
nip:    dq  snip0
textm
snip0:  mov   rdx, [r14]
        add   r14, 8
        mov   [r14], rdx
        nextm
datam

; slide - ( s1 s2 s3 --- s2 s3 )

head    "slide", stko
slide:  dq  slid0
textm
slid0:  mov   rdx, [r14]
        mov   rcx, [r14+8]
        add   r14, 8
        mov   [r14+8], rcx
        mov   [r14], rdx
        nextm
datam

; pick - ( s[n+1] s[n] s[n-1] ... s[0] n --- s[n+1] s[n] s[n-1] ... s[0] s[n] )
; Copy the nth single-quad to the top. Zero based.

head    "pick", stko
pick:   dq  pick0
textm
pick0:  mov   rdx, [r14]
        mov   rcx, [r14+rdx*8+8]
        mov   [r14], rcx
        nextm
datam

; xch - ( s[n+1] s[n] s[n-1] ... s[0] n --- s[n+1] s[0] s[n-1] ... s[n] )
; Swap the nth single-quad with the top entry. 0 xch does nothing, 1 xch
; is the same as swap. Zero based.

head    "xch", stko
xch:    dq  exch0
textm
exch0:  mov   rdx, [r14]
        add   r14, 8
        mov   rcx, [r14]
        mov   rbx, [r14+rdx*8]
        mov   [r14], rbx
        mov   [r14+rdx*8], rcx
        nextm
datam

; replace - ( s[n+1] s[n] s[n-1] ... s[0] s n --- s[n+1] s s[n-1] ... s[0] )
; Replace the nth stack item with the new top entry. Zero based.

head    "replace", stko
replc:  dq  rplc0
textm
rplc0:  mov   rdx, [r14]
        mov   rcx, [r14+8]
        add   r14, 16
        mov   [r14+rdx*8], rcx
        nextm
datam

; pluck - ( s[n+1] s[n] s[n-1] ... s[0] n --- s[n+1] s[n-1] ... s[0] s[n] )
; Extract the nth single-quad to the top of the stack and close the resulting gap.
; Do nothing if argument is zero or negative.

head    "pluck", stko
pluck:  dq plck0
textm
plck0:  mov   rdx, [r14]
        add   r14, 8
        cmp   rdx, 0
        jle   plck2

        mov   rbx, [r14+rdx*8]
plck1:  mov   rax, [r14+rdx*8-8]
        mov   [r14+rdx*8], rax
        sub   rdx, 1
        jnz   plck1

        mov   [r14], rbx
plck2:  nextm
datam

; poke - ( s[n+1] s[n] s[n-1] ... s[0] s n --- s[n+1] s[n] s s[n-1] ... s[0] )
; Make s the nth single-quad on the stack by moving the previous n-1 items up
; one position and then inserting s in the resulting gap. Do nothing if argument
; is zero or negative.

head    "poke", stko
poke:   dq  poke0
textm
poke0:  mov   rcx, [r14]                ; Get stack position
        add   r14, 8                    ; Pop stack
        cmp   rcx, 0                    ; Leave item on stack
        jz    poke2                     ; if offset is zero

        mov   rdx, [r14]                ; Get item to insert
        mov   rsi, r14                  ; Copy stack pointer
poke1:  mov   rax, [rsi+8]              ; Move quads one cell up
        mov   [rsi], rax
        add   rsi, 8
        sub   rcx, 1
        jnz   poke1

        mov   [rsi], rdx                ; Install item in nth position
poke2:  nextm
datam

; roll - ( s[n+1] s[n] s[n-1] ... s[0] n --- s[n+1 s[n-1] ... s[0] s[n] )
; Extract the nth stack item to the top and close the resulting gap.
; Do nothing if argument is zero or negative.
; ANSI Standard synonym for `pluck`.

head    "roll", stko
roll:   dq roll0
textm
roll0:  mov   rdx, [r14]
        add   r14, 8
        cmp   rdx, 0
        jle   roll2

        mov   rbx, [r14+rdx*8]
roll1:  mov   rax, [r14+rdx*8-8]
        mov   [r14+rdx*8], rax
        sub   rdx, 1
        jnz   roll1

        mov   [r14], rbx
roll2:  nextm
datam

; reverse-endian - switch the endianess of the top stack item.

head    "reverse-endian", lgco
rvsndn: dq  rvnd0
textm
rvnd0:  mov   rdx, [r14]
        bswap rdx
        mov   [r14], rdx
        nextm
datam

; Logic Functions

; true - Return true flag - -1

head    "true", lgco
true:   dq  true0
textm
true0:  sub   r14, 8
        mov   qword[r14], -1
        nextm
datam

; false - Return false flag - 0

head    "false", lgco
false:  dq  fals0
textm
fals0:  sub   r14, 8
        mov   qword[r14], 0
        nextm
datam

; Since the names of logic operators tend to be the same as
; machine instructions, their labels in Forthx64 have the 'f'
; appended.

; not - Change the flag on the stack to true if it is false, or
;      to false if it is true.

head    "not", lgco
notf:   dq  notf0
textm
notf0:  cmp   qword[r14], 0
        jnz   notf1
        mov   qword[r14], -1
        jmp   notf2
notf1:  mov   qword[r14], 0
notf2:  nextm
datam

; invert

head    "invert", lgco
invrt:  dq  invt0
textm
invt0:  not   qword[r14]
        nextm
datam

; and

head    "and", lgco
andf:   dq  andf0
textm
andf0:  mov   rdx, [r14]
        add   r14, 8
        and   [r14], rdx
        nextm
datam

; or

head    "or", lgco
orf:    dq  orfo0
textm
orfo0:  mov   rdx, [r14]
        add   r14, 8
        or    [r14], rdx
        nextm
datam

; xor

head    "xor", lgco
xorf:   dq  xorf0
textm
xorf0:  mov   rdx, [r14]
        add   r14, 8
        xor   [r14], rdx
        nextm
datam

; Bitwise operators

; lsl - Logical shift left - 64-bit stack cell

head    "lsl", lgco
lslf:   dq  lslf0
textm
lslf0:  mov  rcx, [r14]                 ; Get shift count
        add  r14, 8                     ; Pop count
        shl  qword[r14], cl             ; Shift stack entry by count
        nextm
datam

; lshift - ANSI Standard synonym for lsl - 64-bit stack cell
; Same code as previous word.

head    "lshift", lgco
lshft:  dq  lshf0
textm
lshf0:  mov  rcx, [r14]                 ; Get shift count
        add  r14, 8                     ; Pop count
        shl  qword[r14], cl             ; Shift stack entry by count
        nextm
datam

; lsr - Logical shift right - 64-bit stack cell

head    "lsr", lgco
lsrf:   dq  lsrf0
textm
lsrf0:  mov  rcx, [r14]                 ; Get shift count
        add  r14, 8                     ; Pop count
        shr  qword[r14], cl             ; Shift stack entry by count
        nextm
datam

; rshift - ANSI Standard synonym for lsr - 64-bit stack cell
; Same code as previous word.

head    "rshift", lgco
rshft:  dq  rshf0
textm
rshf0:  mov  rcx, [r14]                 ; Get shift count
        add  r14, 8                     ; Pop count
        sar  qword[r14], cl             ; Shift stack entry by count
        nextm
datam

; asr - Arithmetic shift right - 64-bit stack cell

head    "asr", lgco
asrf:   dq  asrf0
textm
asrf0:  mov  rcx, [r14]                 ; Get shift count
        add  r14, 8                     ; Pop count
        sar  qword[r14], cl             ; Shift stack entry by count
        nextm
datam

; rol - Rotate left up to 63 bits

head    "rol", lgco
rolf:   dq  rolf0
textm
rolf0:  mov  rcx, [r14]                 ; Get shift count
        add  r14, 8                     ; Pop count
        rol  qword[r14], cl             ; Shift stack entry by count
        nextm
datam

; ror - Rotate right up to 63 bits

head    "ror", lgco
rorf:   dq  rorf0
textm
rorf0:  mov  rcx, [r14]                 ; Get shift count
        add  r14, 8                     ; Pop count
        ror  qword[r14], cl             ; Shift stack entry by count
        nextm
datam

; flsb - Find leading set bit. Returns bit# 0-63 or -1 if no bits are set.

head    "flsb", lgco
flsb:   dq  flsb0
textm
flsb0:  bsr   rdx, [r14]                ; Scan for leading set bit
        jnz   flsb1                     ; Jump if bit found

        not   rdx                       ; Return -1

flsb1:  sub   r14, 8                    ; Push bit location
        mov   [r14], rdx
        nextm
datam

; ftsb - Find trailing set bit. Returns bit# 0-63 or -1 if no bits are set.

head    "ftsb", lgco
ftsb:   dq  ftsb0
textm
ftsb0:  bsf   rdx, [r14]                ; Scan for trailing set bit
        jnz   flsb1                     ; Jump if bit found

        not   rdx                       ; Return -1

ftsb1:  sub   r14, 8                    ; Push bit location
        mov   [r14], rdx
        nextm
datam

; normlz - Normalize stack quad.

head    "normlz", lgco
normlz: dq  nmlz0
textm
nmlz0:  bsr   rcx, [r14]                ; Scan for leading set bit
        jz    nmlz1                     ; Do nothing if zero

        sub   rcx, 63
        neg   rcx
        shl   qword[r14], cl            ; Shift operand   
nmlz1:  nextm
datam

; Integer arithmetic operators

; 1+

head    "1+", ario
onep:   dq  onep0
textm
onep0:  add   qword[r14], 1
        nextm
datam

; 2+

head    "2+", ario
twop:   dq  twop0
textm
twop0:  add   qword[r14], 2
        nextm
datam

; 4+

head    "4+", ario
fourp:  dq  forp0
textm
forp0:  add   qword[r14], 4
        nextm
datam

; 8+

head    "8+", ario
eighp:  dq  eigp0
textm
eigp0:  add   qword[r14], 8
        nextm
datam

; 16+

head    "16+", ario
sixtp:  dq  sxtp0
textm
sxtp0:  add   qword[r14], 16
        nextm
datam

; 24+

head    "24+", ario
twfp:   dq  twfp0
textm
twfp0:  add   qword[r14], 24
        nextm
datam

; 32+

head    "32+", ario
ttwp:   dq  ttwp0
textm
ttwp0:  add   qword[r14], 32
        nextm
datam

; 64+

head    "64+", ario
sxtfp:  dq  sxfp0
textm
sxfp0:  add   qword[r14], 64
        nextm
datam

; 1-

head    "1-", ario
onem:   dq  onem0
textm
onem0:  sub   qword[r14], 1
        nextm
datam

; 2-

head    "2-", ario
twom:   dq  twom0
textm
twom0:  sub   qword[r14], 2
        nextm
datam

; 4-
head    "4-", ario
form:   dq  form0
textm
form0:  sub   qword[r14], 4
        nextm
datam

; 8-

head    "8-", ario
eighm:  dq  eigm0
textm
eigm0:  sub   qword[r14], 8
        nextm
datam

; 16-

head    "16-", ario
sixtm:  dq  sxtm0
textm
sxtm0:  sub   qword[r14], 16
        nextm
datam

; 24-

head    "24-", ario
twfm:   dq  twfm0
textm
twfm0:  sub   qword[r14], 24
        nextm
datam

; 32-

head    "32-", ario
ttwm:   dq  ttwm0
textm
ttwm0:  sub   qword[r14], 32
        nextm
datam

; 64-

head    "64-", ario
sxtfm:  dq  sxfm0
textm
sxfm0:  sub   qword[r14], 64
        nextm
datam

; 2*

head    "2*", ario
tstar:  dq  twst0
textm
twst0:  shl   qword[r14], 1
        nextm
datam

; 4*

head    "4*", ario
fstar:  dq  fost0
textm
fost0:  shl   qword[r14], 2
        nextm
datam

; 8*

head    "8*", ario
estar:  dq  eist0
textm
eist0:  shl   qword[r14], 3
        nextm
datam

; 16*

head    "16*", ario
sxtst:  dq  stst0
textm
stst0:  shl   qword[r14], 4
        nextm
datam

; 32*

head    "32*", ario
thtst:  dq  ttst0
textm
ttst0:  shl   qword[r14], 5
        nextm
datam

; 64*

head    "64*", ario
sfstr:  dq  sfst0
textm
sfst0:  shl   qword[r14], 6
        nextm
datam

; 2/

head    "2/", ario
tslsh:  dq  twsl0
textm
twsl0:  bt    qword[r14], 63
        jnc   twsl1

        mov   rax, [r14]
        neg   rax
        sar   rax, 1
        neg   rax
        mov   [r14], rax
        jmp   twsl2

twsl1:  sar   qword[r14], 1

twsl2:  nextm
datam

; uq/2rem ( uq --- uq/2 rem) Special operator for dividing an unsigned
; integer by two and returning the remainder - 0 or 1.

head    "uq/2rem", ario
utsm:   dq  utsm0
textm
utsm0:  bt    qword[r14], 63
        jnc   utsm1

        throwm 117

utsm1:  xor   rdx, rdx
        sar   qword[r14], 1
        jnc   utsm2

        mov   rdx, 1
        
utsm2:  sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; 4/

head    "4/", ario
fslsh:  dq  fosl0
textm
fosl0:  bt    qword[r14], 63
        jnc   fosl1

        mov   rax, [r14]
        neg   rax
        sar   rax, 2
        neg   rax
        mov   [r14], rax
        jmp   fosl2

fosl1:  sar   qword[r14], 2

fosl2:  nextm
datam

; 8/

head    "8/", ario
eslsh:  dq  eisl0
textm
eisl0:  bt    qword[r14], 63
        jnc   eisl1

        mov   rax, [r14]
        neg   rax
        sar   rax, 3
        neg   rax
        mov   [r14], rax
        jmp   eisl2

eisl1:  sar   qword[r14], 3

eisl2:  nextm
datam

; 16/

head    "16/", ario
sxtsl:  dq  stsl0
textm
stsl0:  bt    qword[r14], 63
        jnc   stsl1

        mov   rax, [r14]
        neg   rax
        sar   rax, 4
        neg   rax
        mov   [r14], rax
        jmp   stsl2

stsl1:  sar   qword[r14], 4

stsl2:  nextm
datam

; 32/

head    "32/", ario
thtsl:  dq  ttsl0
textm
ttsl0:  bt    qword[r14], 63
        jnc   ttsl1

        mov   rax, [r14]
        neg   rax
        sar   rax, 5
        neg   rax
        mov   [r14], rax
        jmp   ttsl2

ttsl1:  sar   qword[r14], 5

ttsl2:  nextm
datam

; 64/

head    "64/", ario
sfsls:  dq  sfsl0
textm
sfsl0:  bt    qword[r14], 63
        jnc   sfsl1

        mov   rax, [r14]
        neg   rax
        sar   rax, 6
        neg   rax
        mov   [r14], rax
        jmp   sfsl2

sfsl1:  sar   qword[r14], 6

sfsl2:  nextm
datam

; rnd<8 - Round stack number to the next lower multiple of eight.
; Do nothing if number is already a multiple of eight.

head    "rnd<8", ario
rdte:   dq  rdte0
textm
rdte0:  mov   rdx, [r14]                ; Get stack value
        shr   rdx, 3                    ; Shift odd bits out
        shl   rdx, 3                    ; Shift zeroes back in
        mov   [r14], rdx
        nextm
datam

; rnd>8 - Round stack number to the next higher multiple of eight.
; Do nothing if number is already a multiple of eight.

head    "rnd>8", ario
rute:   dq  rute0
textm
rute0:  mov   rdx, [r14]                ; Get stack value
        and   rdx, 7                    ; See how much to add
        jz    rute1                     ; Branch if no bytes to add
        neg   rdx
        add   rdx, 8
        add   [r14], rdx                ; Add rounding bytes
rute1:  nextm
datam

; sgn - Signum function

head    "sgn", ario
signum: dq  sgnu0
textm
sgnu0:  bt    qword[r14], 63
        jnc   sgnu2
        mov   qword[r14], -1
        jmp   sgnu4
sgnu2:  cmp   qword[r14], 0
        jnz   sgnu3
        mov   qword[r14], 0
        jmp   sgnu4
sgnu3:  mov   qword[r14], 1
sgnu4:  nextm
datam

; abs

head    "abs", ario
absv:   dq  absv0
textm
absv0:  bt    qword[r14], 63
        jnc   absv1
        neg   qword[r14]
absv1:  nextm
datam

; negate

head    "negate", ario
negate: dq  neg0
textm
neg0:   neg   qword[r14]
        nextm
datam

; min

head    "min", ario
minf:   dq  min0
textm
min0:   mov   rdx, [r14]
        add   r14, 8
        cmp   [r14], rdx
        jle   min1
        mov   [r14], rdx
min1:   nextm
datam

; max

head    "max", ario
maxf:   dq  max0
textm
max0:   mov   rdx, [r14]
        add   r14, 8
        cmp   [r14], rdx
        jge   max1
        mov   [r14], rdx
max1:   nextm
datam

; +

head    "+", ario
plus:   dq  plus0
textm
plus0:  mov   rdx, [r14]
        add   r14, 8
        add   [r14], rdx
        nextm
datam

; -

head    "-", ario
minus:  dq  mins0
textm
mins0:  mov   rdx, [r14]
        add   r14, 8
        sub   [r14], rdx
        nextm
datam

; *  - signed multiply

head    "*", ario
star:   dq  star0
textm
star0:  mov   rax, [r14]
        add   r14, 8
        imul  qword[r14]
; Can insert trap on overflow if the high order result is not zero.
        mov   [r14], rax
        nextm
datam

; / - signed 64-bit quotient of a 64-bit number and a 64-bit divisor

head    "/", ario
slash:  dq  slsh0
textm
slsh0:  mov   rbx, [r14]                ; Get divisor
        add   r14, 8                    ; Pop stack
        test  rbx, rbx
        jnz   slsh1

        throwm 12

slsh1:  mov   rax, [r14]                ; Get dividend
        cqo                             ; Sign-extend dividend into rdx
        idiv  rbx                       ; Divide
        mov   [r14], rax                ; Return quotient
        nextm
datam

; mod - return remainder of division

head    "mod", ario
modu:   dq  modu0
textm
modu0:  mov   rax, [r14+8]              ; Get dividend
        cmp   qword[r14], 0
        jnz   modu1

        throwm 12

modu1:  cqo                             ; Sign-extend dividend
        idiv  qword[r14]                ; Divide by divisor
        add   r14, 8                    ; Pop dividend
        mov   [r14], rdx                ; Return remainder
        nextm
datam

; /mod - signed 64-bit quotient and 64-bit remainder of a 64-bit
;       number and a 64-bit divisor

head    "/mod", ario
slmod:  dq  slmd0
textm
slmd0:  mov   rax, [r14+8]              ; Get dividend
        cmp   qword[r14], 0
        jnz   slmd1

        throwm 12

slmd1:  cqo                             ; Sign-extend dividend
        idiv  qword[r14]                ; Divide
        mov   [r14+8], rdx              ; Return remainder
        mov   [r14], rax                ; Return quotient
        nextm
datam

; u/mod - usigned 64-bit quotient and 64-bit remainder of a 64-bit
;        number and a 64-bit divisor

head    "u/mod", ario
uslmod: dq  usmd0
textm
usmd0:  mov   rax, [r14+8]              ; Get dividend
        cmp   qword[r14], 0
        jnz   usmd1

        throwm 12

usmd1:  xor   rdx, rdx                  ; Clear high order dividend register
        div   qword[r14]                ; Divide
        mov   [r14+8], rdx              ; Return remainder
        mov   [r14], rax                ; Return quotient
        nextm
datam

; */

head    "*/", ario
sslsh:  dq  ssls0
textm
ssls0:  mov   rax, [r14+8]              ; Get multiplicand
        cmp   qword[r14], 0             ; See if divisor is 0
        jnz   ssls1                     ; Branch if not

        throwm 12                       ; Throw zero divisor

ssls1:  imul  qword[r14+16]             ; Multiply by muliplier
        idiv  qword[r14]                ; Divide by divisor
        add   r14, 16                   ; Pop two items
        mov   [r14], rax                ; Return quotient
        nextm
datam

; */mod

head    "*/mod", ario
ssmod:  dq  ssmd0
textm
ssmd0:  mov   rax, [r14+8]              ; Get multiplicand
        cmp   qword[r14], 0
        jnz   ssmd1

        throwm 12

ssmd1:  imul  qword[r14+16]             ; Multiply by muliplier
        idiv  qword[r14]                ; Divide by divisor
        add   r14,8                     ; Drop divisor
        mov   [r14+8],rdx               ; Return remainder
        mov   [r14], rax                ; Return quotient
        nextm
datam

; Mixed integer arithmetic involving 128-bit quantities

; m* - signed 128-bit product of 64-bit multiplicands

head    "m*", ario
mstar:  dq  mstr0
textm
mstr0:  mov   rax, [r14]                ; Get multiplicand
        imul  qword[r14+8]              ; Multiply by multiplier
        mov   [r14+8], rax              ; Return low order result
        mov   [r14], rdx                ; Return high order result
        nextm
datam

; um* - unsigned 128-bit product of 64-bit multiplicands.

head    "um*", ario
umstr:  dq  umst0
textm
umst0:  mov   rax, [r14]                ; Get multiplicand
        mul   qword[r14+8]              ; Multiply by multiplier
        mov   [r14+8], rax              ; Return low order result
        mov   [r14], rdx                ; Return high order result
        nextm
datam

; m/mod - signed 64-bit quotient and 64-bit remainder of a 128-bit
;        number and a 64-bit divisor

head    "m/mod", ario
msmod:  dq  msmd0
textm
msmd0:  mov   rdx, [r14+8]              ; Get high order dividend
        mov   rax, [r14+16]             ; Get low order dividend
        cmp   qword[r14], 0             ; Check for zero divisor
        jnz   msmd1

        throwm 12

msmd1:  idiv  qword[r14]                ; Divide
        add   r14,8                     ; Drop divisor
        mov   [r14+8], rdx              ; Return remainder
        mov   [r14], rax                ; Return quotient
        nextm
datam

; um/mod - unsigned 64-bit quotient and 64-bit remainder of a 128-bit
;         dividend and 64-bit divisor. If there is overflow, the function
;         returns the 128-bit quotient and a false flag (-1). If no overflow
;         can happen returns quotient, remainder and true flag (0).

head    "um/mod", ario
umsmod: dq  umsm0
textm
umsm0:  mov   rdx, [r14+8]              ; Get high order dividend
        mov   rax, [r14+16]             ; Get low order dividend
        cmp   rdx, [r14]                ; Compare divisor to high order dividend
        jnc   umsm1                     ; Branch if greater or equal

        div   qword[r14]                ; Divide

        mov   [r14+16], rdx             ; Return remainder
        mov   [r14+8], rax              ; Return quotient
        mov   rbx, 0                    ; Return true flag
        jmp   umsm2

umsm1:  mov   rbx, rax
        mov   rax, rdx
        xor   rdx, rdx
        div   qword[r14]
        mov   [r14+8], rax              ; Return high order quotient
        mov   rax, rbx
        div   qword[r14]
        mov   [r14+16], rax             ; Return low order quotient
        mov   rbx, -1
umsm2:  mov   [r14], rbx                ; Return flag
        nextm
datam

; gcd - Greatest common divisor of 64-bit integer by the simple Euclidean Algorithm.
;      Note that the numerator may be negative, but the result will always be positive.
;      Both numbers cannot be zero, and gcd(a,0) = |a|.

head    "gcd", ario
gcd:    dq  gcdv0
textm
gcdv0:  bt    qword[r14], 63            ; See if 1st argument is negative
        jnc   gcdv1                     ; Branch if not
        neg   qword[r14]                ; Else negate
gcdv1:  bt    qword[r14+8], 63          ; See if 2nd argument is negative
        jnc   gcdv2                     ; Branch if not
        neg   qword[r14+8]              ; Else negate
gcdv2:  mov   rax, [r14]                ; Get first argument
        add   r14, 8                    ; Pop stack
        mov   rbx, [r14]                ; Get second argument
        cmp   rax, 0                    ; See if 1st number is zero
        jz    gcdv6                     ; Branch if zero
        cmp   rbx, 0                    ; See if 2nd number is zero
        jz    gcdv5                     ; Branch if so
        xor   rdx, rdx                  ; Clear high order dividend
        cmp   rax, rbx                  ; Find smaller argument
        jc    gcdv3
        xchg  rax, rbx                  ; Swap arguments
gcdv3:  div   rbx                       ; Divide by smaller argument
        test  rdx, rdx                  ; See if remainder is zero
        jz    gcdv4                     ; Branch if so
        mov   rax, rbx                  ; Replace quotient with divisor
        mov   rbx, rdx                  ; Replace divisor with remainder
        xor   rdx, rdx                  ; Clear high order dividend
        jmp   gcdv3                     ; Loop
gcdv4:  mov   [r14], rbx                ; Return GCD
        jmp   gcdv9                     ; Finish

gcdv5:  cmp   rax, 0                    ; See if 1st argument is zero
        jz    gcdv8                     ; Throw if so
        mov   [r14], rax                ; Return 1st argument
        jmp   gcdv9                     ; Exit

gcdv6:  cmp   rbx, 0                    ; See if 2nd argument is zero
        jnz   gcdv9                     ; Exit if not

gcdv8:  throwm 29                       ; Throw

gcdv9:  nextm
datam

; bgcd - Greatest common divisor of 64-bit integer by the binary GCD algorithm.
;      Note that the numerator may be negative, but the result will always be positive.
;      Both numbers cannot be zero, and bgcd(a,0) = |a|.

head    "bgcd", ario
bgcd:   dq  bgcd0
textm
bgcd0:  bt    qword[r14], 63            ; See if Y is negative
        jnc   bgcd1                     ; Branch if not
        neg   qword[r14]                ; Else negate
bgcd1:  bt    qword[r14+8], 63          ; See if X is negative
        jnc   bgcd2                     ; Branch if not
        neg   qword[r14+8]              ; Else negate
bgcd2:  mov   rax, [r14]                ; Get Y
        add   r14, 8                    ; Pop stack
        mov   rbx, [r14]                ; Get X
        cmp   rax, 0                    ; See if Y is 0
        jz    bgcd14                    ; Branch if so
        cmp   rbx, 0                    ; See if X is 0
        jz    bgcd13                    ; Branch if so
        cmp   rax, 1                    ; See if Y is 1
        jz    bgcd16                    ; Branch if so
        cmp   rbx, 1                    ; See if X is 1
        jz    bgcd16                    ; Branch if so

        xor   rcx, rcx                  ; Initialize counter
bgcd3:  bt    rax, 0                    ; See if Y is even
        jc    bgcd4                     ; Branch if odd
        bt    rbx, 0                    ; See if X is even
        jc    bgcd5                     ; Branch if odd
        shr   rax, 1                    ; Divide Y by 2
        shr   rbx, 1                    ; Divide X by 2
        sub   rcx, 1                    ; Decrement counter
        jmp   bgcd3                     ; Loop

bgcd4:  bt    rbx, 0                    ; See if X is even
        jc    bgcd6                     ; Branch if odd
        shr   rbx, 1                    ; Divide X by 2
        jmp   bgcd4                     ; Loop

bgcd5:  bt    rax, 0                    ; See if Y is even
        jc    bgcd6                     ; Branch if odd
        shr   rax, 1                    ; Divide Y by 2
        jmp   bgcd5                     ; Loop

bgcd6:  cmp   rax, rbx                  ; Trial-subtract X from Y
        jg    bgcd7                     ; Branch if Y > X
        jz    bgcd11                    ; Finished if Y = X
        xchg  rax, rbx                  ; Else exchange Y and X

bgcd7:  sub   rax, rbx                  ; Y = Y - X

bgcd8:  bt    rax, 0                    ; See if Y is now even
        jc    bgcd6                     ; Branch if odd
        shr   rax, 1                    ; Divide Y by 2
        jmp   bgcd8                     ; Loop

bgcd11: neg   rcx                       ; Make counter positive
        shl   rbx, cl                   ; Shift X left by counter value
        mov   [r14], rbx                ; Return GCD
        jmp   bgcd17                    ; Branch to exit

bgcd13: cmp   rax, 0                    ; See if Y is zero
        jz    bgcd15                    ; Throw if so
        mov   [r14], rax                ; Else return Y
        jmp   bgcd17                    ; Exit

bgcd14: cmp   rbx, 0                    ; See if X is zero
        jnz   bgcd17                    ; Exit if not, X is already on stack

bgcd15: throwm 29                       ; Throw

bgcd16: mov   qword[r14], 1             ; If either argument is 1, return 1

bgcd17: nextm
datam

; reduce - Reduce single precision rational number to lowest terms.
;         If numerator is zero, and denominator is any number, change denominator to 1.
;         I denominator is zero, throw undefined.

head    "reduce", ario
redu:   dq  redu0
textm
redu0:  mov   rax, [r14]                ; Get denominator (Y)
        mov   rbx, [r14+8]              ; Get numerator (X)
        cmp   rbx, 0                    ; See if numerator is zero
        jz    redu10                    ; Branch if so

        cmp   rax, 1                    ; See if denominator is 1
        jz    redu11                    ; Exit if so

        xor   rbp, rbp                  ; Zero flags register
        bt    rbx, 63                   ; See if numerator is negative
        jnc   redu1                     ; Branch if not
        neg   rbx                       ; Else negate and
        bts   rbp, 0                    ; set sign flag
redu1:  cmp   rbx, 1                    ; See if numerator is 1
        jz    redu11                    ; Exit if so

; Initialize auxiliary variables

        mov   rcx, 1                    ; A = 1
        mov   rdx, 0                    ; B = 0
        mov   r8, 0                     ; C = 0
        mov   r9, 1                     ; D = 1

redu2:  bt    rax, 0                    ; See if Y is even
        jc    redu3                     ; Branch if odd
        bt    rbx, 0                    ; See if X is even
        jc    redu4                     ; Branch if odd
        shr   rax, 1                    ; Divide Y by 2
        shr   rbx, 1                    ; Divide X by 2
        jmp   redu2                     ; Loop

redu3:  bt    rbx, 0                    ; See if numerator is still even
        jc    redu5                     ; Branch if odd
        shr   rbx, 1                    ; Divide X by 2
        shl   rcx, 1                    ; Multiply A by 2
        jmp   redu3                     ; Loop

redu4:  bt    rax, 0                    ; See if denominator is still even
        jc    redu5                     ; Branch if odd
        shr   rax, 1                    ; Divide Y by 2
        shl   r9, 1                     ; Multiply D by 2
        jmp   redu4                     ; Loop

redu5:  cmp   rax, rbx                  ; Trial-subtract X from Y
        jg    redu6                     ; Branch if Y > X
        jz    redu8                     ; Finished if Y = X

        xchg  rax, rbx                  ; Else exchange Y and X
        xchg  rcx, r8                   ; Exchange A and C
        xchg  rdx, r9                   ; Exchange B and D

redu6:  sub   rax, rbx                  ; Y = Y - X
        add   rcx, r8                   ; A = A + C
        add   rdx, r9                   ; B = B + D

redu7:  bt    rax, 0                    ; See if Y is now even
        jc    redu5                     ; Branch if odd
        shr   rax, 1                    ; Divide Y by 2
        shl   r8, 1                     ; Multiply C by 2
        shl   r9, 1                     ; Multiply D by 2
        jmp   redu7                     ; Loop

redu8:  add   r8, rcx                   ; NUM = A + C
        add   r9, rdx                   ; DEN = B + D
        btr   rbp, 0                    ; Test/clear sign flag
        jnc   redu9                     ; Branch if flag was clear
        neg   r8                        ; Else negate numerator

redu9:  mov   [r14], r9                 ; Return denominator
        mov   [r14+8], r8               ; Return numerator
        jmp   redu11                    ; Branch to exit

redu10: mov   qword[r14], 1             ; Set denominator to 1

redu11: nextm
datam

; Comparison operators

; 0=  - Replace top stack entry with a true flag (-1) if it is zero,
;      else false flag (0).

head    "0=", rlto
zequ:   dq  zequ0
textm
zequ0:  cmp   qword[r14], 0
        setz  dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; 0<>  - Replace top stack entry with a true flag (-1) if it is not zero,
;       else false flag (0).

head    "0<>", rlto
znequ:  dq  zneq0
textm
zneq0:  cmp   qword[r14], 0
        setnz dl
        neg   dl
        movsx rdx,dl
        mov   [r14], rdx
        nextm
datam

; 0<  - Replace top stack entry with a true flag (-1) if
;      it is less than zero, else false flag (0).

head    "0<", rlto
zless:  dq  zles0
textm
zles0:  cmp   qword[r14], 0
        sets  dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; 0>  - Replace top stack entry with a true flag (-1) if
;      it is greater than zero, else false flag (0).

head    "0>", rlto
zgreat: dq  zgrt0
textm
zgrt0:  cmp   qword[r14], 0
        setg  dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; The following comparison operators need to be verified!

; =  - Replace top two stack entries with a true flag if they are equal,
;     else false flag.

head    "=", rlto
equal:  dq  equl0
textm
equl0:  mov   rdx, [r14]
        add   r14, 8
        cmp   rdx, [r14]
        setz  dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; <>  - Replace top two stack entries with a true flag if they are equal,
;      else false flag.

head    "<>", rlto
ntequ:  dq  nteq0
textm
nteq0:  mov   rdx, [r14]
        add   r14, 8
        cmp   [r14], rdx
        setnz dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; <  - Replace top two stack entries with a true flag if top entry is less
;     than second entry, else false flag.

head    "<", rlto
less:   dq  less0
textm
less0:  mov   rdx, [r14]
        add   r14, 8
        cmp   [r14], rdx
        setl  dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; >  - Replace top two stack entries with a true flag if top entry
;     is greater than second entry, else false flag.

head    ">", rlto
great:  dq  grat0
textm
grat0:  mov   rdx, [r14]
        add   r14, 8
        cmp   [r14], rdx
        setg  dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; u<  - Unsigned less than

head    "u<", rlto
uless:  dq  ules0
textm
ules0:  mov   rdx, [r14]
        add   r14, 8
        sub   [r14], rdx
        sbb   rdx, rdx
        mov   [r14], rdx
        nextm
datam

; u>  - Unsigned greater than

head    "u>", rlto
ugrat:  dq  ugrt0
textm
ugrt0:  mov   rdx, [r14]
        add   r14, 8
        sub   rdx, [r14]
        sbb   rdx, rdx
        mov   [r14], rdx
        nextm
datam

; <=  - Less than or equal

head    "<=", rlto
lseq:   dq  lseq0
textm
lseq0:  mov   rdx, [r14]
        add   r14, 8
        cmp   [r14], rdx
        setle dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; >=  - Greater than or equal

head    ">=", rlto
gteq:   dq  gteq0
textm
gteq0:  mov   rdx, [r14]
        add   r14, 8
        cmp   [r14], rdx
        setge dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; within - ( s1 s2 s3 --- flag ) True when s1 >= s2 and s1 < s3.

head    "within", rlto
withn:  dq  wthn0
textm
wthn0:  mov   rdx, [r14]                ; Get s3
        mov   rcx, [r14+8]              ; Get s2
        mov   rbx, [r14+16]             ; Get s1
        add   r14,16                    ; Pop two items
        sub   rdx, rcx                  ; s3-s2
        sub   rbx, rcx                  ; s1-s2
        sub   rbx, rdx                  ; (s1-s2)-(s3-s2)
        sbb   rdx, rdx
        mov   [r14], rdx
        nextm
datam

; between - ( s1 s2 s3 --- flag ) True when s1 >= s2 and s1 <= s3.

head    "between", rlto
btween: dq  btwn0
textm
btwn0:  mov   rdx, [r14]                ; Get s3
        mov   rcx, [r14+8]              ; Get s2
        mov   rbx, [r14+16]             ; Get s1
        add   r14,16                    ; Pop two items
        add   rdx, 1                    ; Allow for s1=s3
        sub   rdx, rcx                  ; s3-s2
        sub   rbx, rcx                  ; s1-s2
        sub   rbx, rdx                  ; (s1-s2)-(s3-s2)
        sbb   rdx, rdx
        mov   [r14], rdx
        nextm
datam

; . - Output the single precision number on top of the stack as a signed,
; 64-bit integer followed by a space.

; : .   1 ckstk nob0 base @ spi>bsn bsn>ascii count strout space ;

head    ".", hlfo
dot:    dq  docl0
        dq  one,ckstk
        dq  nobn,base,qat,spbsn
        dq  bsasc,count,strout,space,semis

; .r - ( n --- ) Output the single precision number on top of the stack
;     right justified in a field n characters wide. If n is not greater
;     than the number of characters in the string no padding is done.

; : .r    1 ckstk >a nob0 base @ spi>bsn bsn>ascii
;         count a> over - padchrs strout space ;

head    ".r", hlfo
dotr:   dq  docl0
        dq  one,ckstk
        dq  toa,nobn,base,qat,spbsn
        dq  bsasc,count,froma,over
        dq  minus,padcs
        dq  strout,space,semis

; ? - ( addr --- ) Fetch the contents of addr and display it.

; : ?   @ . ;

head    "?", hlfo
qdot:   dq  docl0
        dq  qat,dot,semis

; .. "dot-period" - Output the single precision number on top of the stack as a signed,
; 64-bit integer without a space or other character following.

; : ..   1 ckstk nob0 base @ spi>bsn bsn>ascii count strout ;

head    "..", hlfo
dotper: dq  docl0
        dq  one,ckstk
        dq  nobn,base,qat,spbsn
        dq  bsasc,count,strout,semis

; .| - Output the single precision number on top of the stack as a signed,
; 64-bit integer followed by a bar.

; : .|   1 ckstk nob0 base @ spi>bsn bsn>ascii count strout bar ;

head    ".|", hlfo
dotbar: dq  docl0
        dq  one,ckstk
        dq  nobn,base,qat,spbsn
        dq  bsasc,count,strout,bar,semis

; .bin - Output the single precision number on top of the stack
; in binary.

; : .bin   base @ >a bin . a> base ! ;

head    ".bin", hlfo
dtbin:  dq  docl0
        dq  base,qat,toa,bin,dot,froma,base,stor,semis

; .rbin - ( n --- ) Output the single precision number on top of the stack
; in binary and right justified in a field n characters wide. If n is not
; greater than the number of characters in the string no padding is done.

; .rbin

; : .rbin   base @ >a bin .r a> base ! ;

head    ".rbin", hlfo
dtrbn:  dq  docl0
        dq  base,qat,toa,bin,dotr,froma,base,stor,semis

; .oct - Output the single precision number on top of the stack
; in octal.

; : .oct   base @ >a oct . a> base ! ;

head    ".oct", hlfo
dtoct:  dq  docl0
        dq  base,qat,toa,oct,dot,froma,base,stor,semis

; .roct - ( n --- ) Output the single precision number on top of the stack
; in octal and right justified in a field n characters wide. If n is not
; greater than the number of characters in the string no padding is done.

; : .roct   base @ >a oct .r a> base ! ;

head    ".roct", hlfo
dtroc:  dq  docl0
        dq  base,qat,toa,oct,dotr,froma,base,stor,semis

; .dec - Output the single precision number on top of the stack
; in decimal.

; : .dec   base @ >a dec . a> base ! ;

head    ".dec", hlfo
dtdec:  dq  docl0
        dq  base,qat,toa,deci,dot,froma,base,stor,semis

; .rdec - ( n --- ) Output the single precision number on top of the stack
; in decimal and right justified in a field n characters wide. If n is not
; greater than the number of characters in the string no padding is done.

; : .rdec   base @ >a dec .r a> base ! ;

head    ".rdec", hlfo
dtrdc:  dq  docl0
        dq  base,qat,toa,deci,dotr,froma,base,stor,semis

; .hex - Output the single precision number on top of the stack
; in hexadecimal.

; : .hex   base @ >a hex . a> base ! ;

head    ".hex", hlfo
dthex:  dq  docl0
        dq  base,qat,toa,hex,dot,froma,base,stor,semis

; .rhex - ( n --- ) Output the single precision number on top of the stack
; in hexadecimal and right justified in a field n characters wide. If n is
; not greater than the number of characters in the string no padding is
; done.

; .rhex

; : .rhex   base @ >a hex .r a> base ! ;

head    ".rhex", hlfo
dtrhx:  dq  docl0
        dq  base,qat,toa,hex,dotr,froma,base,stor,semis

; .base   ( n --- ) Output the top stack entry in the number base
; passed on the stack.

; u. - Output the unsigned single precision number on top of the stack
;     in the current number base.

; : u.   1 ckstk nob0 base @ uspi>bsn bsn>ascii count strout space ;

head    "u.", hlfo
udot:   dq  docl0
        dq  one,ckstk
        dq  nobn,base,qat,usbsn
        dq  bsasc,count,strout,space,semis

; u.r - ( n --- ) Output the unsigned single precision number on top
;      of the stack right justified in a field n characters wide.
;      If n is not greater than the number of characters in the string,
;      no padding is done.

; : u.r   1 ckstk >a nob0 base @ uspi>bsn bsn>ascii
;         count a> over - padchrs strout space ;

head    "u.r", hlfo
udotr:  dq  docl0
        dq  one,ckstk
        dq  toa,nobn,base,qat,usbsn
        dq  bsasc,count,froma,over
        dq  minus,padcs
        dq  strout,space,semis

; u.lz - ( n --- ) Output the unsigned spi on top of the stack
;       right justified in a field of zeroes.

; : u.lz   pdchr @ >a 48 pdchr ! u.r a> pdchr ! ;

head    "u.lz", hlfo
udotlz: dq  docl0
        dq  pdchr,qat,toa,lit,48,pdchr,stor
        dq  udotr,froma,pdchr,stor,semis

; u.. "u dot-period" - Output the unsigned single precision number on top
; of the stack as a signed, 64-bit integer with no other character following.

; : u..   1 ckstk nob0 base @ uspi>bsn bsn>ascii count strout ;

head    "u..", hlfo
udotpr: dq  docl0
        dq  one,ckstk
        dq  nobn,base,qat,usbsn
        dq  bsasc,count,strout,semis

; u.bin - Output the single precision number on top of the stack
; as unsigned binary.

; : u.bin   base @ >a bin u. a> base ! ;

head    "u.bin", hlfo
udbin:  dq  docl0
        dq  base,qat,toa,bin,udot,froma,base,stor,semis

; u.oct - Output the single precision number on top of the stack
; as unsigned octal.

; : u.oct   base @ >a oct u. a> base ! ;

head    "u.oct", hlfo
udoct:  dq  docl0
        dq  base,qat,toa,oct,udot,froma,base,stor,semis

; u.dec - Output the single precision number on top of the stack
; as unsigned decimal.

; : u.dec   base @ >a dec u. a> base ! ;

head    "u.dec", hlfo
uddec:  dq  docl0
        dq  base,qat,toa,deci,udot,froma,base,stor,semis

; u.hex - Output the single precision number on top of the stack
; as unsigned hexadecimal.

; : u.hex   base @ >a hex u. a> base ! ;

head    "u.hex", hlfo
udhex:  dq  docl0
        dq  base,qat,toa,hex,udot,froma,base,stor,semis

; hex>asciinlz - Convert the quad on the top of the stack to a hexadecimal ASCII
; string without leading zeroes in the buffer provided for the purpose.
; Install the string length in the buffer, and return its address.

head    "hex>asciinlz", oupo, hidden
hxanz:  dq  hxnz0
textm
hxnz0:  mov   rax, [r14]                ; Get top stack quad
        lea   rdi, [hxout0]             ; Get buffer addr
        mov   [r14], rdi                ; Copy to stack
        mov   rcx, 16                   ; Set counter
        lea   rsi, [hxbyt0]             ; Get table base address
        xor   rbp, rbp                  ; Clear index register

hxnz1:  xor   rbx, rbx                  ; Clear table index
        shld  rbx, rax, 4               ; Shift high order nibble into rbx
        jnz   hxnz3                     ; Branch if nibble is not zero

        shl   rax, 4                    ; Shift quad left
        sub   rcx, 1                    ; Decrement counter
        jnz   hxnz1                     ; Loop
        jmp   hxnz4                     ; Branch to exit

hxnz2:  xor   rbx, rbx                  ; Clear table index
        shld  rbx, rax, 4               ; Shift high order nibble into rbx

hxnz3:  mov   dl, [rsi+rbx]             ; Get corresponding byte
        mov   [rdi+rbp], dl             ; Install byte
        add   rbp, 1                    ; Increment index
        shl   rax, 4                    ; Shift quad left
        sub   rcx, 1                    ; Decrement counter
        jnz   hxnz2

hxnz4:  mov   qword[rdi-8], rbp         ; Install string length

        nextm
datam

; hex.nlz - Output the quad on the stack as a hexadecimal number without leading
; zeroes

; : hex.nlz   hex>asciinlz 8- .name ;

head    "hex.nlz", hlfo
hxdnz:  dq  docl0
        dq  hxanz,eighm,dtnam,semis

; hex>ascii - Convert the quad on the top of the stack to a string
; of sixteen ASCII bytes in the buffer provided for the purpose,
; install the string length in the buffer, and return its address.

head    "hex>ascii", oupo, hidden
hxasc:  dq  hxas0
textm
hxas0:  mov   rax, [r14]                ; Get top stack quad
        lea   rdi, [hxout0]             ; Get buffer addr
        mov   [r14], rdi                ; Copy to stack
        mov   rcx, 16                   ; Set counter
        mov   qword[rdi-8], rcx         ; Install string length
        lea   rdi, [rdi+rcx]            ; Offset to end of block
        lea   rsi, [hxbyt0]             ; Get table base address
        neg   rcx                       ; Negate counter
hxas1:  xor   rbx, rbx                  ; Clear table index
        shld  rbx, rax, 4               ; Shift high order nibble into rbx
        shl   rax, 4                    ; Shift quad left
        mov   dl, [rsi+rbx]             ; Get corresponding byte
        mov   [rdi+rcx], dl             ; Install byte
        add   rcx, 1                    ; Increment counter
        jne   hxas1                     ; Loop if not zero

        nextm
datam

; hex. - Output the quad on the stack as a 16-byte hexadecimal
; block.

; : hex.   hex>ascii 8- .name ;

head    "hex.", hlfo
hexdt:  dq  docl0
        dq  hxasc,eighm,dtnam,semis

; 2hex>ascii - Convert the two top stack quads to a string
; of thirty-two ASCII bytes in the buffer provided for the purpose,
; install the string length in the buffer, and return its address.

head    "2hex>ascii", oupo, hidden
thexa:  dq  thxa0
textm
thxa0:  mov   rax, [r14]                ; Get top stack quad
        add   r14, 8                    ; Pop stack
        lea   rdi, [hxout0]             ; Get buffer addr
        mov   qword[rdi-8], 32          ; Install string length
        lea   rsi, [hxbyt0]             ; Get table base address
        xor   rcx, rcx                  ; Clear index
        mov   rdx, 16                   ; Set counter
thxa1:  xor   rbx, rbx                  ; Clear table index
        shld  rbx, rax, 4               ; Shift high order nibble into rbx
        shl   rax, 4                    ; Shift 1st quad left
        mov   r8b, [rsi+rbx]            ; Get corresponding byte
        mov   [rdi+rcx], r8b            ; Install byte
        add   rcx, 1                    ; Increment index
        sub   rdx, 1                    ; Decrement counter
        jne   thxa1                     ; Loop if not zero

        mov   rax, [r14]                ; Get next quad
        mov   rdx, 16                   ; Set counter
thxa2:  xor   rbx, rbx                  ; Clear table index
        shld  rbx, rax, 4               ; Shift high order nibble into rbx
        shl   rax, 4                    ; Shift 2nd quad left
        mov   r8b, [rsi+rbx]            ; Get corresponding byte
        mov   [rdi+rcx], r8b            ; Install byte
        add   rcx, 1                    ; Increment index
        sub   rdx, 1                    ; Decrement counter
        jne   thxa2                     ; Loop if not zero

        mov   [r14], rdi                ; But buffer address on stack
        nextm
datam

; 2hex. - Output the two quads on the stack as a 32-byte hexadecimal
; block.

; : 2hex.   2hex>ascii 8- .name ;

head    "2hex.", hlfo
thxdt:  dq  docl0
        dq  thexa,eighm,dtnam,semis

; 4hex>ascii - Convert the four top stack quads to a string
; of sixty-four ASCII bytes in the buffer provided for the purpose,
; install the string length in the buffer, and return its address.

head    "4hex>ascii", oupo, hidden
qhexa:  dq  qhxa0
textm
qhxa0:  mov   rax, [r14]                ; Get top stack quad
        add   r14, 8                    ; Pop stack
        lea   rdi, [hxout0]             ; Get buffer addr
        mov   qword[rdi-8], 64          ; Install string length
        lea   rsi, [hxbyt0]             ; Get table base address
        xor   rcx, rcx                  ; Clear index
        mov   rdx, 16                   ; Set counter
qhxa1:  xor   rbx, rbx                  ; Clear table index
        shld  rbx, rax, 4               ; Shift high order nibble into rbx
        shl   rax, 4                    ; Shift 1st quad left
        mov   r8b, [rsi+rbx]            ; Get corresponding byte
        mov   [rdi+rcx], r8b            ; Install byte
        add   rcx, 1                    ; Increment index
        sub   rdx, 1                    ; Decrement counter
        jne   qhxa1                     ; Loop if not zero

        mov   rax, [r14]                ; Get next quad
        add   r14, 8                    ; Pop stack
        mov   rdx, 16                   ; Set counter
qhxa2:  xor   rbx, rbx                  ; Clear table index
        shld  rbx, rax, 4               ; Shift high order nibble into rbx
        shl   rax, 4                    ; Shift 2nd quad left
        mov   r8b, [rsi+rbx]            ; Get corresponding byte
        mov   [rdi+rcx], r8b            ; Install byte
        add   rcx, 1                    ; Increment index
        sub   rdx, 1                    ; Decrement counter
        jne   qhxa2                     ; Loop if not zero

        mov   rax, [r14]                ; Get next quad
        add   r14, 8                    ; Pop stack
        mov   rdx, 16                   ; Set counter
qhxa3:  xor   rbx, rbx                  ; Clear table index
        shld  rbx, rax, 4               ; Shift high order nibble into rbx
        shl   rax, 4                    ; Shift 2nd quad left
        mov   r8b, [rsi+rbx]            ; Get corresponding byte
        mov   [rdi+rcx], r8b            ; Install byte
        add   rcx, 1                    ; Increment index
        sub   rdx, 1                    ; Decrement counter
        jne   qhxa3                     ; Loop if not zero

        mov   rax, [r14]                ; Get next quad
        mov   rdx, 16                   ; Set counter
qhxa4:  xor   rbx, rbx                  ; Clear table index
        shld  rbx, rax, 4               ; Shift high order nibble into rbx
        shl   rax, 4                    ; Shift 2nd quad left
        mov   r8b, [rsi+rbx]            ; Get corresponding byte
        mov   [rdi+rcx], r8b            ; Install byte
        add   rcx, 1                    ; Increment index
        sub   rdx, 1                    ; Decrement counter
        jne   qhxa4                     ; Loop if not zero

        mov   [r14], rdi                ; But buffer address on stack
        nextm
datam

; 4hex. - Output the top four quads on the stack as a 64-byte hexadecimal
; block.

; : 4hex.   4hex>ascii 8- .name ;

head    "4hex.", hlfo
fhxdt:  dq  docl0
        dq  qhexa,eighm,dtnam,semis

; .base  ( n b --- ) Display the top stack number in the supplied number base.

; : .base   2 ckstk dup 2 65 within not if 126 throw then
;          base @ >a base ! . a> base ! ;

head    ".base", hlfo
dtbse:  dq  docl0
        dq  two,ckstk
        dq  dupl,two,lit,65,withn,nzbran,dtbs1
        dq  lit,126,throw
dtbs1:  dq  base,qat,toa,base,stor,dot,froma,base,stor,semis

; Double-quad Operators

; 2,

head    "2,", cmpo
dcomma: dq  dcom0
textm
dcom0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rax, [r14]                ; Move double quad to dictionary
        mov   [rdi], rax
        mov   rax, [r14+8]
        mov   [rdi+8], rax
        add   r14, 16                   ; Pop the stack
        add   qword[dspo0], 16          ; Advance dsp
        nextm
datam

; 2literal - compile a double literal

head    "2literal", -hlfo
dlite:  dq  docl0
        dq  pcomp,dlit,dcomma,semis
dlit:   dq  dlit0
textm
dlit0:  sub   r14, 16                   ; Make room on stack
        mov   rax, [r12]
        mov   [r14], rax
        mov   rax, [r12+8]
        mov   [r14+8], rax
        add   r12, 16                   ; Advance IP past literal
        nextm
datam

; 2constant

head    "2constant", hlfo
dcons:  dq  docl0
        dq  two,ckstk
        dq  dfine,lit,dcno,objcom,pcomm,dcon0
        dq  dcomma,oszcom,semis
textm
dcon0:  sub   r14, 16                   ; Make room on stack
        mov   rax, [r11+8]
        mov   [r14], rax
        mov   rax, [r11+16]
        mov   [r14+8], rax
        nextm
datam

; 2value

head    "2value", hlfo
dvalu:  dq  docl0
        dq  two,ckstk
        dq  dfine,lit,dvlo,objcom,pcomm,dval0
        dq  dcomma,oszcom,semis
textm
dval0:  sub   r14, 16
        mov   rax, [r11+8]
        mov   [r14], rax
        mov   rax, [r11+16]
        mov   [r14+8], rax
        nextm
datam

; 2to - ( d --- ) Set a 2value. Throw error if object is not a 2value.

head    "2to", hlfo
dtval:  dq  docl0
        dq  two,ckstk
        dq  tick,dupl,cftota,obtat
        dq  lit,dvlo,ntequ,zbran,dtvl1
        dq  lit,68,throw
dtvl1:  dq  eighp,dstor
        dq  semis

; 2variable

head    "2variable", hlfo
dvar:   dq  docl0
        dq  dfine,lit,dvro,objcom,pcomm,vari0
        dq  zero,zero,dcomma,oszcom,semis

; 2array - Create an array of n 128-bit elements. ( n --- ).
; Arrays are 1-based. Passed an element number from 1 to the maximum, returns the
; the address of that element. Throws an error if the index is out of bounds.
; If passed a negative number or zero, returns the array base address and the number
; of elements it contains.
;
; Array structure (header not shown):

; | code field | number of elements | elements ... |

head    "2array", hlfo
darra:  dq  docl0
        dq  one,ckstk
        dq  dfine,lit,daro,objcom,pcomm,darr0
        dq  dupl,comma,here,over,sxtst,allot
        dq  swp,zero,qfill,oszcom,semis
textm
darr0:  mov   rax, [r14]                ; Get array index
        cmp   rax, 0
        jg    darr1                     ; Branch if not zero or below

        lea   rdi, [r11+16]             ; Get array base address
        mov   [r14], rdi                ; Return to stack
        mov   rax, [r11+8]              ; Get number of elements
        sub   r14, 8
        mov   [r14], rax                ; Push to stack
        jmp   darr3                     ; Branch to exit

darr1:  cmp   [r11+8], rax              ; See if index is in bounds
        jnc   darr2                     ; Branch if so

        throwm 14                       ; Else throw index out of bounds

darr2:  sub   rax, 1                    ; Arrays are 1-based
        shl   rax, 4                    ; Multiply by sixteen
        lea   rdi, [r11+rax+16]         ; Load address of element
        mov   [r14], rdi                ; Return address of element
darr3:  nextm
datam

; 2@ - ( a-addr --- d ) Fetch double-quad item to the stack from passed address.

head    "2@", memo
dqat:   dq  dqat0
textm
dqat0:  mov   rdi, [r14]
        mov   rcx, [rdi]
        mov   rdx, [rdi+8]
        sub   r14, 8
        mov   [r14], rcx
        mov   [r14+8], rdx
        nextm
datam

; 2! - ( d a-addr --- ) Store double-quad stack item in address.

head    "2!", memo
dstor:  dq  dsto0
textm
dsto0:  mov   rdi, [r14]
        mov   rcx, [r14+8]
        mov   rdx, [r14+16]
        add   r14, 24
        mov   [rdi], rcx
        mov   [rdi+8], rdx
        nextm
datam

; 2>a - ( S: d --- ) ( A: --- d )

head    "2>a", stko
dtoa:   dq  dtoa0
textm
dtoa0:  mov   rcx, [r14]
        mov   rdx, [r14+8]
        add   r14, 16
        sub   r13, 16
        mov   [r13], rcx
        mov   [r13+8], rdx
        nextm
datam

; 2a> - ( S: --- d ) ( A: d --- )

head    "2a>", stko
dfroma: dq  dfma0
textm
dfma0:  mov   rcx, [r13]
        mov   rdx, [r13+8]
        add   r13, 16
        sub   r14, 16
        mov   [r14], rcx
        mov   [r14+8], rdx
        nextm
datam

; 2a! - ( S: d --- d ) ( A: --- d )

head    "2a!", stko
dast:   dq  dast0
textm
dast0:  mov   rcx, [r14]
        mov   rdx, [r14+8]
        sub   r13, 16
        mov   [r13], rcx
        mov   [r13+8], rdx
        nextm
datam

; 2a@ - ( S: --- d ) ( A: d --- d )

head    "2a@", stko
daat:   dq  daat0
textm
daat0:  mov   rcx, [r13]
        mov   rdx, [r13+8]
        sub   r14, 16
        mov   [r14], rcx
        mov   [r14+8], rdx
        nextm
datam

; 2adrop - ( A: d --- ) Discard the top double-quad item from the auxiliary
; stack.

head    "2adrop", stko
dadrp:  dq  dadr0
textm
dadr0:  add   r13, 16
        nextm
datam

; 2apick - ( n --- d[An] ) Copy the nth double-quad item from the auxiliary
; stack to the data stack. Zero based.

head    "2apick", stko
dapck:  dq  dapk0
textm
dapk0:  mov   rdi, [r14]
        shl   rdi, 1
        mov   rax, [r13+rdi*8]
        mov   rbx, [r13+rdi*8+8]
        sub   r14, 8
        mov   [r14], rax
        mov   [r14+8], rbx
        nextm
datam

; 2axch - ( S: d[S0] n --- d[An] ) ( A: d[n+1] d[n] d[n-1] ... d[0] --- 
; d[n+1] d[S0] d[n-1] ... d[0] ) Swap the top double-quad stack entry
; with the auxiliary stack entry whose number is passed on the stack.
; Zero based.

head    "2axch", stko
daxch:  dq  daxc0
textm
daxc0:  mov   r8, [r14]                 ; Pop entry number
        add   r14, 8
        shl   r8, 1                     ; Double for octoword data
        mov   rax, [r14]
        mov   rbx, [r14+8]
        mov   rcx, [r13+r8*8]
        mov   rdx, [r13+r8*8+8]
        mov   [r14], rcx
        mov   [r14+8], rdx
        mov   [r13+r8*8], rax
        mov   [r13+r8*8+8], rbx
        nextm
datam

; 2areplace - ( S: d[S0] n --- ) ( A: d[n+1] d[n] d[n-1] ... d[0] --- 
; d[n+1] d[S0] d[n-1] ... d[0] )  Replace the nth double-quad auxiliary
; stack item with the single-quad item on top of the data stack.
; Zero based.

head    "2areplace", stko
darpl:  dq  darp0
textm
darp0:  mov   rdx, [r14]
        shl   rdx, 1
        mov   rcx, [r14+8]
        mov   rbx, [r14+16]
        add   r14, 24
        mov   [r13+rdx*8], rcx
        mov   [r13+rdx*8+8], rbx
        nextm
datam

; 2drop - ( d --- )

head    "2drop", stko
ddrop:  dq  ddrp0
textm
ddrp0:  add   r14, 16
        nextm
datam

; 2dup - ( d --- d d )

head    "2dup", stko
ddup:   dq  ddup0
textm
ddup0:  mov   rcx, [r14]
        mov   rdx, [r14+8]
        sub   r14, 16
        mov   [r14], rcx
        mov   [r14+8], rdx
        nextm
datam

; 2swap - ( d1 d2 --- d2 d1 )

head    "2swap", stko
dswap:  dq  dswp0
textm
dswp0:  mov   rax, [r14]
        mov   rbx, [r14+8]
        mov   rcx, [r14+16]
        mov   rdx, [r14+24]
        mov   [r14], rcx
        mov   [r14+8], rdx
        mov   [r14+16], rax
        mov   [r14+24], rbx
        nextm
datam

; 2over - ( d1 d2 --- d1 d2 d1 )

head    "2over", stko
dover:  dq  dovr0
textm
dovr0:  mov   rcx, [r14+16]
        mov   rdx, [r14+24]
        sub   r14, 16
        mov   [r14], rcx
        mov   [r14+8], rdx
        nextm
datam

; 2tuck - ( d1 d2 --- d2 d1 d2 )

head    "2tuck", stko
dtuck:  dq  dtck0
textm
dtck0:  mov   rax, [r14]
        mov   rbx, [r14+8]
        mov   rcx, [r14+16]
        mov   rdx, [r14+24]
        sub   r14, 16
        mov   [r14], rax
        mov   [r14+8], rbx
        mov   [r14+16], rcx
        mov   [r14+24], rdx
        mov   [r14+32], rax
        mov   [r14+40], rbx
        nextm
datam

; 2rot - ( d1 d2 d3 --- d2 d3 d1 )

head    "2rot", stko
drot:   dq  drot0
textm
drot0:  mov   rax, [r14]                ; Get 1st entry
        mov   rbx, [r14+8]

        mov   rcx, [r14+16]             ; Get 2nd entry
        mov   rdx, [r14+24]

        mov   rsi, [r14+32]             ; Get 3rd entry
        mov   rdi, [r14+40]

        mov   [r14], rsi                ; Replace 1st with 3rd
        mov   [r14+8], rdi

        mov   [r14+16], rax             ; Replace 2nd with 1st
        mov   [r14+24], rbx

        mov   [r14+32], rcx             ; Replace 3rd with 2nd
        mov   [r14+40], rdx
        nextm
datam

; 2brot - ( d1 d2 d3 --- d3 d1 d2 ) "back rote", reverse rot

head    "2brot", stko
dbrot:  dq  dbrt0
textm
dbrt0:  mov   rax, [r14]                ; Get 1st entry
        mov   rbx, [r14+8]

        mov   rcx, [r14+16]             ; Get 2nd entry
        mov   rdx, [r14+24]

        mov   rsi, [r14+32]             ; Get 3rd entry
        mov   rdi, [r14+40]

        mov   [r14], rcx                ; Replace 1st with 2nd
        mov   [r14+8], rdx

        mov   [r14+16], rsi             ; Replace 2nd with 3rd
        mov   [r14+24], rdi

        mov   [r14+32], rax             ; Replace 3rd with 1st
        mov   [r14+40], rbx
        nextm
datam

; 2slip - ( d1 d2 --- d2 )

head    "2slip", stko
dslip:  dq  dslp0
textm
dslp0:  mov   rcx, [r14]
        mov   rdx, [r14+8]
        add   r14, 16
        mov   [r14], rcx
        mov   [r14+8], rdx
        nextm
datam

; 2slide - ( d1 d2 d3 --- d2 d3 )

head    "2slide", stko
dslid:  dq  dsld0
textm
dsld0:  mov   rax, [r14]
        mov   rbx, [r14+8]
        mov   rcx, [r14+16]
        mov   rdx, [r14+24]
        add   r14, 16
        mov   [r14], rax
        mov   [r14+8], rbx
        mov   [r14+16], rcx
        mov   [r14+24], rdx
        nextm
datam

; 2pick - ( d[n+1] d[n] d[n-1] ... d[0] n --- d[n+1] d[n] d[n-1] ... d[0] d[n] )
; Copy the nth stack item to the top. Zero based.

head    "2pick", stko
dpick:  dq  dpck0
textm
dpck0:  mov   rdi, [r14]
        shl   rdi, 1
        mov   rax, [r14+rdi*8+8]
        mov   rbx, [r14+rdi*8+16]
        sub   r14, 8
        mov   [r14], rax
        mov   [r14+8], rbx
        nextm
datam

; 2xch - ( d[n+1] d[n] d[n-1] ... d[0] n --- d[n+1] d[0] d[n-1] ... d[n] )
; Swap the nth stack item with the top entry. Zero based.

head    "2xch", stko
dxch:   dq  dxch0
textm
dxch0:  mov   r8, [r14]                 ; Pop entry number
        add   r14, 8
        shl   r8, 1                     ; Double for octoword data
        mov   rax, [r14]
        mov   rbx, [r14+8]
        mov   rcx, [r14+r8*8]
        mov   rdx, [r14+r8*8+8]
        mov   [r14], rcx
        mov   [r14+8], rdx
        mov   [r14+r8*8], rax
        mov   [r14+r8*8+8], rbx
        nextm
datam

; 2replace - ( d[n+1] d[n] d[n-1] ... d[0] d n --- d[n+1] d d[n-1] ... d[0] )
; Replace the nth stack item with the new top entry. Zero based.

head    "2replace", stko
drplc:  dq  drpl0
textm
drpl0:  mov   rdx, [r14]
        shl   rdx, 1
        mov   rcx, [r14+8]
        mov   rbx, [r14+16]
        add   r14, 24
        mov   [r14+rdx*8], rcx
        mov   [r14+rdx*8+8], rbx
        nextm
datam

; 2pluck - ( d[n+1] d[n] d[n-1] ... d[0] n --- d[n+1] d[n-1] ... d[0] d[n] )
; Extract the nth double-quad to the top of the stack and close the resulting gap.
; Do nothing if argument is zero or negative.

head    "2pluck", stko
dpluck: dq  dplk0
textm
dplk0:  mov   rdx, [r14]                ; Get item number from stack
        add   r14, 8                    ; Pop the stack
        cmp   rdx, 0                    ; Drop argument if it
        jle   dplk2                     ; is zero or negative

        shl   rdx, 1                    ; Double item number
        mov   rcx, [r14+rdx*8]          ; Get high order double quad
        mov   rbx, [r14+rdx*8+8]        ; Get low order double quad

dplk1:  mov   rax, [r14+rdx*8-8]        ; Close the gap
        mov   [r14+rdx*8+8], rax
        mov   rax, [r14+rdx*8-16]
        mov   [r14+rdx*8], rax
        sub   rdx, 2
        jnz   dplk1

        mov   [r14], rcx                ; Put high order item on stack
        mov   [r14+8], rbx              ; Put low order item on stack
dplk2:  nextm
datam

; 2poke - ( d[n+1] d[n] d[n-1] ... d[0] d n --- d[n+1] d[n] d d[n-1] ... d[0] )
; Make d the nth double-quad on the stack by moving the previous n-1 items up
; one position and then inserting d in the resulting gap. Do nothing if argument
; is zero or negative.

head    "2poke", stko
dpoke:  dq  dpok0
textm
dpok0:  mov   rdx, [r14]                ; Get stack position
        add   r14, 8                    ; Pop stack
        cmp   rdx, 0                    ; Drop argument if it
        jle   dpok2                     ; is zero or negative

        mov   rcx, [r14]                ; Get high order item to insert
        mov   rbx, [r14+8]              ; Get low order item to insert
        mov   rsi, r14                  ; Copy stack pointer
dpok1:  mov   rax, [rsi+16]             ; Move quads one cell up
        mov   [rsi], rax
        mov   rax, [rsi+24]
        mov   [rsi+8], rax
        add   rsi, 16                   ; Advance pointer
        sub   rdx, 1                    ; Decrement count
        jnz   dpok1

        mov   [rsi], rcx                ; Install item in nth position
        mov   [rsi+8], rbx
dpok2:  nextm
datam

; d2*

head    "d2*", ario
dtstr:  dq  dtst0
textm
dtst0:  mov   rax, [r14+8]
        shld  [r14], rax, 1
        shl   qword[r14+8], 1
        nextm
datam

; d4*

head    "d4*", ario
dfstr:  dq  dfst0
textm
dfst0:  mov   rax, [r14+8]
        shld  [r14], rax, 2
        shl   qword[r14+8], 2
        nextm
datam

; d8*

head    "d8*", ario
destr:  dq  dest0
textm
dest0:  mov   rax, [r14+8]
        shld  [r14], rax, 3
        shl   qword[r14+8], 3
        nextm
datam

; d64*

head    "d64*", ario
dsfst:  dq  dsft0
textm
dsft0:  mov   rax, [r14+8]
        shld  [r14], rax, 6
        shl   qword[r14+8], 6
        nextm
datam

; d2/

head    "d2/", ario
dtsla:  dq  dtsl0
textm
dtsl0:  bt    qword[r14], 63
        jnc   dtsl3

        mov   rbx, [r14+8]
        mov   rax, [r14]
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dtsl1

        add   rax, 1

dtsl1:  shrd  rbx, rax, 1
        sar   rax, 1
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dtsl2

        add   rax, 1

dtsl2:  mov   [r14+8], rbx
        mov   [r14], rax
        jmp   dtsl4

dtsl3:  shrd  [r14+8], rax, 1
        sar   qword[r14], 1

dtsl4:  nextm
datam

; d4/

head    "d4/", ario
dfsla:  dq  dfsl0
textm
dfsl0:  bt    qword[r14], 63
        jnc   dfsl3

        mov   rbx, [r14+8]
        mov   rax, [r14]
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dfsl1

        add   rax, 1

dfsl1:  shrd  rbx, rax, 2
        sar   rax, 2
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dfsl2

        add   rax, 1

dfsl2:  mov   [r14+8], rbx
        mov   [r14], rax
        jmp   dfsl4

dfsl3:  shrd  [r14+8], rax, 2
        sar   qword[r14], 2

dfsl4:  nextm
datam

; d8/

head    "d8/", ario
desla:  dq  desl0
textm
desl0:  bt    qword[r14], 63
        jnc   desl3

        mov   rbx, [r14+8]
        mov   rax, [r14]
        not   rbx
        not   rax
        add   rbx, 1
        jnc   desl1

        add   rax, 1

desl1:  shrd  rbx, rax, 3
        sar   rax, 3
        not   rbx
        not   rax
        add   rbx, 1
        jnc   desl2

        add   rax, 1

desl2:  mov   [r14+8], rbx
        mov   [r14], rax
        jmp   desl4

desl3:  shrd  [r14+8], rax, 3
        sar   qword[r14], 3

desl4:  nextm
datam

; d16/

head    "d16/", ario
dstsl:  dq  dsts0
textm
dsts0:  bt    qword[r14], 63
        jnc   dsts3

        mov   rbx, [r14+8]
        mov   rax, [r14]
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dsts1

        add   rax, 1

dsts1:  shrd  rbx, rax, 4
        sar   rax, 4
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dsts2

        add   rax, 1

dsts2:  mov   [r14+8], rbx
        mov   [r14], rax
        jmp   dsts4

dsts3:  shrd  [r14+8], rax, 4
        sar   qword[r14], 4

dsts4:  nextm
datam

; d32/

head    "d32/", ario
dttsl:  dq  dtts0
textm
dtts0:  bt    qword[r14], 63
        jnc   dtts3

        mov   rbx, [r14+8]
        mov   rax, [r14]
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dtts1

        add   rax, 1

dtts1:  shrd  rbx, rax, 5
        sar   rax, 5
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dtts2

        add   rax, 1

dtts2:  mov   [r14+8], rbx
        mov   [r14], rax
        jmp   dtts4

dtts3:  shrd  [r14+8], rax, 5
        sar   qword[r14], 5

dtts4:  nextm
datam

; d64/

head    "d64/", ario
dsfsl:  dq  dsfs0
textm
dsfs0:  bt    qword[r14], 63
        jnc   dsfs3

        mov   rbx, [r14+8]
        mov   rax, [r14]
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dsfs1

        add   rax, 1

dsfs1:  shrd  rbx, rax, 6
        sar   rax, 6
        not   rbx
        not   rax
        add   rbx, 1
        jnc   dsfs2

        add   rax, 1

dsfs2:  mov   [r14+8], rbx
        mov   [r14], rax
        jmp   dsfs4

dsfs3:  shrd  [r14+8], rax, 6
        sar   qword[r14], 6

dsfs4:  nextm
datam

; dsgn - Signum of double precision integer

head    "dsgn", ario
dsgn:   dq  dsgn0
textm
dsgn0:  add   r14, 8
        bt    qword[r14-8], 63
        jnc   dsgn2
        mov   qword[r14], -1
        jmp   dsgn4
dsgn2:  cmp   qword[r14], 0
        jnz   dsgn3
        cmp   qword[r14-8], 0
        jnz   dsgn3
        mov   qword[r14], 0
        jmp   dsgn4
dsgn3:  mov   qword[r14], 1
dsgn4:  nextm
datam

; dabs - Absolute value of double precision integer

head    "dabs", ario
dabs:   dq  dabs0
textm
dabs0:   bt    qword[r14], 63
        jnc   dabs1
        not   qword[r14+8]
        not   qword[r14]
        add   qword[r14+8], 1
        jnc   dabs1
        add   qword[r14], 1
dabs1:  nextm
datam

; dnegate - Change sign of double precision integer

head    "dnegate", ario
dneg:   dq  dneg0
textm
dneg0:  not   qword[r14+8]
        not   qword[r14]
        add   qword[r14+8], 1
        jnc   dneg1
        add   qword[r14], 1
dneg1:  nextm
datam

; dmin - Minimum of two double precision integers

head    "dmin", ario
dmin:   dq  dmin0
textm
dmin0:  mov   rdx, [r14]                ; Get high order of 1st operand
        mov   rcx, [r14+8]              ; Get low order
        add   r14, 16                   ; Pop 1st operand
        cmp   [r14], rdx                ; Compare high orders
        jz    dmin1                     ; If equal, compare low orders
        jl    dmin3                     ; If less, leave 2nd operand on stack
        jmp   dmin2                     ; If greater, overwrite 2nd with 1st
dmin1:  cmp   [r14+8], rcx              ; Compare low orders
        jle   dmin3                     ; If less or equal, leave 2nd operand
dmin2:  mov   [r14], rdx                ; Else overwrite 2nd operand with 1st
        mov   [r14+8], rcx
dmin3:  nextm
datam

; dmax - Maximum of two double precision integers

head    "dmax", ario
dmax:   dq  dmax0
textm
dmax0:  mov   rdx, [r14]                ; Get high order of 1st operand
        mov   rcx, [r14+8]              ; Get low order
        add   r14, 16                   ; Pop 1st operand
        cmp   [r14], rdx                ; Compare high orders
        jz    dmax1                     ; If equal, compare low orders
        jg    dmax3                     ; If greater, leave 2nd operand on stack
        jmp   dmax2                     ; If less, overwrite 2nd with 1st
dmax1:  cmp   [r14+8], rcx              ; Compare low orders
        jge   dmax3                     ; If greater or equal, leave 2nd operand
dmax2:  mov   [r14], rdx                ; Else overwrite 2nd operand with 1st
        mov   [r14+8], rcx
dmax3:  nextm
datam

; d+ - Add double precision integers

head    "d+", ario
dplus:  dq  dpls0
textm
dpls0:  mov   rdx, [r14+8]
        mov   rcx, [r14]
        add   r14, 16
        add   [r14+8], rdx
        adc   [r14], rcx
        nextm
datam

; d- - Subtract the double precision entry on top of the stack from the double
;     precision entry below it.

head    "d-", ario
dminus: dq  dmns0
textm
dmns0:  mov   rdx, [r14+8]
        mov   rcx, [r14]
        add   r14, 16
        sub   [r14+8], rdx
        sbb   [r14], rcx
        nextm
datam

; d/mod - divide a 128-bit dividend by a 128-bit divisor and return
; the 128-bit quotient and remainder.

head    "d/mod", ario
dsmd:   dq  dsmd0
textm
dsmd0:  xor   rbp, rbp                  ; Zero flags register
        bt    qword[r14], 63            ; Test sign of divisor
        jnc   dsmd1                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag if negative
        not   qword[r14+8]              ; Negate divisor
        not   qword[r14]
        add   qword[r14+8], 1
        jnc   dsmd1
        add   qword[r14], 1

dsmd1:  bt    qword[r14+16], 63         ; Test sign dividend
        jnc   dsmd2                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag if negative
        not   qword[r14+24]             ; Negate dividend
        not   qword[r14+16]
        add   qword[r14+24], 1
        jnc   dsmd2
        add   qword[r14+16], 1

; Find divisor lead quad. If lead quad is zero, use simpler routine.
; If divisor is zero, throw zero divide exception.

dsmd2:  cmp   qword[r14], 0             ; Find divisor lead quad
        jnz   dsmd5

        cmp   qword[r14+8], 0
        jnz   dsmd3

; Zero-divide exception.

        btr   rbp, 0                    ; Clear sign flag

        throwm 12

; Divide dividend by single divisor quad.

dsmd3:  cmp   qword[r14+16], 0          ; Test 1st dividend quad
        jz    dsmd4                     ; Branch if zero

        xor   rdx, rdx                  ; Zero high order dividend register
        mov   rax, [r14+16]             ; Get high order dividend
        div   qword[r14+8]              ; Divide
        mov   [r14], rax                ; Return high order quotient
        mov   rax, [r14+24]             ; Get low order dividend
        div   qword[r14+8]              ; Divide
        mov   [r14+8], rax              ; Return low order quotient
        mov   [r14+24], rdx             ; Return remainder
        mov   qword[r14+16], 0          ; Zero high order remainder
        jmp   dsmd15                    ; Branch to test sign flag

dsmd4:  cmp   qword[r14+24], 0          ; Test 2nd dividend quad
        jz    dsmd6                     ; Branch if zero

        mov   rax, [r14+24]             ; Get low order dividend
        div   qword[r14+8]              ; Divide
        mov   [r14+8], rax              ; Return low order quotient
        mov   [r14+24], rdx             ; Return remainder
        jmp   dsmd15                    ; Branch to test sign flag

; Find lead quad of dividend. If dividend is zero, return 0
; for quotient and remainder.
; If dividend is only 1 quad, divisor is larger, return 0
; for the quotient and the dividend for the remainder.

dsmd5:  cmp   qword[r14+16], 0          ; Find dividend lead quad
        jnz   dsmd7

        cmp   qword[r14+24], 0
        jnz   dsmd8                     ; Dividend is smaller

; If dividend is 0, return 0 for both quotient and remainder.
; Remainder/dividend is already 0.

dsmd6:  mov   qword[r14], 0             ; Set quotient to zero
        mov   qword[r14+8], 0
        jmp   dsmd17                    ; Branch to exit

dsmd7:  mov   r8, [r14]                 ; Compare 1st quad of divisor
        cmp   [r14+16], r8              ; with 1st quad of dividend
        jc    dsmd8                     ; Branch if dividend is smaller
        jnz   dsmd10                    ; If not equal, dividend is greater

; If lead quads are equal compare 2nd quads.

        mov   rbx, [r14+8]              ; Compare 2nd quad of divisor
        cmp   [r14+24], rbx             ; with dividend quad
        jc    dsmd8                     ; Branch if dividend is smaller
        jz    dsmd9                     ; If not equal, dividend is greater

; Divisor and dividend are equal. Return 1 for quotient and 0 for remainder.

        mov   qword[r14+8], 1
        mov   qword[r14], 0
        mov   qword[r14+16], 0
        mov   qword[r14+24], 0
        jmp   dsmd15                    ; Branch to test sign and finish

; Dividend is smaller than divisor. Return 0 for quotient. Remainder is
; dividend.

dsmd8:  mov   qword[r14+8], 0
        mov   qword[r14], 0
        jmp   dsmd15                    ; Branch to test sign and finish

; Lead quads of divisor and dividend are equal, return 1 for the quotient
; and subtract the divisor from the dividend for the remainder.

dsmd9:  mov   rax, [r14+8]              ; Subtract divisor from dividend
        mov   rbx, [r14]
        sub   [r14+24], rax
        sbb   [r14+16], rbx

        mov   qword[r14+8], 1           ; Set quotient to 1
        mov   qword[r14], 0
        jmp   dsmd15                    ; Branch to test sign and finish

; Prepare to divide and see if shifting is needed. If 2nd quad of divisor
; is not greater than the 1st quad, no shifting is needed.

dsmd10: mov   rdx, [r14+16]             ; Get dividend ready
        mov   rax, [r14+24]             ; to shift and divide
        cmp   r8, [r14+8]               ; Compare 2nd divisor quad with 1st
        jnc   dsmd11                    ; Shift if 2nd is greater

; Find divisor shift count.

        xor   rcx, rcx                  ; Zero register
        bsr   rcx, r8                   ; Scan for leading set bit
        neg   rcx                       ; Negate
        add   rcx, 63                   ; Add 63 for shift count

; Find normalized divisor lead quad.

        mov   rbx, [r14+8]              ; Get 2nd divisor quad
        shld  r8, rbx, cl               ; Shift 2nd quad into 1st

; Shift the dividend by the same amount as the divisor.

        xor   rbx, rbx                  ; Clear 1st quad
        shld  rbx, rdx, cl              ; Shift 2nd quad into 1st
        shld  rdx, rax, cl              ; Shift 3rd quad into 2nd
        shl   rax, cl                   ; Shift 3rd quad

; See if shifted lead dividend quad is zero.

        cmp   rbx, 0
        jz    dsmd11                    ; Branch if lead quad is zero

; If shifted dividend lead quad is not zero, divide 1st and 2nd
; quads by divisor lead quad.

        mov   rax, rdx
        mov   rdx, rbx
        jmp   dsmd12

; If shifted dividend lead quad is zero, test for possible overflow,
; and divide either 2nd and 3rd quads or only 2nd quad by divisor lead
; quad.

dsmd11: cmp   rdx, r8                   ; See if divisor lead quad larger
        jc    dsmd12                    ; Branch if so

        mov   rax, rdx                  ; Copy high order to low
        xor   rdx, rdx                  ; Clear high order

dsmd12: div   r8                        ; Divide by divisor lead quad
        mov   r9, rax                   ; Save estimated quotient

; Multiply divisor by estimated quotient digit and subtract from dividend.
; Product is kept in rdi and rsi registers.

        mov   rax, [r14+8]              ; Get 2nd divisor quad
        mul   r9                        ; Multiply by qhat
        mov   rsi, rax                  ; Install low order product
        mov   rdi, rdx                  ; Install high order product

        mov   rax, [r14]                ; Get 1st divisor quad
        mul   r9                        ; Multiply by qhat
        add   rdi, rax                  ; Add to high order product

        sub   [r14+24], rsi             ; Subtract from dividend low
        sbb   [r14+16], rdi             ; Subtract from dividend high

; See if partial result is now negative. If so, decrement qhat, add
; the divisor to the partial result, and test the sign bit. If the sign
; is still negative, decrement qhat and add the divisor once more.
; Now the result will be correct.

        bt    qword[r14+16], 63         ; Test high order bit of dividend
        jnc   dsmd14

dsmd13: sub   r9, 1                     ; Decrement qhat

        mov   rax, [r14+8]              ; Get low order divisor quad
        add   [r14+24], rax             ; Add to low order dividend
        mov   rax, [r14]                ; Get high order divisor quad
        adc   [r14+16], rax             ; Add to high order dividend

; Test sign of result. If negative, repeat decrement and add procedure.

        bt    qword[r14+16], 63         ; Test high order bit of dividend
        jc    dsmd13

; Division is finished. Install quotient and determine signs.

dsmd14: mov   [r14+8], r9               ; Install quotient quad
        mov   qword[r14], 0             ; Zero high order quotient

; If sign flag is set, negate quotient and remainder (symmetric division).

dsmd15: btr   rbp, 0                    ; Test/clear sign flag
        jnc   dsmd17                    ; Branch if flag was clear

        not   qword[r14+8]              ; Negate quotient
        not   qword[r14]
        add   qword[r14+8], 1
        jnc   dsmd16
        add   qword[r14], 1

dsmd16: not   qword[r14+24]             ; Negate remainder
        not   qword[r14+16]
        add   qword[r14+24], 1
        jnc   dsmd17
        add   qword[r14+16], 1

dsmd17: nextm
datam

; Double relational operators

; d0= - ( d --- flag ) Replace double with true flag if it is equal to 0.

head    "d0=", rlto
dzeq:   dq  dzeq0
textm
dzeq0:  cmp   qword[r14], 0
        jnz   dzeq1
        cmp   qword[r14+8], 0
        jnz   dzeq1

        mov   qword[r14+8], -1
        jmp   dzeq2

dzeq1:  mov   qword[r14+8], 0
dzeq2:  add   r14, 8
        nextm
datam

; d0< - ( d --- flag ) Replace double with true flag if it is less than 0.

head    "d0<", rlto
dzls:   dq  dzls0
textm
dzls0:  bt    qword[r14], 63
        jnc   dzls1

        mov   qword[r14+8], -1
        jmp   dzls2

dzls1:  mov   qword[r14+8], 0
dzls2:  add   r14, 8
        nextm
datam

; d= - ( d1 d2 --- flag ) Replace the top two double quadwords with a true flag
; if they are equal, otherwise a false flag.

head    "d=", rlto
dequ:   dq  dequ0
textm
dequ0:  mov   rax, [r14+8]
        cmp   rax, [r14+24]
        jnz   dequ1
        mov   rax, [r14]
        cmp   rax, [r14+16]
        jnz   dequ1

        mov   qword[r14+24], -1
        jmp   dequ2

dequ1:  mov   qword[r14+24], 0
dequ2:  add   r14, 24
        nextm
datam

; d< - ( d1 d2 --- flag ) Replace the top two double quadwords with a true flag
; if the 1st is less than the 2nd, otherwise a false flag.

head    "d<", rlto
dlss:   dq  dlss0
textm
dlss0:  xor   rbp, rbp                  ; Clear flags register
        bt    qword[r14], 63            ; Test sign of 1st entry
        jnc   dlss1                     ; Branch if positive
        btc   rbp, 0                    ; Complement sign flag
dlss1:  bt    qword[r14+16], 63         ; Test sign of 2nd entry
        jnc   dlss2                     ; Branch if positive
        btc   rbp, 0                    ; Complement sign flag
dlss2:  btr   rbp, 0                    ; Test/clear sign flag
        jnc   dlss3                     ; If flag was clear, signs are the same
        mov   rbx, -1                   ; Set flag to true
        bt    qword[r14], 63            ; Test sign of 1st entry
        jnc   dlss5                     ; Return true flag if positive
        mov   rbx, 0                    ; Else return false flag
        jmp   dlss5

dlss3:  mov   rax, [r14]                ; Get 1st quad of 1st entry
        cmp   [r14+16], rax             ; Compare with 1st quad of 2nd entry
        jnz   dlss4                     ; Branch if not equal
        mov   rax, [r14+8]              ; Get 2nd quad of 1st entry
        cmp   [r14+24], rax             ; Compare with 2nd quad of 2nd entry
dlss4:  setl  bl                        ; Set flag for result
        neg   bl
        movsx rbx, bl

dlss5:  mov   [r14+24], rbx             ; Put flag on stack
        add   r14, 24                   ; Pop 3 quads
        nextm
datam

; du< - ( ud1 ud2 --- flag ) Replace the top two double quadwords with a true
; flag if the 1st unsigned double is less than the 2nd, otherwise return a
; false flag.

head    "du<", rlto
dulss:  dq  duls0
textm
duls0:  mov   rax, [r14+8]
        sub   [r14+24], rax
        mov   rax, [r14]
        sbb   [r14+16], rax
        sbb   rbx, rbx
        mov   [r14+24], rbx
        add   r14, 24
        nextm
datam

; sq>d - Sign extend a 64-bit integer to 128 bits.

head    "sq>d", nbco
sqtd:   dq  sqtd0
textm
sqtd0:  mov   rax, [r14]                ; Get single precision value
        cqo                             ; Sign-extend to rax:rdx
        sub   r14, 8
        mov   [r14], rdx                ; Push high order to stack
        nextm
datam

; d>sq - Convert a 128-bit integer to 64 bits. Throw error if number
; cannot be represented in 64 bits.

head    "d>sq", nbco
dtsq:   dq  dtsq0
textm
dtsq0:  bt    qword[r14], 63            ; Test sign bit
        setc  dl
        bt    qword[r14+8], 63          ; Test sign of low order quad
        setc  bl
        xor   bl, dl
        jnz   dtsq1

        neg   dl
        movsx rdx, dl
        cmp   [r14], rdx
        jz    dtsq2

dtsq1:  throwm 41

dtsq2:  add   r14, 8
        nextm
datam

; Output formatting words for double-quad operands

; pad - ( --- addr ) Return the address of a buffer for intermediate
; string processing. This buffer is not currently used by any predefined
; ANSI Standard Forth words. For the purposes of Forthx64 the buffer will
; be the hld buffer.

head    "pad"
xpad:   dq  xpad0
textm
xpad0:  lea   rdi, [hld0] 
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; Pictured Numeric Output

; The following words implement the ANSI Standard number output wordset.
; For pictured numeric output the hld buffer is used. Since the
; digits of an integer are developed from right to left, they are
; first placed in the buffer from left to right and then reverse ordered
; by #>.

; hold ( char --- ) Insert the character at the current location in the
; pictured output string initiated by <# in the hld buffer.
; Throw 91 if digs flag is not set.

head    "hold"
hold:   dq  hold0
textm
hold0:  mov   rdx, [r14]                ; Get character from stack
        add   r14, 8                    ; Pop the stack
        bt    qword[flgs0], 11          ; See if digs flag is set
        jc    hold1                     ; Branch if so

        throwm 91                       ; Throw error

hold1:  lea   rdi, [hld0]               ; Get address of hld buffer
        mov   rcx, [rdi]                ; Get output character count
        mov   [rdi+rcx+8], dl           ; Store character in buffer
        add   qword[rdi], 1             ; Increment character count
        nextm
datam

; #> ( ud --- c-addr u ) Clear system flag #11 and end pictured numeric
; output. Reverse order string in hld buffer and leave the address and
; byte count of the string on the stack. The unsigned double, ud,
; is presumed to be zero. If digs flag was not set, throw error 91.

head    "#>"
edig:   dq  edig0
textm
edig0:  btr   qword[flgs0], 11          ; Test/clear digs flag
        jc    edig1                     ; Branch if flag was set

        throwm 91                       ; Throw error

edig1:  lea   rdi, [hld0]               ; Get address of hld buffer
        mov   rsi, rdi                  ; Make copy
        add   rdi, 8                    ; Advance to string
        mov   rcx, [rsi]                ; Get output character count
        mov   r8, rcx                   ; Save two copies of count
        mov   r9, rcx
        shr   rcx, 1                    ; Halve count
        jz    edig3                     ; Branch if zero

        xor   rdx, rdx                  ; Zero high order index
edig2:  mov   al, [rdi+rdx]             ; Get high order byte
        mov   bl, [rsi+r8+7]            ; Get low order byte
        mov   [rdi+rdx], bl             ; Swap bytes
        mov   [rsi+r8+7], al
        add   rdx, 1                    ; Increment high order index
        sub   r8, 1                     ; Decrement low order index
        sub   rcx, 1                    ; Decrement half character count
        jnz   edig2                     ; Loop for character count

edig3:  mov   [r14+8], rdi              ; Return addr of string
        mov   [r14], r9                 ; Return length of string
        nextm
datam

; sign ( n --- ) Insert a minus sign at the current location in the
; hld buffer if the high order bit of n is set (n negative).
; Used after all digits have been converted. Throw 91 if digs flag is not set.

head    "sign"
sign:   dq  sign0
textm
sign0:  mov   rdx, [r14]                ; Get n from stack
        add   r14, 8                    ; Pop the stack
        bt    qword[flgs0], 11          ; See if digs flag is set
        jc    sign1                     ; Branch if so

        throwm 91                       ; Throw error

sign1:  bt    rdx, 63                   ; See if n is negative
        jnc   sign2                     ; Branch if not
        lea   rdi, [hld0]               ; Get address of hld buffer
        mov   rcx, [rdi]                ; Get output character count
        mov   byte[rdi+rcx+8], 45       ; Install minus sign in buffer
        add   qword[rdi], 1             ; Add one to character count
sign2:  nextm
datam

; # - ( ud1 --- ud2 ) Extract the lowest order digit from ud1, producing
; ud2, and install its ascii code in the output string. Increment the
; character count. If digs flag is not set, throw error 91.

head    "#"
dig:    dq  dig0
textm
dig0:   bt    qword[flgs0], 11          ; Test digs flag
        jc    dig1                      ; Branch if flag is set

        throwm 91                       ; Throw error

dig1:   mov   r8, [base0]               ; Get number base
        lea   rdi, [hld0]               ; Get addr of buffer
        mov   rcx, [rdi]                ; Get output character count
        lea   rsi, [nof0]               ; Get base addr of number output filter
        mov   rax, [r14]                ; Get high order stack quad
        xor   rdx, rdx                  ; Clear high order division register
        div   r8                        ; Divide by number base
        mov   [r14], rax                ; Return to stack
        mov   rax, [r14+8]              ; Get low order stack quad
        div   r8                        ; Divide by number base
        mov   [r14+8], rax              ; Return to stack
        mov   bl, [rsi+rdx]             ; Get ascii value of generated digit
        mov   [rdi+rcx+8], bl           ; Install in output string
        add   qword[rdi], 1             ; Add one the character count
        nextm
datam

; #s - ( ud1 --- ud2 ) Extract digits from ud1 and install the ascii code
; of each digit in turn in the output string until ud2 is zero. If digs flag
; is not set, throw error 91.

head    "#s"
digs:   dq  digs0
textm
digs0:  bt    qword[flgs0], 11          ; Test digs flag
        jc    digs1                     ; Branch if flag is set

        throwm 91                       ; Throw error

digs1:  xor   rbp, rbp                  ; Zero flags register
        mov   r8, [base0]               ; Get number base
        lea   rdi, [hld0]               ; Get addr of buffer
        mov   rcx, [rdi]                ; Get character count/index
        lea   rsi, [nof0]               ; Get base addr of number output filter
        btr   rbp, 0                    ; Clear non-zero quotient flag

digs2:  mov   rax, [r14]                ; Get high order stack quad
        xor   rdx, rdx                  ; Clear high order division register
        div   r8                        ; Divide by number base
        mov   [r14], rax                ; Return to stack
        test  rax, rax                  ; Test for zero quotient
        jz    digs3                     ; Jmp if quotient is zero
        bts   rbp, 0                    ; Set non-zero quotient flag

digs3:  mov   rax, [r14+8]              ; Get low order stack quad
        div   r8                        ; Divide by number base
        mov   [r14+8], rax              ; Return to stack
        test  rax, rax                  ; Test for zero quotient
        jz    digs4                     ; Jmp if quotient is zero
        bts   rbp, 0                    ; Set non-zero quotient flag

digs4:  mov   bl, byte[rsi+rdx]         ; Get ascii value of generated digit
        mov   byte[rdi+rcx+8], bl       ; Install in output string
        add   rcx, 1                    ; Increment index
        btr   rbp, 0                    ; Test and clear zero-quotient flag
        jnc   digs5                     ; Done if quotient is zero

        jmp   digs2                     ; Else continue

digs5:  mov   [rdi], rcx                ; Install new character count
        nextm
datam

; <# - ( --- ) Set flag #11, clear output character count, and begin pictured
; numeric output.

head    "<#"
bdig:   dq  bdig0
textm
bdig0:  bts   qword[flgs0], 11
        lea   rdi, [hld0]               ; Get address of hld buffer
        mov   qword[rdi], 0             ; Zero character count
        nextm
datam

; d. - Output the double quad integer on the top of the stack.

; : d.   2 ckstk over slide over dabs <# #s rot sign #> type space ;

head    "d.", hlfo
ddot:   dq  docl0
        dq  two,ckstk
        dq  over,slide,over,dabs,bdig,digs,
        dq  rot,sign,edig,strout,space,semis

; d.r - ( n --- ) Output the double quad integer on the top of the stack, right
; justified in a field n characters wide.

; : d.r   2 ckstk >a over slide over dabs <# #s rot sign #>
;         a> over - padchrs strout space ;

head    "d.r", hlfo
ddotr:  dq  docl0
        dq  two,ckstk
        dq  toa,over,slide,over,dabs,bdig,digs,
        dq  rot,sign,edig,froma,over,minus
        dq  padcs,strout,space,semis

; ud. - Output as unsigned, the double quad integer on the top of the stack.

; : ud.   2 ckstk <# #s #> type space ;

head    "ud.", hlfo
uddt:   dq  docl0
        dq  two,ckstk
        dq  bdig,digs,edig,strout,space,semis

; Triple-quad Operators

; 3,

head    "3,", cmpo
tcomma: dq  tcom0
textm
tcom0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rax, [r14]                ; Move triplequad to dictionary
        mov   [rdi], rax
        mov   rax, [r14+8]
        mov   [rdi+8], rax
        mov   rax, [r14+16]
        mov   [rdi+16], rax
        add   r14, 24                   ; Pop the stack
        add   qword[dspo0], 24          ; Advance dsp
        nextm
datam

; 3literal - compile a triplequad literal

head    "3literal", -hlfo
tlite:  dq  docl0
        dq  pcomp,tlit,tcomma,semis
tlit:   dq  tlit0
textm
tlit0:  sub   r14, 24                   ; Make room on stack
        mov   rax, [r12]
        mov   [r14], rax
        mov   rax, [r12+8]
        mov   [r14+8], rax
        mov   rax, [r12+16]
        mov   [r14+16], rax
        add   r12, 24                   ; Advance IP past literal
        nextm
datam

; 3constant

head    "3constant", hlfo
tcons:  dq  docl0
        dq  three, ckstk
        dq  dfine,lit,tcno,objcom,pcomm,tcon0
        dq  tcomma,oszcom,semis
textm
tcon0:  sub   r14, 24                   ; Make room on stack
        mov   rax, [r11+8]
        mov   [r14], rax
        mov   rax, [r11+16]
        mov   [r14+8], rax
        mov   rax, [r11+24]
        mov   [r14+16], rax
        nextm
datam

; 3variable

head    "3variable", hlfo
tvar:   dq  docl0
        dq  dfine,lit,tvro,objcom,pcomm,vari0
        dq  zero,zero,zero,tcomma,oszcom,semis

; 3array - Create an array of n 192-bit elements. ( n --- ).
; Arrays are 1-based. Passed an element number from 1 to the maximum, returns the
; the address of that element. Throws an error if the index is out of bounds.
; If passed a negative number or zero, returns the array base address and the number
; of elements it contains.
;
; Array structure (header not shown):

; | code field | number of elements | elements ... |

head    "3array", hlfo
tarra:  dq  docl0
        dq  one,ckstk
        dq  dfine,lit,taro,objcom,pcomm,tarr0
        dq  dupl,comma,here,over,lit,24,star,allot
        dq  swp,zero,qfill,oszcom,semis
textm
tarr0:  mov   rax, [r14]                ; Get array index
        cmp   rax, 0
        jg    tarr1                     ; Branch if not zero or below

        lea   rdi, [r11+16]             ; Get array base address
        mov   [r14], rdi                ; Return to stack
        mov   rax, [r11+8]              ; Get number of elements
        sub   r14, 8
        mov   [r14], rax                ; Push to stack
        jmp   tarr3                     ; Branch to exit

tarr1:  cmp   [r11+8], rax              ; See if index is in bounds
        jnc   tarr2                     ; Branch if so

        throwm 14                       ; Else throw index out of bounds

tarr2:  sub   rax, 1                    ; Arrays are 1-based
        mov   rbx, rax                  ; Make copy
        shl   rax, 4                    ; Multiply by sixteen
        shl   rbx, 3                    ; Multiply by eight
        add   rax, rbx                  ; Add
        lea   rdi, [r11+rax+16]         ; Load address of element
        mov   [r14], rdi                ; Return address of element
tarr3:  nextm
datam

; 3@

head    "3@", memo
tqat:   dq  tqat0
textm
tqat0:  mov   rdi, [r14]
        sub   r14, 16
        mov   rax, [rdi]
        mov   [r14], rax
        mov   rax, [rdi+8]
        mov   [r14+8], rax
        mov   rax, [rdi+16]
        mov   [r14+16], rax
        nextm
datam

; 3!

head    "3!", memo
tstor:  dq  tsto0
textm

tsto0:  mov   rdi, [r14]
        mov   rax, [r14+8]
        mov   [rdi], rax
        mov   rax, [r14+16]
        mov   [rdi+8], rax
        mov   rax, [r14+24]
        mov   [rdi+16], rax
        add   r14, 32
        nextm
datam

; 3>a

head    "3>a", stko
ttoa:   dq  ttoa0
textm
ttoa0:  sub   r13, 24
        mov   rax, [r14]
        mov   [r13], rax
        mov   rax, [r14+8]
        mov   [r13+8], rax
        mov   rax, [r14+16]
        mov   [r13+16], rax
        add   r14, 24
        nextm
datam

; 3a>

head    "3a>", stko
tfrma:  dq  tfma0
textm
tfma0:  sub   r14, 24
        mov   rax, [r13]
        mov   [r14], rax
        mov   rax, [r13+8]
        mov   [r14+8], rax
        mov   rax, [r13+16]
        mov   [r14+16], rax
        add   r13, 24
        nextm
datam

; 3a!

head    "3a!", stko
tast:   dq  tast0
textm
tast0:  sub   r13, 24
        mov   rax, [r14]
        mov   [r13], rax
        mov   rax, [r14+8]
        mov   [r13+8], rax
        mov   rax, [r14+16]
        mov   [r13+16], rax
        nextm
datam

; 3a@

head    "3a@", stko
taat:   dq  taat0
textm
taat0:  sub   r14, 24
        mov   rax, [r13]
        mov   [r14], rax
        mov   rax, [r13+8]
        mov   [r14+8], rax
        mov   rax, [r13+16]
        mov   [r14+16], rax
        nextm
datam

; 3adrop ( A: t --- ) Discard the top triple-quad item from the auxiliary
; stack.

head    "3adrop", stko
tadrp:  dq  tadr0
textm
tadr0:  add   r13, 24
        nextm
datam

; 3apick - ( n --- t[An] ) Copy the nth triple-quad item from the auxiliary
; stack to the data stack. Zero based.

head    "3apick", stko
tapck:  dq  tapk0
textm
tapk0:  mov   rdi, [r14]
        shl   rdi, 1
        add   rdi, [r14]
        sub   r14, 16
        mov   rax, [r13+rdi*8]
        mov   [r14], rax
        mov   rax, [r13+rdi*8+8]
        mov   [r14+8], rax
        mov   rax, [r13+rdi*8+16]
        mov   [r14+16], rax
        nextm
datam

; 3axch - ( S: t[S] n --- t[n] ) ( A: t[n+1],t[S],t[n-1],---, t0 ) Swap the top
; triple-quad data stack entry with the auxiliary stack entry whose number is
; passed on the data stack. Zero based.

head    "3axch", stko
taxch:  dq  taxc0
textm
taxc0:  mov   rdi, [r14]                ; Get entry number
        shl   rdi, 1                    ; Double it
        add   rdi, [r14]                ; Triple it
        add   r14, 8                    ; Pop stack

        mov   rax, [r14]                ; Exchange quads
        mov   rbx, [r13+rdi*8]
        mov   [r14], rbx
        mov   [r13+rdi*8], rax

        mov   rax, [r14+8]
        mov   rbx, [r13+rdi*8+8]
        mov   [r14+8], rbx
        mov   [r13+rdi*8+8], rax

        mov   rax, [r14+16]
        mov   rbx, [r13+rdi*8+16]
        mov   [r14+16], rbx
        mov   [r13+rdi*8+16], rax
        nextm
datam

; 3areplace - ( S: t[S0] n --- ) ( A: t[n+1] t[n] t[n-1] ... t[0] --- 
; t[n+1] t[S0] t[n-1] ... t[0] )  Replace the nth triple-quad auxiliary
; stack item with the single-quad item on top of the data stack.
; Zero based.

head    "3areplace", stko
tarpl:  dq  tarp0
textm
tarp0:  mov   rdi, [r14]
        shl   rdi, 1
        add   rdi, [r14]
        mov   rax, [r14+8]
        mov   [r13+rdi*8], rax
        mov   rax, [r14+16]
        mov   [r13+rdi*8+8], rax
        mov   rax, [r14+24]
        mov   [r13+rdi*8+16], rax
        add   r14, 32
        nextm
datam

; 3drop

head    "3drop", stko
tdrop:  dq  tdrp0
textm
tdrp0:  add   r14, 24
        nextm
datam

; 3dup

head    "3dup", stko
tdup:   dq  tdup0
textm
tdup0:  sub   r14, 24
        mov   rax, [r14+24]
        mov   [r14], rax
        mov   rax, [r14+32]
        mov   [r14+8], rax
        mov   rax, [r14+40]
        mov   [r14+16], rax
        nextm
datam

; 3swap

head    "3swap", stko
tswap:  dq  tswp0
textm
tswp0:  mov   rax, [r14]
        mov   rbx, [r14+24]
        mov   [r14], rbx
        mov   [r14+24], rax

        mov   rax, [r14+8]
        mov   rbx, [r14+32]
        mov   [r14+8], rbx
        mov   [r14+32], rax

        mov   rax, [r14+16]
        mov   rbx, [r14+40]
        mov   [r14+16], rbx
        mov   [r14+40], rax
        nextm
datam

; 3over

head    "3over", stko
tover:  dq  tovr0
textm
tovr0:  sub   r14, 24
        mov   rax, [r14+48]
        mov   [r14], rax
        mov   rax, [r14+56]
        mov   [r14+8], rax
        mov   rax, [r14+64]
        mov   [r14+16], rax
        nextm
datam

; 3tuck

head    "3tuck", stko
ttuck:  dq  ttck0
textm
ttck0:  sub   r14, 24

        mov   rax, [r14+24]
        mov   rbx, [r14+48]
        mov   [r14], rax
        mov   [r14+24], rbx
        mov   [r14+48], rax

        mov   rax, [r14+32]
        mov   rbx, [r14+56]
        mov   [r14+8], rax
        mov   [r14+32], rbx
        mov   [r14+56], rax

        mov   rax, [r14+40]
        mov   rbx, [r14+64]
        mov   [r14+16], rax
        mov   [r14+40], rbx
        mov   [r14+64], rax
        nextm
datam

; 3rot ( n1 n2 n3 --- n2 n3 n1 )

head    "3rot", stko
trot:   dq  trot0
textm
trot0:  mov   rax, [r14]                ; Get 3rd entry
        mov   rbx, [r14+24]             ; Get 2nd entry
        mov   rcx, [r14+48]             ; Get 1st entry
        mov   [r14], rcx                ; Make 3rd entry 1st
        mov   [r14+24], rax             ; Make 2nd entry 3rd
        mov   [r14+48], rbx             ; Make 1st entry 2nd

        mov   rax, [r14+8]
        mov   rbx, [r14+32]
        mov   rcx, [r14+56]
        mov   [r14+8], rcx
        mov   [r14+32], rax
        mov   [r14+56], rbx

        mov   rax, [r14+16]
        mov   rbx, [r14+40]
        mov   rcx, [r14+64]
        mov   [r14+16], rcx
        mov   [r14+40], rax
        mov   [r14+64], rbx
        nextm
datam

; 3brot ( n1 n2 n3 --- n3 n1 n2 )

head    "3brot", stko
tbrot:  dq  tbrt0
textm
tbrt0:  mov   rax, [r14]                ; Get 3rd entry
        mov   rbx, [r14+24]             ; Get 2nd entry
        mov   rcx, [r14+48]             ; Get 1st entry
        mov   [r14], rbx                ; Make 3rd entry 2nd
        mov   [r14+24], rcx             ; Make 2nd entry 1st
        mov   [r14+48], rax             ; Make 1st entry 3rd

        mov   rax, [r14+8]
        mov   rbx, [r14+32]
        mov   rcx, [r14+56]
        mov   [r14+8], rbx
        mov   [r14+32], rcx
        mov   [r14+56], rax

        mov   rax, [r14+16]
        mov   rbx, [r14+40]
        mov   rcx, [r14+64]
        mov   [r14+16], rbx
        mov   [r14+40], rcx
        mov   [r14+64], rax
        nextm
datam

; 3slip ( n1 n2 --- n2 )

head    "3slip", stko
tslip:  dq  tslp0
textm
tslp0:  mov   rax, [r14]
        mov   [r14+24], rax
        mov   rax, [r14+8]
        mov   [r14+32], rax
        mov   rax, [r14+16]
        mov   [r14+40], rax
        add   r14, 24
        nextm
datam

; 3slide ( n1 n2 n3 --- n2 n3 )

head    "3slide", stko
tslid:  dq  tsld0
textm
tsld0:  mov   rax, [r14+24]
        mov   [r14+48], rax
        mov   rax, [r14+32]
        mov   [r14+56], rax
        mov   rax, [r14+40]
        mov   [r14+64], rax

        mov   rax, [r14]
        mov   [r14+24], rax
        mov   rax, [r14+8]
        mov   [r14+32], rax
        mov   rax, [r14+16]
        mov   [r14+40], rax
        add   r14, 24
        nextm
datam

; 3pick

head    "3pick", stko
tpick:  dq  tpck0
textm
tpck0:  mov   rdi, [r14]
        shl   rdi, 1
        add   rdi, [r14]
        sub   r14, 16
        mov   rax, [r14+rdi*8+24]
        mov   [r14], rax
        mov   rax, [r14+rdi*8+32]
        mov   [r14+8], rax
        mov   rax, [r14+rdi*8+40]
        mov   [r14+16], rax
        nextm
datam

; 3xch - ( n --- ) - Swap the top triplequad entry with the triplequad
;                   entry whose number is passed on the stack.

head    "3xch", stko
txch:   dq  txch0
textm
txch0:  mov   rdi, [r14]                ; Get entry number
        shl   rdi, 1                    ; Double it
        add   rdi, [r14]                ; Triple it
        add   r14, 8                    ; Pop stack

        mov   rax, [r14]                ; Exchange quads
        mov   rbx, [r14+rdi*8]
        mov   [r14], rbx
        mov   [r14+rdi*8], rax

        mov   rax, [r14+8]
        mov   rbx, [r14+rdi*8+8]
        mov   [r14+8], rbx
        mov   [r14+rdi*8+8], rax

        mov   rax, [r14+16]
        mov   rbx, [r14+rdi*8+16]
        mov   [r14+16], rbx
        mov   [r14+rdi*8+16], rax
        nextm
datam

; 3replace

head    "3replace", stko
trplc:  dq  trpl0
textm
trpl0:  mov   rdi, [r14]
        shl   rdi, 1
        add   rdi, [r14]
        mov   rax, [r14+8]
        mov   [r14+rdi*8+32], rax
        mov   rax, [r14+16]
        mov   [r14+rdi*8+40], rax
        mov   rax, [r14+24]
        mov   [r14+rdi*8+48], rax
        add   r14, 32
        nextm
datam

; 3pluck
; Do nothing if argument is zero or negative.

head    "3pluck", stko
tpluck: dq  tplk0
textm
tplk0:  mov   rdi, [r14]
        mov   rsi, rdi
        add   r14, 8
        cmp   rdi, 0                    ; Drop argument if it
        jle   tplk2                     ; is zero or negative

        shl   rdi, 1
        add   rdi, rsi
        mov   rax, [r14+rdi*8]          ; Copy item to registers
        mov   rbx, [r14+rdi*8+8]
        mov   rcx, [r14+rdi*8+16]

tplk1:  mov   rsi, [r14+rdi*8-8]        ; Close the gap
        mov   [r14+rdi*8+16], rsi
        mov   rsi, [r14+rdi*8-16]
        mov   [r14+rdi*8+8], rsi
        mov   rsi, [r14+rdi*8-24]
        mov   [r14+rdi*8], rsi
        sub   rdi, 3
        jnz   tplk1

        mov   [r14], rax                ; Put item on top of stack
        mov   [r14+8], rbx
        mov   [r14+16], rcx

tplk2:  nextm
datam

; 3poke
; Do nothing if argument is zero or negative.

head    "3poke", stko
tpoke:  dq  tpok0
textm
tpok0:  mov   r9, [r14]                 ; Get stack position
        add   r14, 8                    ; Pop stack
        cmp   r9, 0                     ; Drop argument if it
        jle   tpok2                     ; is zero or negative

        mov   rax, [r14]                ; Save new item in registers
        mov   rbx, [r14+8]
        mov   rcx, [r14+16]

        lea   rdi, [r14+24]             ; Offset to 2nd triplequad
        xor   r8, r8                    ; Zero index register

tpok1:  mov   rsi, [rdi+r8*8]           ; Open slot for new triplequad
        mov   [r14+r8*8], rsi
        mov   rsi, [rdi+r8*8+8]
        mov   [r14+r8*8+8], rsi
        mov   rsi, [rdi+r8*8+16]
        mov   [r14+r8*8+16], rsi

        add   r8, 3
        sub   r9, 1
        jnz   tpok1

        mov   [r14+r8*8], rax
        mov   [r14+r8*8+8], rbx
        mov   [r14+r8*8+16], rcx
tpok2:  nextm
datam

; Quadruple-quad Operators

; 4,

head    "4,", cmpo
qcomma: dq  qcom0
textm
qcom0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rax, [r14]                ; Move quadquad to dictionary
        mov   [rdi], rax
        mov   rax, [r14+8]
        mov   [rdi+8], rax
        mov   rax, [r14+16]
        mov   [rdi+16], rax
        mov   rax, [r14+24]
        mov   [rdi+24], rax
        add   r14, 32                   ; Pop the stack
        add   qword[dspo0], 32          ; Advance dsp
        nextm
datam

; 4literal - compile a quadquad literal

head    "4literal", -hlfo
qlite:  dq  docl0
        dq  pcomp,qlit,qcomma,semis
qlit:   dq  qlit0
textm
qlit0:  sub   r14, 32                   ; Make room on stack
        mov   rax, [r12]
        mov   [r14], rax
        mov   rax, [r12+8]
        mov   [r14+8], rax
        mov   rax, [r12+16]
        mov   [r14+16], rax
        mov   rax, [r12+24]
        mov   [r14+24], rax
        add   r12, 32                   ; Advance IP past literal
        nextm
datam

; 4constant

head    "4constant", hlfo
qcons:  dq  docl0
        dq  four,ckstk
        dq  dfine,lit,qcno,objcom,pcomm,qcon0
        dq  qcomma,oszcom,semis
textm
qcon0:  sub   r14, 32                   ; Make room on stack
        mov   rax, [r11+8]
        mov   [r14], rax
        mov   rax, [r11+16]
        mov   [r14+8], rax
        mov   rax, [r11+24]
        mov   [r14+16], rax
        mov   rax, [r11+32]
        mov   [r14+24], rax
        nextm
datam

; 4variable

head    "4variable", hlfo
qvar:   dq  docl0
        dq  dfine,lit,qvro,objcom,pcomm,vari0
        dq  zero,zero,zero,zero,qcomma,oszcom,semis

; 4array - Create an array of n 256-bit elements. ( n --- ).
; Arrays are 1-based. Passed an element number from 1 to the maximum, returns the
; the address of that element. Throws an error if the index is out of bounds.
; If passed a negative number or zero, returns the array base address and the number
; of elements it contains.
;
; Array structure (header not shown):

; | code field | number of elements | elements ... |

head    "4array", hlfo
qarra:  dq  docl0
        dq  one,ckstk
        dq  dfine,lit,qaro,objcom,pcomm,qarr0
        dq  dupl,comma,here,over,thtst,allot
        dq  swp,zero,qfill,oszcom,semis
textm
qarr0:  mov   rax, [r14]                ; Get array index
        cmp   rax, 0
        jg    qarr1                     ; Branch if not zero or below

        lea   rdi, [r11+16]             ; Get array base address
        mov   [r14], rdi                ; Return to stack
        mov   rax, [r11+8]              ; Get number of elements
        sub   r14, 8
        mov   [r14], rax                ; Push to stack
        jmp   qarr3                     ; Branch to exit

qarr1:  cmp   [r11+8], rax              ; See if index is in bounds
        jnc   qarr2                     ; Branch if so

        throwm 14                       ; Else throw index out of bounds

qarr2:  sub   rax, 1                    ; Arrays are 1-based
        shl   rax, 5                    ; Multiply by thirty-two
        lea   rdi, [r11+rax+16]         ; Load address of element
        mov   [r14], rdi                ; Return address of element
qarr3:  nextm
datam

head    "4@", memo
qqat:   dq  qqat0
textm
qqat0:  mov   rdi, [r14]
        sub   r14, 24
        mov   rax, [rdi]
        mov   [r14], rax
        mov   rax, [rdi+8]
        mov   [r14+8], rax
        mov   rax, [rdi+16]
        mov   [r14+16], rax
        mov   rax, [rdi+24]
        mov   [r14+24], rax
        nextm
datam

; 4!

head    "4!", memo
qstor:  dq  qsto0
textm
qsto0:  mov   rdi, [r14]
        mov   rax, [r14+8]
        mov   [rdi], rax
        mov   rax, [r14+16]
        mov   [rdi+8], rax
        mov   rax, [r14+24]
        mov   [rdi+16], rax
        mov   rax, [r14+32]
        mov   [rdi+24], rax
        add   r14, 40
        nextm
datam

; 4>a

head    "4>a", stko
qtoa:   dq  qtoa0
textm
qtoa0:  sub   r13, 32
        mov   rax, [r14]
        mov   [r13], rax
        mov   rax, [r14+8]
        mov   [r13+8], rax
        mov   rax, [r14+16]
        mov   [r13+16], rax
        mov   rax, [r14+24]
        mov   [r13+24], rax
        add   r14, 32
        nextm
datam

; 4a>

head    "4a>", stko
qfroma: dq  qfma0
textm
qfma0:  sub   r14, 32
        mov   rax, [r13]
        mov   [r14], rax
        mov   rax, [r13+8]
        mov   [r14+8], rax
        mov   rax, [r13+16]
        mov   [r14+16], rax
        mov   rax, [r13+24]
        mov   [r14+24], rax
        add   r13, 32
        nextm
datam

; 4a!

head    "4a!", stko
qast:   dq  qast0
textm
qast0:  sub   r13, 32
        mov   rax, [r14]
        mov   [r13], rax
        mov   rax, [r14+8]
        mov   [r13+8], rax
        mov   rax, [r14+16]
        mov   [r13+16], rax
        mov   rax, [r14+24]
        mov   [r13+24], rax
        nextm
datam

; 4a@

head    "4a@", stko
qaat:   dq  qaat0
textm
qaat0:  sub   r14, 32
        mov   rax, [r13]
        mov   [r14], rax
        mov   rax, [r13+8]
        mov   [r14+8], rax
        mov   rax, [r13+16]
        mov   [r14+16], rax
        mov   rax, [r13+24]
        mov   [r14+24], rax
        nextm
datam

; 4adrop ( A: q --- ) Discard the top quadruple-quad item from the auxiliary
; stack.

head    "4adrop", stko
qadrp:  dq  qadr0
textm
qadr0:  add   r13, 32
        nextm
datam

; 4apick - ( n --- q[An] ) Copy the nth quadruple-quad item from the auxiliary
; stack to the data stack. Zero based.

head    "4apick", stko
qapck:  dq  qapk0
textm
qapk0:  mov   rdi, [r14]
        shl   rdi, 2
        sub   r14, 24
        mov   rax, [r13+rdi*8]
        mov   [r14], rax
        mov   rax, [r13+rdi*8+8]
        mov   [r14+8], rax
        mov   rax, [r13+rdi*8+16]
        mov   [r14+16], rax
        mov   rax, [r13+rdi*8+24]
        mov   [r14+24], rax
        nextm
datam

; 4axch - ( S: q[S0] n --- q[An] ) ( A: q[n+1] q[n] q[n-1] ... q[0] --- 
; q[n+1] q[S0] q[n-1] ... q[0] ) Swap the top quadruple-quad stack entry
; with the auxiliary stack entry whose number is passed on the stack.
; Zero based.

head    "4axch", stko
qaxch:  dq  qaxc0
textm
qaxc0:  mov   rdi, [r14]                ; Get entry number
        add   r14, 8                    ; Pop stack
        shl   rdi, 2                    ; Quadruple number

        mov   rax, [r14]                ; Exchange quads
        mov   rbx, [r13+rdi*8]
        mov   [r14], rbx
        mov   [r13+rdi*8], rax

        mov   rax, [r14+8]
        mov   rbx, [r13+rdi*8+8]
        mov   [r14+8], rbx
        mov   [r13+rdi*8+8], rax

        mov   rax, [r14+16]
        mov   rbx, [r13+rdi*8+16]
        mov   [r14+16], rbx
        mov   [r13+rdi*8+16], rax

        mov   rax, [r14+24]
        mov   rbx, [r13+rdi*8+24]
        mov   [r14+24], rbx
        mov   [r13+rdi*8+24], rax
        nextm
datam

; 4areplace - ( S: q[S0] n --- ) ( A: q[n+1] q[n] q[n-1] ... q[0] --- 
; q[n+1] q[S0] q[n-1] ... q[0] )  Replace the nth quadruple-quad auxiliary
; stack item with the single-quad item on top of the data stack.
; Zero based.

head    "4areplace", stko
qarpl:  dq  qarp0
textm
qarp0:  mov   rdi, [r14]
        shl   rdi, 2
        mov   rax, [r14+8]
        mov   [r13+rdi*8], rax
        mov   rax, [r14+16]
        mov   [r13+rdi*8+8], rax
        mov   rax, [r14+24]
        mov   [r13+rdi*8+16], rax
        mov   rax, [r14+32]
        mov   [r13+rdi*8+24], rax
        add   r14, 40
        nextm
datam

; 4drop

head    "4drop", stko
qdrop:  dq  qdrp0
textm
qdrp0:  add   r14, 32
        nextm
datam

; 4dup

head    "4dup", stko
qdup:   dq  qdup0
textm
qdup0:  sub   r14, 32
        mov   rax, [r14+32]
        mov   [r14], rax
        mov   rax, [r14+40]
        mov   [r14+8], rax
        mov   rax, [r14+48]
        mov   [r14+16], rax
        mov   rax, [r14+56]
        mov   [r14+24], rax
        nextm
datam

; 4swap

head    "4swap", stko
qswap:  dq  qswp0
textm
qswp0:  mov   rax, [r14]
        mov   rbx, [r14+32]
        mov   [r14], rbx
        mov   [r14+32], rax

        mov   rax, [r14+8]
        mov   rbx, [r14+40]
        mov   [r14+8], rbx
        mov   [r14+40], rax

        mov   rax, [r14+16]
        mov   rbx, [r14+48]
        mov   [r14+16], rbx
        mov   [r14+48], rax

        mov   rax, [r14+24]
        mov   rbx, [r14+56]
        mov   [r14+24], rbx
        mov   [r14+56], rax
        nextm
datam

; 4over

head    "4over", stko
qover:  dq  qovr0
textm
qovr0:  sub   r14, 32
        mov   rax, [r14+64]
        mov   [r14], rax
        mov   rax, [r14+72]
        mov   [r14+8], rax
        mov   rax, [r14+80]
        mov   [r14+16], rax
        mov   rax, [r14+88]
        mov   [r14+24], rax
        nextm
datam

; 4tuck

head    "4tuck", stko
qtuck:  dq  qtck0
textm
qtck0:  sub   r14, 32

        mov   rax, [r14+32]
        mov   rbx, [r14+64]
        mov   [r14], rax
        mov   [r14+32], rbx
        mov   [r14+64], rax

        mov   rax, [r14+40]
        mov   rbx, [r14+72]
        mov   [r14+8], rax
        mov   [r14+40], rbx
        mov   [r14+72], rax

        mov   rax, [r14+48]
        mov   rbx, [r14+80]
        mov   [r14+16], rax
        mov   [r14+48], rbx
        mov   [r14+80], rax

        mov   rax, [r14+56]
        mov   rbx, [r14+88]
        mov   [r14+24], rax
        mov   [r14+56], rbx
        mov   [r14+88], rax
        nextm
datam

; 4rot ( n1 n2 n3 --- n2 n3 n1 )

head    "4rot", stko
qrot:   dq  qrot0
textm
qrot0:  mov   rax, [r14]                ; Get 3rd entry
        mov   rbx, [r14+32]             ; Get 2nd entry
        mov   rcx, [r14+64]             ; Get 1st entry
        mov   [r14], rcx                ; Make 3rd entry 1st
        mov   [r14+32], rax             ; Make 2nd entry 3rd
        mov   [r14+64], rbx             ; Make 1st entry 2nd

        mov   rax, [r14+8]
        mov   rbx, [r14+40]
        mov   rcx, [r14+72]
        mov   [r14+8], rcx
        mov   [r14+40], rax
        mov   [r14+72], rbx

        mov   rax, [r14+16]
        mov   rbx, [r14+48]
        mov   rcx, [r14+80]
        mov   [r14+16], rcx
        mov   [r14+48], rax
        mov   [r14+80], rbx

        mov   rax, [r14+24]
        mov   rbx, [r14+56]
        mov   rcx, [r14+88]
        mov   [r14+24], rcx
        mov   [r14+56], rax
        mov   [r14+88], rbx
        nextm
datam

; 4brot ( n1 n2 n3 --- n3 n1 n2 )

head    "4brot", stko
qbrot:  dq  qbrt0
textm
qbrt0:  mov   rax, [r14]                ; Get 3rd entry
        mov   rbx, [r14+32]             ; Get 2nd entry
        mov   rcx, [r14+64]             ; Get 1st entry
        mov   [r14], rbx                ; Make 3rd entry 2nd
        mov   [r14+32], rcx             ; Make 2nd entry 1st
        mov   [r14+64], rax             ; Make 1st entry 3rd

        mov   rax, [r14+8]
        mov   rbx, [r14+40]
        mov   rcx, [r14+72]
        mov   [r14+8], rbx
        mov   [r14+40], rcx
        mov   [r14+72], rax

        mov   rax, [r14+16]
        mov   rbx, [r14+48]
        mov   rcx, [r14+80]
        mov   [r14+16], rbx
        mov   [r14+48], rcx
        mov   [r14+80], rax

        mov   rax, [r14+24]
        mov   rbx, [r14+56]
        mov   rcx, [r14+88]
        mov   [r14+24], rbx
        mov   [r14+56], rcx
        mov   [r14+88], rax
        nextm
datam

; 4slip ( n1 n2 --- n2 )

head    "4slip", stko
qslip:  dq  qslp0
textm
qslp0:  mov   rax, [r14]
        mov   [r14+32], rax
        mov   rax, [r14+8]
        mov   [r14+40], rax
        mov   rax, [r14+16]
        mov   [r14+48], rax
        mov   rax, [r14+24]
        mov   [r14+56], rax
        add   r14, 32
        nextm
datam

; 4slide ( n1 n2 n3 --- n2 n3 )

head    "4slide", stko
qslid:  dq  qsld0
textm
qsld0:  mov   rax, [r14+32]
        mov   [r14+64], rax
        mov   rax, [r14+40]
        mov   [r14+72], rax
        mov   rax, [r14+48]
        mov   [r14+80], rax
        mov   rax, [r14+56]
        mov   [r14+88], rax

        mov   rax, [r14]
        mov   [r14+32], rax
        mov   rax, [r14+8]
        mov   [r14+40], rax
        mov   rax, [r14+16]
        mov   [r14+48], rax
        mov   rax, [r14+24]
        mov   [r14+56], rax
        add   r14, 32
        nextm
datam

; 4pick

head    "4pick", stko
qpick:  dq  qpck0
textm
qpck0:  mov   rdi, [r14]
        shl   rdi, 2
        sub   r14, 24
        mov   rax, [r14+rdi*8+32]
        mov   [r14], rax
        mov   rax, [r14+rdi*8+40]
        mov   [r14+8], rax
        mov   rax, [r14+rdi*8+48]
        mov   [r14+16], rax
        mov   rax, [r14+rdi*8+56]
        mov   [r14+24], rax
        nextm
datam

; 4xch - ( n --- ) - Swap the top quadruple-quad entry with the quadruple-quad
; entry whose number is passed on the stack.

head    "4xch", stko
qxch:   dq  qxch0
textm
qxch0:  mov   rdi, [r14]                ; Get entry number
        add   r14, 8                    ; Pop stack
        shl   rdi, 2                    ; Quadruple number

        mov   rax, [r14]                ; Exchange quads
        mov   rbx, [r14+rdi*8]
        mov   [r14], rbx
        mov   [r14+rdi*8], rax

        mov   rax, [r14+8]
        mov   rbx, [r14+rdi*8+8]
        mov   [r14+8], rbx
        mov   [r14+rdi*8+8], rax

        mov   rax, [r14+16]
        mov   rbx, [r14+rdi*8+16]
        mov   [r14+16], rbx
        mov   [r14+rdi*8+16], rax

        mov   rax, [r14+24]
        mov   rbx, [r14+rdi*8+24]
        mov   [r14+24], rbx
        mov   [r14+rdi*8+24], rax
        nextm
datam

; 4replace

head    "4replace", stko
qrplc:  dq  qrpl0
textm
qrpl0:  mov   rdi, [r14]
        shl   rdi, 2
        mov   rax, [r14+8]
        mov   [r14+rdi*8+40], rax
        mov   rax, [r14+16]
        mov   [r14+rdi*8+48], rax
        mov   rax, [r14+24]
        mov   [r14+rdi*8+56], rax
        mov   rax, [r14+32]
        mov   [r14+rdi*8+64], rax
        add   r14, 40
        nextm
datam

; 4pluck
; Do nothing if argument is zero or negative.

head    "4pluck", stko
qpluck: dq  qplk0
textm
qplk0:  mov   rdi, [r14]
        add   r14, 8
        cmp   rdi, 0                    ; Drop argument if it
        jle   qplk2                     ; is zero or negative

        shl   rdi, 2
        mov   rax, [r14+rdi*8]          ; Copy item to registers
        mov   rbx, [r14+rdi*8+8]
        mov   rcx, [r14+rdi*8+16]
        mov   rdx, [r14+rdi*8+24]

qplk1:  mov   rsi, [r14+rdi*8-8]        ; Close the gap
        mov   [r14+rdi*8+24], rsi
        mov   rsi, [r14+rdi*8-16]
        mov   [r14+rdi*8+16], rsi
        mov   rsi, [r14+rdi*8-24]
        mov   [r14+rdi*8+8], rsi
        mov   rsi, [r14+rdi*8-32]
        mov   [r14+rdi*8], rsi
        sub   rdi, 4
        jnz   qplk1

        mov   [r14], rax                ; Put item on top of stack
        mov   [r14+8], rbx
        mov   [r14+16], rcx
        mov   [r14+24], rdx

qplk2:  nextm
datam

; 4poke
; Do nothing if argument is zero or negative.

head    "4poke", stko
qpoke:  dq  qpok0
textm
qpok0:  mov   r9, [r14]                 ; Get stack position
        add   r14, 8                    ; Pop stack
        cmp   r9, 0                     ; Drop argument if it
        jle   qpok2                     ; is zero or negative

        mov   rax, [r14]                ; Save new item in registers
        mov   rbx, [r14+8]
        mov   rcx, [r14+16]
        mov   rdx, [r14+24]

        lea   rdi, [r14+32]             ; Offset to 2nd quadquad
        xor   r8, r8                    ; Zero index register

qpok1:  mov   rsi, [rdi+r8*8]           ; Open slot for new quadquad
        mov   [r14+r8*8], rsi
        mov   rsi, [rdi+r8*8+8]
        mov   [r14+r8*8+8], rsi
        mov   rsi, [rdi+r8*8+16]
        mov   [r14+r8*8+16], rsi
        mov   rsi, [rdi+r8*8+24]
        mov   [r14+r8*8+24], rsi

        add   r8, 4
        sub   r9, 1
        jnz   qpok1

        mov   [r14+r8*8], rax
        mov   [r14+r8*8+8], rbx
        mov   [r14+r8*8+16], rcx
        mov   [r14+r8*8+24], rdx
qpok2:  nextm
datam

; Octa-quad Operators

; 8,

head    "8,", cmpo
ocomma: dq  ocom0
textm
ocom0:  mov   rdi, [dspo0]              ; Get dsp
        mov   rax, [r14]                ; Move quadquad to dictionary
        mov   [rdi], rax
        mov   rax, [r14+8]
        mov   [rdi+8], rax
        mov   rax, [r14+16]
        mov   [rdi+16], rax
        mov   rax, [r14+24]
        mov   [rdi+24], rax
        mov   rax, [r14+32]
        mov   [rdi+32], rax
        mov   rax, [r14+40]
        mov   [rdi+40], rax
        mov   rax, [r14+48]
        mov   [rdi+48], rax
        mov   rax, [r14+56]
        mov   [rdi+56], rax
        add   r14, 64                   ; Pop the stack
        add   qword[dspo0], 64          ; Advance dsp
        nextm
datam

; 8literal - compile an octaquad literal

head    "8literal", -hlfo
olite:  dq  docl0
        dq  pcomp,olit,ocomma,semis
olit:   dq  olit0
textm
olit0:  sub   r14, 64                   ; Make room on stack
        mov   rax, [r12]
        mov   [r14], rax
        mov   rax, [r12+8]
        mov   [r14+8], rax
        mov   rax, [r12+16]
        mov   [r14+16], rax
        mov   rax, [r12+24]
        mov   [r14+24], rax
        mov   rax, [r12+32]
        mov   [r14+32], rax
        mov   rax, [r12+40]
        mov   [r14+40], rax
        mov   rax, [r12+48]
        mov   [r14+48], rax
        mov   rax, [r12+56]
        mov   [r14+56], rax
        add   r12, 64                   ; Advance IP past literal
        nextm
datam

; 8constant

head    "8constant", hlfo
ocons:  dq  docl0
        dq  eight,ckstk
        dq  dfine,lit,ocno,objcom,pcomm,ocon0
        dq  ocomma,oszcom,semis
textm
ocon0:  sub   r14, 64                   ; Make room on stack
        mov   rax, [r11+8]
        mov   [r14], rax
        mov   rax, [r11+16]
        mov   [r14+8], rax
        mov   rax, [r11+24]
        mov   [r14+16], rax
        mov   rax, [r11+32]
        mov   [r14+24], rax
        mov   rax, [r11+40]
        mov   [r14+32], rax
        mov   rax, [r11+48]
        mov   [r14+40], rax
        mov   rax, [r11+56]
        mov   [r14+48], rax
        mov   rax, [r11+64]
        mov   [r14+56], rax
        nextm
datam

; 8variable

head    "8variable", hlfo
ovar:   dq  docl0
        dq  dfine,lit,ovro,objcom,pcomm,vari0
        dq  zero,zero,zero,zero,zero,zero,zero,zero
        dq  ocomma,oszcom,semis

; 8array - Create an array of n 512-bit elements. ( n --- ).
; Arrays are 1-based. Passed an element number from 1 to the maximum, returns the
; the address of that element. Throws an error if the index is out of bounds.
; If passed a negative number or zero, returns the array base address and the number
; of elements it contains.
;
; Array structure (header not shown):

; | code field | number of elements | elements ... |

head    "8array", hlfo
oarra:  dq  docl0
        dq  one,ckstk
        dq  dfine,lit,oaro,objcom,pcomm,oarr0
        dq  dupl,comma,here,over,sfstr,allot
        dq  swp,zero,qfill,oszcom,semis
textm
oarr0:  mov   rax, [r14]                ; Get array index
        cmp   rax, 0
        jg    oarr1                     ; Branch if not zero or below

        lea   rdi, [r11+16]             ; Get array base address
        mov   [r14], rdi                ; Return to stack
        mov   rax, [r11+8]              ; Get number of elements
        sub   r14, 8
        mov   [r14], rax                ; Push to stack
        jmp   oarr3                     ; Branch to exit

oarr1:  cmp   [r11+8], rax              ; See if index is in bounds
        jnc   oarr2                     ; Branch if so

        throwm 14                       ; Else throw index out of bounds

oarr2:  sub   rax, 1                    ; Arrays are 1-based
        shl   rax, 6                    ; Multiply by sixty-four
        lea   rdi, [r11+rax+16]         ; Load address of element
        mov   [r14], rdi                ; Return address of element
oarr3:  nextm
datam

head    "8@", memo
oqat:   dq  oqat0
textm
oqat0:  mov   rdi, [r14]
        sub   r14, 56
        mov   rax, [rdi]
        mov   [r14], rax
        mov   rax, [rdi+8]
        mov   [r14+8], rax
        mov   rax, [rdi+16]
        mov   [r14+16], rax
        mov   rax, [rdi+24]
        mov   [r14+24], rax
        mov   rax, [rdi+32]
        mov   [r14+32], rax
        mov   rax, [rdi+40]
        mov   [r14+40], rax
        mov   rax, [rdi+48]
        mov   [r14+48], rax
        mov   rax, [rdi+56]
        mov   [r14+56], rax
        nextm
datam

; 8!

head    "8!", memo
ostor:  dq  osto0
textm
osto0:  mov   rdi, [r14]
        mov   rax, [r14+8]
        mov   [rdi], rax
        mov   rax, [r14+16]
        mov   [rdi+8], rax
        mov   rax, [r14+24]
        mov   [rdi+16], rax
        mov   rax, [r14+32]
        mov   [rdi+24], rax
        mov   rax, [r14+40]
        mov   [rdi+32], rax
        mov   rax, [r14+48]
        mov   [rdi+40], rax
        mov   rax, [r14+56]
        mov   [rdi+48], rax
        mov   rax, [r14+64]
        mov   [rdi+56], rax
        add   r14, 72
        nextm
datam

; 8>a

head    "8>a", stko
otoa:   dq  otoa0
textm
otoa0:  sub   r13, 64
        mov   rax, [r14]
        mov   [r13], rax
        mov   rax, [r14+8]
        mov   [r13+8], rax
        mov   rax, [r14+16]
        mov   [r13+16], rax
        mov   rax, [r14+24]
        mov   [r13+24], rax
        mov   rax, [r14+32]
        mov   [r13+32], rax
        mov   rax, [r14+40]
        mov   [r13+40], rax
        mov   rax, [r14+48]
        mov   [r13+48], rax
        mov   rax, [r14+56]
        mov   [r13+56], rax
        add   r14, 64
        nextm
datam

; 8a>

head    "8a>", stko
ofroma: dq  ofma0
textm
ofma0:  sub   r14, 64
        mov   rax, [r13]
        mov   [r14], rax
        mov   rax, [r13+8]
        mov   [r14+8], rax
        mov   rax, [r13+16]
        mov   [r14+16], rax
        mov   rax, [r13+24]
        mov   [r14+24], rax
        mov   rax, [r13+32]
        mov   [r14+32], rax
        mov   rax, [r13+40]
        mov   [r14+40], rax
        mov   rax, [r13+48]
        mov   [r14+48], rax
        mov   rax, [r13+56]
        mov   [r14+56], rax
        add   r13, 64
        nextm
datam

; 8a!

head    "8a!", stko
oast:   dq  oast0
textm
oast0:  sub   r13, 64
        mov   rax, [r14]
        mov   [r13], rax
        mov   rax, [r14+8]
        mov   [r13+8], rax
        mov   rax, [r14+16]
        mov   [r13+16], rax
        mov   rax, [r14+24]
        mov   [r13+24], rax
        mov   rax, [r14+32]
        mov   [r13+32], rax
        mov   rax, [r14+40]
        mov   [r13+40], rax
        mov   rax, [r14+48]
        mov   [r13+48], rax
        mov   rax, [r14+56]
        mov   [r13+56], rax
        nextm
datam

; 8a@

head    "8a@", stko
oaat:   dq  oaat0
textm
oaat0:  sub   r14, 64
        mov   rax, [r13]
        mov   [r14], rax
        mov   rax, [r13+8]
        mov   [r14+8], rax
        mov   rax, [r13+16]
        mov   [r14+16], rax
        mov   rax, [r13+24]
        mov   [r14+24], rax
        mov   rax, [r13+32]
        mov   [r14+32], rax
        mov   rax, [r13+40]
        mov   [r14+40], rax
        mov   rax, [r13+48]
        mov   [r14+48], rax
        mov   rax, [r13+56]
        mov   [r14+56], rax
        nextm
datam

; 8adrop ( A: o --- ) Discard the top octuple-quad item from the auxiliary
; stack.

head    "8adrop", stko
oadrp:  dq  oadr0
textm
oadr0:  add   r13, 64
        nextm
datam

; 8apick - ( n --- o[An] ) Copy the nth octuple-quad item from the auxiliary
; stack to the data stack. Zero based.

head    "8apick", stko
oapck:  dq  oapk0
textm
oapk0:  mov   rdi, [r14]
        shl   rdi, 3
        sub   r14, 56
        mov   rax, [r13+rdi*8]
        mov   [r14], rax
        mov   rax, [r13+rdi*8+8]
        mov   [r14+8], rax
        mov   rax, [r13+rdi*8+16]
        mov   [r14+16], rax
        mov   rax, [r13+rdi*8+24]
        mov   [r14+24], rax
        mov   rax, [r13+rdi*8+32]
        mov   [r14+32], rax
        mov   rax, [r13+rdi*8+40]
        mov   [r14+40], rax
        mov   rax, [r13+rdi*8+48]
        mov   [r14+48], rax
        mov   rax, [r13+rdi*8+56]
        mov   [r14+56], rax
        nextm
datam

; 8axch - ( S: o[S0] n --- o[An] ) ( A: o[n+1] o[n] o[n-1] ... o[0] --- 
; o[n+1] o[S0] o[n-1] ... o[0] ) Swap the top octuple-quad stack entry
; with the auxiliary stack entry whose number is passed on the stack.
; Zero based.

head    "8axch", stko
oaxch:  dq  oaxc0
textm
oaxc0:  mov   rdi, [r14]                ; Get entry number
        add   r14, 8                    ; Pop stack
        shl   rdi, 3                    ; Multiply index by 8

        mov   rax, [r14]                ; Exchange quads
        mov   rbx, [r13+rdi*8]
        mov   [r14], rbx
        mov   [r13+rdi*8], rax

        mov   rax, [r14+8]
        mov   rbx, [r13+rdi*8+8]
        mov   [r14+8], rbx
        mov   [r13+rdi*8+8], rax

        mov   rax, [r14+16]
        mov   rbx, [r13+rdi*8+16]
        mov   [r14+16], rbx
        mov   [r13+rdi*8+16], rax

        mov   rax, [r14+24]
        mov   rbx, [r13+rdi*8+24]
        mov   [r14+24], rbx
        mov   [r13+rdi*8+24], rax

        mov   rax, [r14+32]
        mov   rbx, [r13+rdi*8+32]
        mov   [r14+32], rbx
        mov   [r13+rdi*8+32], rax

        mov   rax, [r14+40]
        mov   rbx, [r13+rdi*8+40]
        mov   [r14+40], rbx
        mov   [r13+rdi*8+40], rax

        mov   rax, [r14+48]
        mov   rbx, [r13+rdi*8+48]
        mov   [r14+48], rbx
        mov   [r13+rdi*8+48], rax

        mov   rax, [r14+56]
        mov   rbx, [r13+rdi*8+56]
        mov   [r14+56], rbx
        mov   [r13+rdi*8+56], rax
        nextm
datam

; 8areplace - ( S: o[S0] n --- ) ( A: o[n+1] o[n] o[n-1] ... o[0] --- 
; o[n+1] o[S0] o[n-1] ... o[0] )  Replace the nth octuple-quad auxiliary
; stack item with the single-quad item on top of the data stack.
; Zero based.

head    "8areplace", stko
oarpl:  dq  oarp0
textm
oarp0:  mov   rdi, [r14]
        shl   rdi, 3
        mov   rax, [r14+8]
        mov   [r13+rdi*8], rax
        mov   rax, [r14+16]
        mov   [r13+rdi*8+8], rax
        mov   rax, [r14+24]
        mov   [r13+rdi*8+16], rax
        mov   rax, [r14+32]
        mov   [r13+rdi*8+24], rax
        mov   rax, [r14+40]
        mov   [r13+rdi*8+32], rax
        mov   rax, [r14+48]
        mov   [r13+rdi*8+40], rax
        mov   rax, [r14+56]
        mov   [r13+rdi*8+48], rax
        mov   rax, [r14+64]
        mov   [r13+rdi*8+56], rax
        add   r14, 72
        nextm
datam

; 8drop

head    "8drop", stko
odrop:  dq  odrp0
textm
odrp0:  add   r14, 64
        nextm
datam

; 8dup

head    "8dup", stko
odup:   dq  odup0
textm
odup0:  sub   r14, 64
        mov   rax, [r14+64]
        mov   [r14], rax
        mov   rax, [r14+72]
        mov   [r14+8], rax
        mov   rax, [r14+80]
        mov   [r14+16], rax
        mov   rax, [r14+88]
        mov   [r14+24], rax
        mov   rax, [r14+96]
        mov   [r14+32], rax
        mov   rax, [r14+104]
        mov   [r14+40], rax
        mov   rax, [r14+112]
        mov   [r14+48], rax
        mov   rax, [r14+120]
        mov   [r14+56], rax
        nextm
datam

; 8swap

head    "8swap", stko
oswap:  dq  oswp0
textm
oswp0:  mov   rax, [r14]
        mov   rbx, [r14+64]
        mov   [r14], rbx
        mov   [r14+64], rax

        mov   rax, [r14+8]
        mov   rbx, [r14+72]
        mov   [r14+8], rbx
        mov   [r14+72], rax

        mov   rax, [r14+16]
        mov   rbx, [r14+80]
        mov   [r14+16], rbx
        mov   [r14+80], rax

        mov   rax, [r14+24]
        mov   rbx, [r14+88]
        mov   [r14+24], rbx
        mov   [r14+88], rax

        mov   rax, [r14+32]
        mov   rbx, [r14+96]
        mov   [r14+32], rbx
        mov   [r14+96], rax

        mov   rax, [r14+40]
        mov   rbx, [r14+104]
        mov   [r14+40], rbx
        mov   [r14+104], rax

        mov   rax, [r14+48]
        mov   rbx, [r14+112]
        mov   [r14+48], rbx
        mov   [r14+112], rax

        mov   rax, [r14+56]
        mov   rbx, [r14+120]
        mov   [r14+56], rbx
        mov   [r14+120], rax
        nextm
datam

; 8over

head    "8over", stko
oover:  dq  oovr0
textm
oovr0:  sub   r14, 64
        mov   rax, [r14+128]
        mov   [r14], rax
        mov   rax, [r14+136]
        mov   [r14+8], rax
        mov   rax, [r14+144]
        mov   [r14+16], rax
        mov   rax, [r14+152]
        mov   [r14+24], rax
        mov   rax, [r14+160]
        mov   [r14+32], rax
        mov   rax, [r14+168]
        mov   [r14+40], rax
        mov   rax, [r14+176]
        mov   [r14+48], rax
        mov   rax, [r14+184]
        mov   [r14+56], rax
        nextm
datam

; 8tuck

head    "8tuck", stko
otuck:  dq  otck0
textm
otck0:  sub   r14, 64

        mov   rax, [r14+64]
        mov   rbx, [r14+128]
        mov   [r14], rax
        mov   [r14+64], rbx
        mov   [r14+128], rax

        mov   rax, [r14+72]
        mov   rbx, [r14+136]
        mov   [r14+8], rax
        mov   [r14+72], rbx
        mov   [r14+136], rax

        mov   rax, [r14+80]
        mov   rbx, [r14+144]
        mov   [r14+16], rax
        mov   [r14+80], rbx
        mov   [r14+144], rax

        mov   rax, [r14+88]
        mov   rbx, [r14+152]
        mov   [r14+24], rax
        mov   [r14+88], rbx
        mov   [r14+152], rax

        mov   rax, [r14+96]
        mov   rbx, [r14+160]
        mov   [r14+32], rax
        mov   [r14+96], rbx
        mov   [r14+160], rax

        mov   rax, [r14+104]
        mov   rbx, [r14+168]
        mov   [r14+40], rax
        mov   [r14+104], rbx
        mov   [r14+168], rax

        mov   rax, [r14+112]
        mov   rbx, [r14+176]
        mov   [r14+48], rax
        mov   [r14+112], rbx
        mov   [r14+176], rax

        mov   rax, [r14+120]
        mov   rbx, [r14+184]
        mov   [r14+56], rax
        mov   [r14+120], rbx
        mov   [r14+184], rax
        nextm
datam

; 8rot ( n1 n2 n3 --- n2 n3 n1 )

head    "8rot", stko
orot:   dq  orot0
textm
orot0:  mov   rax, [r14]                ; Get 3rd entry
        mov   rbx, [r14+64]             ; Get 2nd entry
        mov   rcx, [r14+128]            ; Get 1st entry
        mov   [r14], rcx                ; Make 3rd entry 1st
        mov   [r14+64], rax             ; Make 2nd entry 3rd
        mov   [r14+128], rbx            ; Make 1st entry 2nd

        mov   rax, [r14+8]
        mov   rbx, [r14+72]
        mov   rcx, [r14+136]
        mov   [r14+8], rcx
        mov   [r14+72], rax
        mov   [r14+136], rbx

        mov   rax, [r14+16]
        mov   rbx, [r14+80]
        mov   rcx, [r14+144]
        mov   [r14+16], rcx
        mov   [r14+80], rax
        mov   [r14+144], rbx

        mov   rax, [r14+24]
        mov   rbx, [r14+88]
        mov   rcx, [r14+152]
        mov   [r14+24], rcx
        mov   [r14+88], rax
        mov   [r14+152], rbx

        mov   rax, [r14+32]
        mov   rbx, [r14+96]
        mov   rcx, [r14+160]
        mov   [r14+32], rcx
        mov   [r14+96], rax
        mov   [r14+160], rbx

        mov   rax, [r14+40]
        mov   rbx, [r14+104]
        mov   rcx, [r14+168]
        mov   [r14+40], rcx
        mov   [r14+104], rax
        mov   [r14+168], rbx

        mov   rax, [r14+48]
        mov   rbx, [r14+112]
        mov   rcx, [r14+176]
        mov   [r14+48], rcx
        mov   [r14+112], rax
        mov   [r14+176], rbx

        mov   rax, [r14+56]
        mov   rbx, [r14+120]
        mov   rcx, [r14+184]
        mov   [r14+56], rcx
        mov   [r14+120], rax
        mov   [r14+184], rbx
        nextm
datam

; 8brot ( n1 n2 n3 --- n3 n1 n2 )

head    "8brot", stko
obrot:  dq  obrt0
textm
obrt0:  mov   rax, [r14]                ; Get 3rd entry
        mov   rbx, [r14+64]             ; Get 2nd entry
        mov   rcx, [r14+128]            ; Get 1st entry
        mov   [r14], rbx                ; Make 3rd entry 2nd
        mov   [r14+64], rcx             ; Make 2nd entry 1st
        mov   [r14+128], rax            ; Make 1st entry 3rd

        mov   rax, [r14+8]
        mov   rbx, [r14+72]
        mov   rcx, [r14+136]
        mov   [r14+8], rbx
        mov   [r14+72], rcx
        mov   [r14+136], rax

        mov   rax, [r14+16]
        mov   rbx, [r14+80]
        mov   rcx, [r14+144]
        mov   [r14+16], rbx
        mov   [r14+80], rcx
        mov   [r14+144], rax

        mov   rax, [r14+24]
        mov   rbx, [r14+88]
        mov   rcx, [r14+152]
        mov   [r14+24], rbx
        mov   [r14+88], rcx
        mov   [r14+152], rax

        mov   rax, [r14+32]
        mov   rbx, [r14+96]
        mov   rcx, [r14+160]
        mov   [r14+32], rbx
        mov   [r14+96], rcx
        mov   [r14+160], rax

        mov   rax, [r14+40]
        mov   rbx, [r14+104]
        mov   rcx, [r14+168]
        mov   [r14+40], rbx
        mov   [r14+104], rcx
        mov   [r14+168], rax

        mov   rax, [r14+48]
        mov   rbx, [r14+112]
        mov   rcx, [r14+176]
        mov   [r14+48], rbx
        mov   [r14+112], rcx
        mov   [r14+176], rax

        mov   rax, [r14+56]
        mov   rbx, [r14+120]
        mov   rcx, [r14+184]
        mov   [r14+56], rbx
        mov   [r14+120], rcx
        mov   [r14+184], rax
        nextm
datam

; 8slip ( n1 n2 --- n2 )

head    "8slip", stko
oslip:  dq  oslp0
textm
oslp0:  mov   rax, [r14]
        mov   [r14+64], rax
        mov   rax, [r14+8]
        mov   [r14+72], rax
        mov   rax, [r14+16]
        mov   [r14+80], rax
        mov   rax, [r14+24]
        mov   [r14+88], rax
        mov   rax, [r14+32]
        mov   [r14+96], rax
        mov   rax, [r14+40]
        mov   [r14+104], rax
        mov   rax, [r14+48]
        mov   [r14+112], rax
        mov   rax, [r14+56]
        mov   [r14+120], rax
        add   r14, 64
        nextm
datam

; 8slide ( n1 n2 n3 --- n2 n3 )

head    "8slide", stko
oslid:  dq  osld0
textm
osld0:  mov   rax, [r14+64]
        mov   [r14+128], rax
        mov   rax, [r14+72]
        mov   [r14+136], rax
        mov   rax, [r14+80]
        mov   [r14+144], rax
        mov   rax, [r14+88]
        mov   [r14+152], rax
        mov   rax, [r14+96]
        mov   [r14+160], rax
        mov   rax, [r14+104]
        mov   [r14+168], rax
        mov   rax, [r14+112]
        mov   [r14+176], rax
        mov   rax, [r14+120]
        mov   [r14+184], rax

        mov   rax, [r14]
        mov   [r14+64], rax
        mov   rax, [r14+8]
        mov   [r14+72], rax
        mov   rax, [r14+16]
        mov   [r14+80], rax
        mov   rax, [r14+24]
        mov   [r14+88], rax
        mov   rax, [r14+32]
        mov   [r14+96], rax
        mov   rax, [r14+40]
        mov   [r14+104], rax
        mov   rax, [r14+48]
        mov   [r14+112], rax
        mov   rax, [r14+56]
        mov   [r14+120], rax
        add   r14, 64
        nextm
datam

; 8pick

head    "8pick", stko
opick:  dq  opck0
textm
opck0:  mov   rdi, [r14]
        shl   rdi, 3
        sub   r14, 56
        mov   rax, [r14+rdi*8+64]
        mov   [r14], rax
        mov   rax, [r14+rdi*8+72]
        mov   [r14+8], rax
        mov   rax, [r14+rdi*8+80]
        mov   [r14+16], rax
        mov   rax, [r14+rdi*8+88]
        mov   [r14+24], rax
        mov   rax, [r14+rdi*8+96]
        mov   [r14+32], rax
        mov   rax, [r14+rdi*8+104]
        mov   [r14+40], rax
        mov   rax, [r14+rdi*8+112]
        mov   [r14+48], rax
        mov   rax, [r14+rdi*8+120]
        mov   [r14+56], rax
        nextm
datam

; 8xch - ( n --- ) - Swap the top octuple-quad entry with the octuple-quad
; entry whose number is passed on the stack.

head    "8xch", stko
oxch:   dq  oxch0
textm
oxch0:  mov   rdi, [r14]                ; Get entry number
        add   r14, 8                    ; Pop stack
        shl   rdi, 3                    ; Multiply index by 8

        mov   rax, [r14]                ; Exchange quads
        mov   rbx, [r14+rdi*8]
        mov   [r14], rbx
        mov   [r14+rdi*8], rax

        mov   rax, [r14+8]
        mov   rbx, [r14+rdi*8+8]
        mov   [r14+8], rbx
        mov   [r14+rdi*8+8], rax

        mov   rax, [r14+16]
        mov   rbx, [r14+rdi*8+16]
        mov   [r14+16], rbx
        mov   [r14+rdi*8+16], rax

        mov   rax, [r14+24]
        mov   rbx, [r14+rdi*8+24]
        mov   [r14+24], rbx
        mov   [r14+rdi*8+24], rax

        mov   rax, [r14+32]
        mov   rbx, [r14+rdi*8+32]
        mov   [r14+32], rbx
        mov   [r14+rdi*8+32], rax

        mov   rax, [r14+40]
        mov   rbx, [r14+rdi*8+40]
        mov   [r14+40], rbx
        mov   [r14+rdi*8+40], rax

        mov   rax, [r14+48]
        mov   rbx, [r14+rdi*8+48]
        mov   [r14+48], rbx
        mov   [r14+rdi*8+48], rax

        mov   rax, [r14+56]
        mov   rbx, [r14+rdi*8+56]
        mov   [r14+56], rbx
        mov   [r14+rdi*8+56], rax
        nextm
datam

; 8replace

head    "8replace", stko
orplc:  dq  orpl0
textm
orpl0:  mov   rdi, [r14]
        shl   rdi, 3
        mov   rax, [r14+8]
        mov   [r14+rdi*8+72], rax
        mov   rax, [r14+16]
        mov   [r14+rdi*8+80], rax
        mov   rax, [r14+24]
        mov   [r14+rdi*8+88], rax
        mov   rax, [r14+32]
        mov   [r14+rdi*8+96], rax
        mov   rax, [r14+40]
        mov   [r14+rdi*8+104], rax
        mov   rax, [r14+48]
        mov   [r14+rdi*8+112], rax
        mov   rax, [r14+56]
        mov   [r14+rdi*8+120], rax
        mov   rax, [r14+64]
        mov   [r14+rdi*8+128], rax
        add   r14, 72
        nextm
datam

; 8pluck
; Do nothing if argument is zero or negative.

head    "8pluck", stko
opluck: dq  oplk0
textm
oplk0:  mov   rdi, [r14]
        add   r14, 8
        cmp   rdi, 0                    ; Drop argument if it
        jle   oplk2                     ; is zero or negative

        shl   rdi, 3                    ; Multiply by 8

        mov   rax, [r14+rdi*8]          ; Copy item to registers
        mov   rbx, [r14+rdi*8+8]
        mov   rcx, [r14+rdi*8+16]
        mov   rdx, [r14+rdi*8+24]
        mov   rbp, [r14+rdi*8+32]
        mov   r8, [r14+rdi*8+40]
        mov   r9, [r14+rdi*8+48]
        mov   r10, [r14+rdi*8+56]

oplk1:  mov   rsi, [r14+rdi*8-8]        ; Close the gap
        mov   [r14+rdi*8+56], rsi
        mov   rsi, [r14+rdi*8-16]
        mov   [r14+rdi*8+48], rsi
        mov   rsi, [r14+rdi*8-24]
        mov   [r14+rdi*8+40], rsi
        mov   rsi, [r14+rdi*8-32]
        mov   [r14+rdi*8+32], rsi
        mov   rsi, [r14+rdi*8-40]
        mov   [r14+rdi*8+24], rsi
        mov   rsi, [r14+rdi*8-48]
        mov   [r14+rdi*8+16], rsi
        mov   rsi, [r14+rdi*8-56]
        mov   [r14+rdi*8+8], rsi
        mov   rsi, [r14+rdi*8-64]
        mov   [r14+rdi*8], rsi
        sub   rdi, 8
        jnz   oplk1

        mov   [r14], rax                ; Put item on top of stack
        mov   [r14+8], rbx
        mov   [r14+16], rcx
        mov   [r14+24], rdx
        mov   [r14+32], rbp
        mov   [r14+40], r8
        mov   [r14+48], r9
        mov   [r14+56], r10
oplk2:  nextm
datam

; 8poke
; Do nothing if argument is zero or negative.

head    "8poke", stko
opoke:  dq  opok0
textm
opok0:  sub   r15, 8                    ; Free up r12
        mov   [r15], r12

        mov   r12, [r14]                ; Get stack position
        add   r14, 8                    ; Pop stack
        cmp   r12, 0                    ; Drop argument if it
        jle   opok2                     ; is zero or negative

        mov   rax, [r14]                ; Save new item in registers
        mov   rbx, [r14+8]
        mov   rcx, [r14+16]
        mov   rdx, [r14+24]
        mov   rbp, [r14+32]
        mov   r8, [r14+40]
        mov   r9, [r14+48]
        mov   r10, [r14+56]

        lea   rdi, [r14+64]             ; Offset to 2nd octaquad
        xor   r11, r11                  ; Zero index register

opok1:  mov   rsi, [rdi+r11*8]          ; Open slot for new octaquad
        mov   [r14+r11*8], rsi
        mov   rsi, [rdi+r11*8+8]
        mov   [r14+r11*8+8], rsi
        mov   rsi, [rdi+r11*8+16]
        mov   [r14+r11*8+16], rsi
        mov   rsi, [rdi+r11*8+24]
        mov   [r14+r11*8+24], rsi
        mov   rsi, [rdi+r11*8+32]
        mov   [r14+r11*8+32], rsi
        mov   rsi, [rdi+r11*8+40]
        mov   [r14+r11*8+40], rsi
        mov   rsi, [rdi+r11*8+48]
        mov   [r14+r11*8+48], rsi
        mov   rsi, [rdi+r11*8+56]
        mov   [r14+r11*8+56], rsi

        add   r11, 8                    ; Increment index
        sub   r12, 1                    ; Decrement item number
        jnz   opok1

        mov   [r14+r11*8], rax
        mov   [r14+r11*8+8], rbx
        mov   [r14+r11*8+16], rcx
        mov   [r14+r11*8+24], rdx
        mov   [r14+r11*8+32], rbp
        mov   [r14+r11*8+40], r8
        mov   [r14+r11*8+48], r9
        mov   [r14+r11*8+56], r10

opok2:  mov   r12, [r15]                ; Restore r12
        add   r15, 8
        nextm
datam

; Macros for Multi-quad Operators

; Macros for Unrolling Loops - AKA Super Macros

; Shift count for super macros. Can be 1-15, but 15 is pushing the limit with
; code sizes upwards of 1 MB for a single word such as ndup and an executable file
; size of 144 MB! And for all that, it doesn't seem to be faster than with the shift
; count of 7. A sweet spot seems to be 4.

%define shcnt 4


; The ssopm macro unrolls loops for multi-quad stack operators. It takes
; three parameters - the operand size, the number of shifts, and the macro
; name for the code that carries out one iteration of the stack operation.
; Macro for unrolling loops in multi-quad stack operators.
; Uses registers rcx, r9, and rbp.
; The operators it calls may use rax, rbx, and rdx.

; The quadsize is expected to be in r9, and it has already been shifted
; once. The quadsize is expected to be in rcx, and it has already been
; decremented once. If the shift count is negative, the loop count
; will be incremented instead of decremented. So far the only operators
; that do this are npoke and 2npoke.
; The operand size parameter is crucial to the functioning of the macro,
; and there are currently only three possible values - 2, 4, and 8.
; Double quadsize operands take 2, quadruple quadsize operands take 4,
; and octuple quadsize operands take 8. If this parameter is not correctly
; specified. Either assembly will not complete, or the program will crash
; when the code that uses the macro is envoked.

%macro  ssopm  3

%assign n %2

%assign fl 0

  %if n < 0
     %assign n -n
     %assign fl 1
  %endif

%assign nqds %1

%assign j 0

%define %%ss(x) %%ss. %+ x

%rep    n

  %if  j <> n - 1

        %assign k j+1

        %%ss(j) shr   r9, 1
                jnc   %%ss(k)

  %else

       %%ss(j):

  %endif

  %assign i 0

  %rep  nqds/%1

        %3 i

        %assign i i+%1

  %endrep

  %if j <> n - 1

      %if fl = 0

        sub   rcx, nqds                 ; Decrement by nqds

      %else

        add   rcx, nqds                 ; Increment by nqds

      %endif

        jnz   %%ss(k)
                                        ; resume following macro code
        jmp   %%target

       %assign nqds nqds*2
       %assign j j+1

  %else

      %if fl = 0

        sub   rcx, nqds                 ; Decrement by nqds

      %else

        add   rcx, nqds                 ; Increment by nqds

      %endif

        jnz   %%ss(j)

  %endif

%endrep

%%target:

%endmacro

; Operators for ssopm

; Double operator macros to be used inside of ssopm

%macro  dmovm 1
        mov   rax, [rsi+rcx*8-8*%1-8]
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   rax, [rsi+rcx*8-8*%1-16]
        mov   [rdi+rcx*8-8*%1-16], rax
%endmacro

%macro  dswpm 1
        mov   rbx, [rdi+rcx*8-8*%1-8]
        mov   rax, [r14+rcx*8-8*%1-8]
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   [r14+rcx*8-8*%1-8], rbx
        mov   rbx, [rdi+rcx*8-8*%1-16]
        mov   rax, [r14+rcx*8-8*%1-16]
        mov   [rdi+rcx*8-8*%1-16], rax
        mov   [r14+rcx*8-8*%1-16], rbx
%endmacro

%macro  dtckm 1
        mov   rbx, [rdi+rcx*8-8*%1-8]
        mov   rax, [rsi+rcx*8-8*%1-8]
        mov   [r14+rcx*8-8*%1-8], rbx
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   [rsi+rcx*8-8*%1-8], rbx
        mov   rbx, [rdi+rcx*8-8*%1-16]
        mov   rax, [rsi+rcx*8-8*%1-16]
        mov   [r14+rcx*8-8*%1-16], rbx
        mov   [rdi+rcx*8-8*%1-16], rax
        mov   [rsi+rcx*8-8*%1-16], rbx
%endmacro

%macro  drotm 1
        mov   rdx, [r14+rcx*8-8*%1-8]
        mov   rax, [rdi+rcx*8-8*%1-8]
        mov   rbx, [rsi+rcx*8-8*%1-8]
        mov   [r14+rcx*8-8*%1-8], rbx
        mov   [rsi+rcx*8-8*%1-8], rax
        mov   [rdi+rcx*8-8*%1-8], rdx
        mov   rdx, [r14+rcx*8-8*%1-16]
        mov   rax, [rdi+rcx*8-8*%1-16]
        mov   rbx, [rsi+rcx*8-8*%1-16]
        mov   [r14+rcx*8-8*%1-16], rbx
        mov   [rsi+rcx*8-8*%1-16], rax
        mov   [rdi+rcx*8-8*%1-16], rdx
%endmacro

%macro  dbrtm 1
        mov   rdx, [r14+rcx*8-8*%1-8]
        mov   rax, [rdi+rcx*8-8*%1-8]
        mov   rbx, [rsi+rcx*8-8*%1-8]
        mov   [r14+rcx*8-8*%1-8], rax
        mov   [rsi+rcx*8-8*%1-8], rdx
        mov   [rdi+rcx*8-8*%1-8], rbx
        mov   rdx, [r14+rcx*8-8*%1-16]
        mov   rax, [rdi+rcx*8-8*%1-16]
        mov   rbx, [rsi+rcx*8-8*%1-16]
        mov   [r14+rcx*8-8*%1-16], rax
        mov   [rsi+rcx*8-8*%1-16], rdx
        mov   [rdi+rcx*8-8*%1-16], rbx
%endmacro

%macro  dpokm 1
        mov   rbx, [rsi+rcx*8+8*%1]
        mov   rdx, [rsi+rcx*8+8*%1+8]
        mov   [rdi+rcx*8+8*%1], rbx
        mov   [rdi+rcx*8+8*%1+8], rdx
%endmacro

; Fill multi-quads with 0.

%macro  dzrom 1
        mov   qword[rdi+rcx*8-8*%1-8], 0
        mov   qword[rdi+rcx*8-8*%1-16], 0
%endmacro

; Fill multi-quads with value in rbx.

%macro  dfilm 1
        mov   [rdi+rcx*8-8*%1-8], rbx
        mov   [rdi+rcx*8-8*%1-16], rbx
%endmacro

; Quadruple operator macros to be used inside of ssopm

%macro  qmovm 1
        mov   rax, [rsi+rcx*8-8*%1-8]
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   rax, [rsi+rcx*8-8*%1-16]
        mov   [rdi+rcx*8-8*%1-16], rax
        mov   rax, [rsi+rcx*8-8*%1-24]
        mov   [rdi+rcx*8-8*%1-24], rax
        mov   rax, [rsi+rcx*8-8*%1-32]
        mov   [rdi+rcx*8-8*%1-32], rax
%endmacro

%macro  qswpm 1
        mov   rbx, [rdi+rcx*8-8*%1-8]
        mov   rax, [r14+rcx*8-8*%1-8]
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   [r14+rcx*8-8*%1-8], rbx
        mov   rbx, [rdi+rcx*8-8*%1-16]
        mov   rax, [r14+rcx*8-8*%1-16]
        mov   [rdi+rcx*8-8*%1-16], rax
        mov   [r14+rcx*8-8*%1-16], rbx
        mov   rbx, [rdi+rcx*8-8*%1-24]
        mov   rax, [r14+rcx*8-8*%1-24]
        mov   [rdi+rcx*8-8*%1-24], rax
        mov   [r14+rcx*8-8*%1-24], rbx
        mov   rbx, [rdi+rcx*8-8*%1-32]
        mov   rax, [r14+rcx*8-8*%1-32]
        mov   [rdi+rcx*8-8*%1-32], rax
        mov   [r14+rcx*8-8*%1-32], rbx
%endmacro

%macro  qtckm 1
        mov   rbx, [rdi+rcx*8-8*%1-8]
        mov   rax, [rsi+rcx*8-8*%1-8]
        mov   [r14+rcx*8-8*%1-8], rbx
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   [rsi+rcx*8-8*%1-8], rbx
        mov   rbx, [rdi+rcx*8-8*%1-16]
        mov   rax, [rsi+rcx*8-8*%1-16]
        mov   [r14+rcx*8-8*%1-16], rbx
        mov   [rdi+rcx*8-8*%1-16], rax
        mov   [rsi+rcx*8-8*%1-16], rbx
        mov   rbx, [rdi+rcx*8-8*%1-24]
        mov   rax, [rsi+rcx*8-8*%1-24]
        mov   [r14+rcx*8-8*%1-24], rbx
        mov   [rdi+rcx*8-8*%1-24], rax
        mov   [rsi+rcx*8-8*%1-24], rbx
        mov   rbx, [rdi+rcx*8-8*%1-32]
        mov   rax, [rsi+rcx*8-8*%1-32]
        mov   [r14+rcx*8-8*%1-32], rbx
        mov   [rdi+rcx*8-8*%1-32], rax
        mov   [rsi+rcx*8-8*%1-32], rbx
%endmacro

%macro  qrotm 1
        mov   rdx, [r14+rcx*8-8*%1-8]
        mov   rax, [rdi+rcx*8-8*%1-8]
        mov   rbx, [rsi+rcx*8-8*%1-8]
        mov   [r14+rcx*8-8*%1-8], rbx
        mov   [rsi+rcx*8-8*%1-8], rax
        mov   [rdi+rcx*8-8*%1-8], rdx
        mov   rdx, [r14+rcx*8-8*%1-16]
        mov   rax, [rdi+rcx*8-8*%1-16]
        mov   rbx, [rsi+rcx*8-8*%1-16]
        mov   [r14+rcx*8-8*%1-16], rbx
        mov   [rsi+rcx*8-8*%1-16], rax
        mov   [rdi+rcx*8-8*%1-16], rdx
        mov   rdx, [r14+rcx*8-8*%1-24]
        mov   rax, [rdi+rcx*8-8*%1-24]
        mov   rbx, [rsi+rcx*8-8*%1-24]
        mov   [r14+rcx*8-8*%1-24], rbx
        mov   [rsi+rcx*8-8*%1-24], rax
        mov   [rdi+rcx*8-8*%1-24], rdx
        mov   rdx, [r14+rcx*8-8*%1-32]
        mov   rax, [rdi+rcx*8-8*%1-32]
        mov   rbx, [rsi+rcx*8-8*%1-32]
        mov   [r14+rcx*8-8*%1-32], rbx
        mov   [rsi+rcx*8-8*%1-32], rax
        mov   [rdi+rcx*8-8*%1-32], rdx
%endmacro

%macro  qbrtm 1
        mov   rdx, [r14+rcx*8-8*%1-8]
        mov   rax, [rdi+rcx*8-8*%1-8]
        mov   rbx, [rsi+rcx*8-8*%1-8]
        mov   [r14+rcx*8-8*%1-8], rax
        mov   [rsi+rcx*8-8*%1-8], rdx
        mov   [rdi+rcx*8-8*%1-8], rbx
        mov   rdx, [r14+rcx*8-8*%1-16]
        mov   rax, [rdi+rcx*8-8*%1-16]
        mov   rbx, [rsi+rcx*8-8*%1-16]
        mov   [r14+rcx*8-8*%1-16], rax
        mov   [rsi+rcx*8-8*%1-16], rdx
        mov   [rdi+rcx*8-8*%1-16], rbx
        mov   rdx, [r14+rcx*8-8*%1-24]
        mov   rax, [rdi+rcx*8-8*%1-24]
        mov   rbx, [rsi+rcx*8-8*%1-24]
        mov   [r14+rcx*8-8*%1-24], rax
        mov   [rsi+rcx*8-8*%1-24], rdx
        mov   [rdi+rcx*8-8*%1-24], rbx
        mov   rdx, [r14+rcx*8-8*%1-32]
        mov   rax, [rdi+rcx*8-8*%1-32]
        mov   rbx, [rsi+rcx*8-8*%1-32]
        mov   [r14+rcx*8-8*%1-32], rax
        mov   [rsi+rcx*8-8*%1-32], rdx
        mov   [rdi+rcx*8-8*%1-32], rbx
%endmacro

%macro  qpokm 1
        mov   rbx, [rsi+rcx*8+8*%1]
        mov   rdx, [rsi+rcx*8+8*%1+8]
        mov   [rdi+rcx*8+8*%1], rbx
        mov   [rdi+rcx*8++8*%1+8], rdx
        mov   rbx, [rsi+rcx*8+8*%1+16]
        mov   rdx, [rsi+rcx*8+8*%1+24]
        mov   [rdi+rcx*8+8*%1+16], rbx
        mov   [rdi+rcx*8+8*%1+24], rdx
%endmacro

; Octuple operator macros to be used inside of ssopm

%macro  omovm 1
        mov   rax, [rsi+rcx*8-8*%1-8]
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   rax, [rsi+rcx*8-8*%1-16]
        mov   [rdi+rcx*8-8*%1-16], rax
        mov   rax, [rsi+rcx*8-8*%1-24]
        mov   [rdi+rcx*8-8*%1-24], rax
        mov   rax, [rsi+rcx*8-8*%1-32]
        mov   [rdi+rcx*8-8*%1-32], rax
        mov   rax, [rsi+rcx*8-8*%1-40]
        mov   [rdi+rcx*8-8*%1-40], rax
        mov   rax, [rsi+rcx*8-8*%1-48]
        mov   [rdi+rcx*8-8*%1-48], rax
        mov   rax, [rsi+rcx*8-8*%1-56]
        mov   [rdi+rcx*8-8*%1-56], rax
        mov   rax, [rsi+rcx*8-8*%1-64]
        mov   [rdi+rcx*8-8*%1-64], rax
%endmacro

%macro  oswpm 1
        mov   rbx, [rdi+rcx*8-8*%1-8]
        mov   rax, [r14+rcx*8-8*%1-8]
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   [r14+rcx*8-8*%1-8], rbx
        mov   rbx, [rdi+rcx*8-8*%1-16]
        mov   rax, [r14+rcx*8-8*%1-16]
        mov   [rdi+rcx*8-8*%1-16], rax
        mov   [r14+rcx*8-8*%1-16], rbx
        mov   rbx, [rdi+rcx*8-8*%1-24]
        mov   rax, [r14+rcx*8-8*%1-24]
        mov   [rdi+rcx*8-8*%1-24], rax
        mov   [r14+rcx*8-8*%1-24], rbx
        mov   rbx, [rdi+rcx*8-8*%1-32]
        mov   rax, [r14+rcx*8-8*%1-32]
        mov   [rdi+rcx*8-8*%1-32], rax
        mov   [r14+rcx*8-8*%1-32], rbx
        mov   rbx, [rdi+rcx*8-8*%1-40]
        mov   rax, [r14+rcx*8-8*%1-40]
        mov   [rdi+rcx*8-8*%1-40], rax
        mov   [r14+rcx*8-8*%1-40], rbx
        mov   rbx, [rdi+rcx*8-8*%1-48]
        mov   rax, [r14+rcx*8-8*%1-48]
        mov   [rdi+rcx*8-8*%1-48], rax
        mov   [r14+rcx*8-8*%1-48], rbx
        mov   rbx, [rdi+rcx*8-8*%1-56]
        mov   rax, [r14+rcx*8-8*%1-56]
        mov   [rdi+rcx*8-8*%1-56], rax
        mov   [r14+rcx*8-8*%1-56], rbx
        mov   rbx, [rdi+rcx*8-8*%1-64]
        mov   rax, [r14+rcx*8-8*%1-64]
        mov   [rdi+rcx*8-8*%1-64], rax
        mov   [r14+rcx*8-8*%1-64], rbx
%endmacro

%macro  ontkm 1
        mov   rbx, [rdi+rcx*8-8*%1-8]
        mov   rax, [rsi+rcx*8-8*%1-8]
        mov   [r14+rcx*8-8*%1-8], rbx
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   [rsi+rcx*8-8*%1-8], rbx
        mov   rbx, [rdi+rcx*8-8*%1-16]
        mov   rax, [rsi+rcx*8-8*%1-16]
        mov   [r14+rcx*8-8*%1-16], rbx
        mov   [rdi+rcx*8-8*%1-16], rax
        mov   [rsi+rcx*8-8*%1-16], rbx
        mov   rbx, [rdi+rcx*8-8*%1-24]
        mov   rax, [rsi+rcx*8-8*%1-24]
        mov   [r14+rcx*8-8*%1-24], rbx
        mov   [rdi+rcx*8-8*%1-24], rax
        mov   [rsi+rcx*8-8*%1-24], rbx
        mov   rbx, [rdi+rcx*8-8*%1-32]
        mov   rax, [rsi+rcx*8-8*%1-32]
        mov   [r14+rcx*8-8*%1-32], rbx
        mov   [rdi+rcx*8-8*%1-32], rax
        mov   [rsi+rcx*8-8*%1-32], rbx
        mov   rbx, [rdi+rcx*8-8*%1-40]
        mov   rax, [rsi+rcx*8-8*%1-40]
        mov   [r14+rcx*8-8*%1-40], rbx
        mov   [rdi+rcx*8-8*%1-40], rax
        mov   [rsi+rcx*8-8*%1-40], rbx
        mov   rbx, [rdi+rcx*8-8*%1-48]
        mov   rax, [rsi+rcx*8-8*%1-48]
        mov   [r14+rcx*8-8*%1-48], rbx
        mov   [rdi+rcx*8-8*%1-48], rax
        mov   [rsi+rcx*8-8*%1-48], rbx
        mov   rbx, [rdi+rcx*8-8*%1-56]
        mov   rax, [rsi+rcx*8-8*%1-56]
        mov   [r14+rcx*8-8*%1-56], rbx
        mov   [rdi+rcx*8-8*%1-56], rax
        mov   [rsi+rcx*8-8*%1-56], rbx
        mov   rbx, [rdi+rcx*8-8*%1-64]
        mov   rax, [rsi+rcx*8-8*%1-64]
        mov   [r14+rcx*8-8*%1-64], rbx
        mov   [rdi+rcx*8-8*%1-64], rax
        mov   [rsi+rcx*8-8*%1-64], rbx
%endmacro

%macro  orotm 1
        mov   rdx, [r14+rcx*8-8*%1-8]
        mov   rax, [rdi+rcx*8-8*%1-8]
        mov   rbx, [rsi+rcx*8-8*%1-8]
        mov   [r14+rcx*8-8*%1-8], rbx
        mov   [rsi+rcx*8-8*%1-8], rax
        mov   [rdi+rcx*8-8*%1-8], rdx
        mov   rdx, [r14+rcx*8-8*%1-16]
        mov   rax, [rdi+rcx*8-8*%1-16]
        mov   rbx, [rsi+rcx*8-8*%1-16]
        mov   [r14+rcx*8-8*%1-16], rbx
        mov   [rsi+rcx*8-8*%1-16], rax
        mov   [rdi+rcx*8-8*%1-16], rdx
        mov   rdx, [r14+rcx*8-8*%1-24]
        mov   rax, [rdi+rcx*8-8*%1-24]
        mov   rbx, [rsi+rcx*8-8*%1-24]
        mov   [r14+rcx*8-8*%1-24], rbx
        mov   [rsi+rcx*8-8*%1-24], rax
        mov   [rdi+rcx*8-8*%1-24], rdx
        mov   rdx, [r14+rcx*8-8*%1-32]
        mov   rax, [rdi+rcx*8-8*%1-32]
        mov   rbx, [rsi+rcx*8-8*%1-32]
        mov   [r14+rcx*8-8*%1-32], rbx
        mov   [rsi+rcx*8-8*%1-32], rax
        mov   [rdi+rcx*8-8*%1-32], rdx
        mov   rdx, [r14+rcx*8-8*%1-40]
        mov   rax, [rdi+rcx*8-8*%1-40]
        mov   rbx, [rsi+rcx*8-8*%1-40]
        mov   [r14+rcx*8-8*%1-40], rbx
        mov   [rsi+rcx*8-8*%1-40], rax
        mov   [rdi+rcx*8-8*%1-40], rdx
        mov   rdx, [r14+rcx*8-8*%1-48]
        mov   rax, [rdi+rcx*8-8*%1-48]
        mov   rbx, [rsi+rcx*8-8*%1-48]
        mov   [r14+rcx*8-8*%1-48], rbx
        mov   [rsi+rcx*8-8*%1-48], rax
        mov   [rdi+rcx*8-8*%1-48], rdx
        mov   rdx, [r14+rcx*8-8*%1-56]
        mov   rax, [rdi+rcx*8-8*%1-56]
        mov   rbx, [rsi+rcx*8-8*%1-56]
        mov   [r14+rcx*8-8*%1-56], rbx
        mov   [rsi+rcx*8-8*%1-56], rax
        mov   [rdi+rcx*8-8*%1-56], rdx
        mov   rdx, [r14+rcx*8-8*%1-64]
        mov   rax, [rdi+rcx*8-8*%1-64]
        mov   rbx, [rsi+rcx*8-8*%1-64]
        mov   [r14+rcx*8-8*%1-64], rbx
        mov   [rsi+rcx*8-8*%1-64], rax
        mov   [rdi+rcx*8-8*%1-64], rdx
%endmacro

%macro  obrtm 1
        mov   rdx, [r14+rcx*8-8*%1-8]
        mov   rax, [rdi+rcx*8-8*%1-8]
        mov   rbx, [rsi+rcx*8-8*%1-8]
        mov   [r14+rcx*8-8*%1-8], rax
        mov   [rsi+rcx*8-8*%1-8], rdx
        mov   [rdi+rcx*8-8*%1-8], rbx
        mov   rdx, [r14+rcx*8-8*%1-16]
        mov   rax, [rdi+rcx*8-8*%1-16]
        mov   rbx, [rsi+rcx*8-8*%1-16]
        mov   [r14+rcx*8-8*%1-16], rax
        mov   [rsi+rcx*8-8*%1-16], rdx
        mov   [rdi+rcx*8-8*%1-16], rbx
        mov   rdx, [r14+rcx*8-8*%1-24]
        mov   rax, [rdi+rcx*8-8*%1-24]
        mov   rbx, [rsi+rcx*8-8*%1-24]
        mov   [r14+rcx*8-8*%1-24], rax
        mov   [rsi+rcx*8-8*%1-24], rdx
        mov   [rdi+rcx*8-8*%1-24], rbx
        mov   rdx, [r14+rcx*8-8*%1-32]
        mov   rax, [rdi+rcx*8-8*%1-32]
        mov   rbx, [rsi+rcx*8-8*%1-32]
        mov   [r14+rcx*8-8*%1-32], rax
        mov   [rsi+rcx*8-8*%1-32], rdx
        mov   [rdi+rcx*8-8*%1-32], rbx
        mov   rdx, [r14+rcx*8-8*%1-40]
        mov   rax, [rdi+rcx*8-8*%1-40]
        mov   rbx, [rsi+rcx*8-8*%1-40]
        mov   [r14+rcx*8-8*%1-40], rax
        mov   [rsi+rcx*8-8*%1-40], rdx
        mov   [rdi+rcx*8-8*%1-40], rbx
        mov   rdx, [r14+rcx*8-8*%1-48]
        mov   rax, [rdi+rcx*8-8*%1-48]
        mov   rbx, [rsi+rcx*8-8*%1-48]
        mov   [r14+rcx*8-8*%1-48], rax
        mov   [rsi+rcx*8-8*%1-48], rdx
        mov   [rdi+rcx*8-8*%1-48], rbx
        mov   rdx, [r14+rcx*8-8*%1-56]
        mov   rax, [rdi+rcx*8-8*%1-56]
        mov   rbx, [rsi+rcx*8-8*%1-56]
        mov   [r14+rcx*8-8*%1-56], rax
        mov   [rsi+rcx*8-8*%1-56], rdx
        mov   [rdi+rcx*8-8*%1-56], rbx
        mov   rdx, [r14+rcx*8-8*%1-64]
        mov   rax, [rdi+rcx*8-8*%1-64]
        mov   rbx, [rsi+rcx*8-8*%1-64]
        mov   [r14+rcx*8-8*%1-64], rax
        mov   [rsi+rcx*8-8*%1-64], rdx
        mov   [rdi+rcx*8-8*%1-64], rbx
%endmacro

%macro  opokm 1
        mov   rbx, [rsi+rcx*8+8*%1]
        mov   rdx, [rsi+rcx*8+8*%1+8]
        mov   [rdi+rcx*8+8*%1], rbx
        mov   [rdi+rcx*8++8*%1+8], rdx
        mov   rbx, [rsi+rcx*8+8*%1+16]
        mov   rdx, [rsi+rcx*8+8*%1+24]
        mov   [rdi+rcx*8+8*%1+16], rbx
        mov   [rdi+rcx*8+8*%1+24], rdx
        mov   rbx, [rsi+rcx*8+8*%1+32]
        mov   rdx, [rsi+rcx*8+8*%1+40]
        mov   [rdi+rcx*8+8*%1+32], rbx
        mov   [rdi+rcx*8+8*%1+40], rdx
        mov   rbx, [rsi+rcx*8+8*%1+48]
        mov   rdx, [rsi+rcx*8+8*%1+56]
        mov   [rdi+rcx*8+8*%1+48], rbx
        mov   [rdi+rcx*8+8*%1+56], rdx
%endmacro

; Special hexadecituple operator macro for 8nslide

%macro  hdmovm 1
        mov   rax, [rsi+rcx*8-8*%1-8]
        mov   [rdi+rcx*8-8*%1-8], rax
        mov   rax, [rsi+rcx*8-8*%1-16]
        mov   [rdi+rcx*8-8*%1-16], rax
        mov   rax, [rsi+rcx*8-8*%1-24]
        mov   [rdi+rcx*8-8*%1-24], rax
        mov   rax, [rsi+rcx*8-8*%1-32]
        mov   [rdi+rcx*8-8*%1-32], rax
        mov   rax, [rsi+rcx*8-8*%1-40]
        mov   [rdi+rcx*8-8*%1-40], rax
        mov   rax, [rsi+rcx*8-8*%1-48]
        mov   [rdi+rcx*8-8*%1-48], rax
        mov   rax, [rsi+rcx*8-8*%1-56]
        mov   [rdi+rcx*8-8*%1-56], rax
        mov   rax, [rsi+rcx*8-8*%1-64]
        mov   [rdi+rcx*8-8*%1-64], rax
        mov   rax, [rsi+rcx*8-8*%1-72]
        mov   [rdi+rcx*8-8*%1-72], rax
        mov   rax, [rsi+rcx*8-8*%1-80]
        mov   [rdi+rcx*8-8*%1-80], rax
        mov   rax, [rsi+rcx*8-8*%1-88]
        mov   [rdi+rcx*8-8*%1-88], rax
        mov   rax, [rsi+rcx*8-8*%1-96]
        mov   [rdi+rcx*8-8*%1-96], rax
        mov   rax, [rsi+rcx*8-8*%1-104]
        mov   [rdi+rcx*8-8*%1-104], rax
        mov   rax, [rsi+rcx*8-8*%1-112]
        mov   [rdi+rcx*8-8*%1-112], rax
        mov   rax, [rsi+rcx*8-8*%1-120]
        mov   [rdi+rcx*8-8*%1-120], rax
        mov   rax, [rsi+rcx*8-8*%1-128]
        mov   [rdi+rcx*8-8*%1-128], rax
%endmacro

; stkreverse - Reverse the number of stack quads passed as an argument.
; Does nothing but pop the argument if it is 1 or less. Also does nothing
; but pop the argument if it is too big. It's best not to throw an error,
; since doing so will dump the stack - not desirable for large entries.
; This is a utility word to aid in cutting and pasting multi-quad
; stack entries. When a multi-quad stack entry is copied from text and
; pasted into the command line, its quads are reversed. This word puts
; them in correct order again.

head    "stkreverse", mqso
strev:  dq  strv0
textm
strv0:  mov   rcx, [r14]                ; Get argument
        add   r14, 8                    ; Pop argument
        lea   rdx, [dstack0]            ; Get initial stack pointer
        sub   rdx, r14                  ; Subtract current stack pointer
        shr   rdx, 3                    ; Bytes>quads
        cmp   rdx, rcx                  ; Compare with argument
        jc    strv2                     ; Do nothing if argument too big

        cmp   rcx, 1                    ; See if only 1 quad
        jle   strv2                     ; Nothing to do, exit

        lea   rdi, [r14+rcx*8-8]        ; Load address of last entry
        shr   rcx, 1                    ; Halve for count
        xor   rdx, rdx                  ; Zero index
strv1:  mov   rax, [r14+rdx*8]
        mov   rbx, [rdi]
        mov   [r14+rdx*8], rbx
        mov   [rdi], rax
        add   rdx, 1                    ; Increment index
        sub   rdi, 8                    ; Decrement pointer
        sub   rcx, 1                    ; Decrement count
        jnz   strv1                     ; Loop if not zero
strv2:  nextm
datam

; *drop - ( s1 s2 s3 ... s[n] n --- ) Drop n items from the stack,
; including n. Throw error if there are not enough items on the stack.

head    "*drop", stko
stdrop: dq  stdr0
textm
stdr0:  mov   rbx, [r14]
        add   rbx, 1
        shl   rbx, 3

; Make sure there is enough data on the stack.

        lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        cmp   rdi, rbx                  ; Compare data size
        jnc   stdr1                     ; Branch if sufficient

        throwm 69

stdr1:  add   r14, rbx
        nextm
datam

; *adrop - ( S: n --- ) ( A: s1 s2 s3 ... s[n] --- ) Drop n items from the
; auxiliary stack. Throw error if there are not enough items on the auxliliary
; stack.

head    "*adrop", stko
stadrp: dq  stad0
textm
stad0:  mov   rbx, [r14]                ; Get n
        add   r14, 8                    ; Pop data stack
        shl   rbx, 3

; Make sure there is enough data on the auxiliary stack.

        lea   rdi, [astack0]            ; Get initial stack pointer
        sub   rdi, r13                  ; Subtract current stack pointer
        cmp   rdi, rbx                  ; Compare data size
        jnc   stad1                     ; Branch if sufficient

        throwm 69

stad1:  add   r13, rbx
        nextm
datam

; *dup - ( s n --- s s s ... ) Make n-1 copies of the top stack entry.

head    "*dup", stko
stdup:  dq  stdu0
textm
stdu0:  mov   rcx, [r14]
        add   r14, 8
        mov   rdx, [r14]
stdu1:  sub   r14, 8
        mov   [r14], rdx
        sub   rcx, 1
        jnz   stdu1
        nextm
datam

; *@ - ( addr n --- s1 s2 s3 ... s[n] ) Fetch n quadwords to the stack from addr.

head    "*@", mqmo
strat:  dq  stra0
textm
stra0:  mov   rsi, [r14+8]              ; Get address
        mov   rcx, [r14]                ; Get number of quads
        mov   r9, rcx                   ; Copy quad count for shift
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+16]       ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   stra1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destistraion
        sub   rcx, 1                    ; One quad
        jnz   stra1
        jmp   stra2

stra1:  ssopm 2, shcnt, dmovm

stra2:  nextm
datam

; *, - ( s1 s2 s3 ... s[n] n --- ) Compile n quads from the stack.

head    "*,", cmpo
strcom: dq  stcm0
textm
stcm0:  mov   rcx, [r14]                ; Get number of quads
        add   r14, 8                    ; Pop the stack
        mov   r9, rcx                   ; Copy for shifting
        mov   rdi, [dspo0]              ; Get dsp
        mov   [rdi], rcx                ; Install qsz
        lea   rdi, [rdi+rcx*8+8]        ; Load constant/literal base addr
        lea   r14, [r14+rcx*8]          ; Pop stack
        mov   rsi, r14                  ; Copy stack base address
        mov   [dspo0], rdi              ; Update dsp
        neg   rcx                       ; Create negative offset

        shr   r9, 1
        jnc   stcm1

        mov   rbx, [rsi+rcx*8]          ; Get first/next quad
        mov   [rdi+rcx*8], rbx          ; Move from stack
        add   rcx, 1                    ; Increment counter
        jnz   stcm1                     ; Loop for quad size
        jmp   stcm2

stcm1:  ssopm 2, -shcnt, dpokm
stcm2:  nextm
datam

; clrstk - Empty the stack.

head    "clrstk", stko
clrstk: dq  docl0
        dq  depth,stdrop,semis

; clrastk - Empty the auxiliary stack.

head    "clrastk", stko
clrast: dq  docl0
        dq  adepth,stadrp,semis

; clrstks - Empty the data stack and the auxiliary stack.

head    "clrstks", stko
clrsts: dq  docl0
        dq  depth,stdrop,adepth,stadrp,semis

; qsz@ - Return current quad size

head    "qsz@", stco
qszat:  dq  qzat0
textm
qzat0:  mov   rdx, [qdsz0]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; qsz! - Change the quad size to the value passed on the stack.
; This is a dangerous word as written with no bounds check!

head    "qsz!", stco
qszsto: dq  qzst0
textm
qzst0:  mov   rdx, [r14]
        add   r14, 8
        mov   [qdsz0], rdx
        nextm
datam

; qsz*2 - Multiply the quad size by two

head    "qsz*2", stco
qstt:   dq  qstt0
textm
qstt0:  shl   qword[qdsz0], 1
        nextm
datam

; qsz/2 - Divide the quad size by two. This does nothing if the cell
;        size is one, or if it is odd. There is no error message yet.

head    "qsz/2", stco
qsst:   dq  qsst0
textm
qsst0:  mov   rdx, [qdsz0]
        shr   rdx, 1
        jna   qsst1                     ; Do nothing if zero or odd
        mov   [qdsz0], rdx
qsst1:  nextm
datam

; Multi-quad Operators

head    "n,", cmpo
ncomma: dq  ncom0
textm
ncom0:  mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy for shifting
        mov   rdi, [dspo0]              ; Get dsp
        mov   [rdi], rcx                ; Install qsz
        lea   rdi, [rdi+rcx*8+8]        ; Load constant/literal base addr
        lea   r14, [r14+rcx*8]          ; Pop stack
        mov   rsi, r14                  ; Copy stack base address
        mov   [dspo0], rdi              ; Update dsp
        neg   rcx                       ; Create negative offset

        shr   r9, 1
        jnc   ncom1

        mov   rbx, [rsi+rcx*8]          ; Get first/next quad
        mov   [rdi+rcx*8], rbx          ; Move from stack
        add   rcx, 1                    ; Increment counter
        jnz   ncom1                     ; Loop for quad size
        jmp   ncom2

ncom1:  ssopm 2, -shcnt, dpokm
ncom2:  nextm
datam

head    "nliteral", -hlfo
nlite:  dq  docl0
        dq  pcomp,nlit,ncomma,semis
nlit:   dq  nlit0
textm
nlit0:  mov   rsi, r12                  ; Get literal address
        mov   rcx, [rsi]                ; Get qsz of literal
        mov   r9, rcx                   ; Copy for shifting
        add   rsi, 8                    ; Offset to literal value
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer

        shr   r9, 1                     ; Shift count right
        jnc   nlit1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   nlit1
        jmp   nlit2

nlit1:  ssopm 2, shcnt, dmovm

nlit2:  nextm
datam

; nconstant

head    "nconstant", hlfo
ncon:   dq  docl0
        dq  qszat,ckstk
        dq  dfine,lit,ncno,objcom,pcomm,ncon0
        dq  ncomma,oszcom,semis
textm
ncon0:  lea   rsi, [r11+16]             ; Load address of in-line constant
        mov   rcx, [rsi-8]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   ncon1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   ncon1
        jmp   ncon2

ncon1:  ssopm 2, shcnt, dmovm

ncon2:  nextm
datam

; nvariable - Create a multi-quad variable.

head    "nvariable", hlfo
nvar:   dq  docl0
        dq  dfine,lit,nvro,objcom,pcomm,nvar0
        dq  zero,uqtin,ncomma,oszcom,semis
textm
nvar0:  sub   r14, 16
        lea   rdx, [r11+16]             ; Get in-line address of variable
        mov   [r14+8], rdx              ; Return address
        mov   rbx, [rdx-8]              ; Get variable/array qsz
        mov   [r14], rbx                ; Return to stack
        nextm
datam

; narray - Create a multi-quad array of n elements in the current qsz. ( n --- ).
; Arrays are 1-based. Passed an element number from 1 to the maximum, returns
; the element size and base address. Throws an error if the index is out of bounds.
; If passed a negative number or zero, returns the array base address and the number
; of elements it contains.
;
; Array structure (header not shown):

; | code field | number of elements | element size | elements ... |

head    "narray", hlfo
narr:   dq  docl0
        dq  one,ckstk
        dq  dfine,lit,naro,objcom,pcomm,narr0
        dq  dupl,comma,qszat,dupl,comma,star,here,over
        dq  estar,allot,swp,zero,qfill,oszcom,semis
textm
narr0:  mov   rax, [r14]                ; Get array index
        cmp   rax, 0
        jg    narr1                     ; Branch if not zero or below

        lea   rdi, [r11+24]             ; Get array base address
        mov   [r14], rdi                ; Return to stack
        mov   rax, [r11+8]              ; Get number of elements
        sub   r14, 8
        mov   [r14], rax                ; Push to stack
        jmp   narr3                     ; Branch to exit

narr1:  cmp   [r11+8], rax              ; See if index is in bounds
        jnc   narr2                     ; Branch if so

        throwm 14                       ; Else throw index out of bounds

narr2:  sub   rax, 1                    ; Arrays are 1-based
        mov   rbx, [r11+16]             ; Get element qsz
        mul   rbx                       ; Multiply by element qsz
        shl   rax, 3                    ; Multiply by eight
        lea   rdi, [r11+rax+24]         ; Load address of element
        mov   [r14], rdi                ; Return address of element
        sub   r14, 8
        mov   [r14], rbx                ; Return element quadsize

narr3:  nextm
datam

; n@ - Fetch the contents of a multi-quad container to the stack.

head    "n@", mqmo
nqat:   dq  nqat0
textm
nqat0:  mov   rsi, [r14+8]              ; Get variable address
        mov   rcx, [r14]                ; Get qsz of variable
        cmp   rcx, [qdsz0]              ; Compare with system qsz
        jz    nqat1                     ; Branch if they are equal

        throwm 23                       ; Throw conainer size mismatch

nqat1:  mov   r9, rcx                   ; Copy qsz for shift
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+16]       ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   nqat2                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destinqation
        sub   rcx, 1                    ; One quad
        jnz   nqat2
        jmp   nqat3

nqat2:  ssopm 2, shcnt, dmovm

nqat3:  nextm
datam

; n! - Store multi-quad stack entry.

head    "n!", mqmo
nstor:  dq  nsto0
textm
nsto0:  mov   rdi, [r14+8]              ; Get address of variable
        mov   rcx, [r14]                ; Get variable quadsize
        cmp   rcx, [qdsz0]              ; Compare with system qsz
        jz    nsto1                     ; Branch if they are equal

        throwm 23                       ; Throw conainer size mismatch

nsto1:  mov   r9, rcx                   ; Copy qsz for shifting
        lea   rsi, [r14+16]             ; Load adjusted stack pointer
        lea   r14, [r14+rcx*8+16]       ; Pop the stack

        shr   r9, 1                     ; Shift count right
        jnc   nsto2                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   nsto2
        jmp   nsto3

nsto2:  ssopm 2, shcnt, dmovm

nsto3:  nextm
datam

; n>a - Pop top multi-quad stack item and push it to the auxiliary stack.
; Note if the qsz changes, it must be restored before the next na>!

head    "n>a", mqso
ntoa:   dq  ntoa0
textm
ntoa0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop stack entry
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        mov   rdi, r13                  ; Copy auxiliary stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   ntoa1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   ntoa1
        jmp   ntoa2

ntoa1:  ssopm 2, shcnt, dmovm

ntoa2:  nextm
datam

; na> - Pop the top multi-quad item from the auxiliary stack and push
; it to the data stack.

head    "na>", mqso
nfrma:  dq  nfma0
textm
nfma0:  mov   rcx, [qdsz0]              ; Get quadsize
        mov   r9, rcx                   ; Copy qsz for shifting
        lea   rsi, [r13]                ; Load addr of entry
        lea   r13, [r13+rcx*8]          ; Pop entry
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   nfma1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   nfma1
        jmp   nfma2

nfma1:  ssopm 2, shcnt, dmovm

nfma2:  nextm
datam

; na! - Push the top single-quadsize data stack entry to the auxiliary
; stack without popping the data stack.

head    "na!", mqso
nast:   dq  nast0
textm
nast0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        mov   rsi, r14                  ; Copy stack pointer
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        mov   rdi, r13                  ; Copy return stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   nast1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   nast1
        jmp   nast2

nast1:  ssopm 2, shcnt, dmovm

nast2:  nextm
datam

; na@ - Copy top multi-quad item from the auxiliary stack
; to the data stack.

head    "na@", mqso
naat:   dq  naat0
textm
naat0:  mov   rcx, [qdsz0]              ; Get quadsize
        mov   r9, rcx                   ; Copy qsz for shifting
        lea   rsi, [r13]                ; Load auxiliary stack pointer
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   naat1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   naat1
        jmp   naat2

naat1:  ssopm 2, shcnt, dmovm

naat2:  nextm
datam

; nadrop - Discard the single-quadsize item on the auxiliary stack.

head    "nadrop", mqso
nadrp:  dq  nadp0
textm
nadp0:  mov   rcx, [qdsz0]              ; Get quadsize
        lea   r13, [r13+rcx*8]          ; Pop auxiliary stack
        nextm
datam

; napick - Copy the single-quadsize item whose number is passed on the data stack
; from the auxiliary stack to the data stack.

head    "napick", mqso
napick: dq  napk0
textm
napk0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        mul   rcx                       ; Multiply item number by qsz
        lea   rsi, [r13+rax*8]          ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   napk1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   napk1
        jmp   napk2

napk1:  ssopm 2, shcnt, dmovm

napk2:  nextm
datam

; naxch - Exchange the single-quadsize entry on top of the data stack
; with the single-quadsize entry on the auxiliary stack whose number
; is passed on the data stack.

head    "naxch", mqso
naxch:  dq  naxc0
textm
naxc0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy for shifting
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r13+rax*8]          ; Offset to item
        shr   r9, 1                     ; Shift count right
        jnc   naxc1                     ; Branch if no carry

        mov   rbx, [rdi+rcx*8-8]        ; Get quad from 2nd entry
        mov   rax, [r14+rcx*8-8]        ; Get quad from 1st entry
        mov   [rdi+rcx*8-8], rax        ; Replace 2nd with 1st
        mov   [r14+rcx*8-8], rbx        ; Replace 1st with 2nd
        sub   rcx,1                     ; One quad
        jnz   naxc1
        jmp   naxc2

naxc1:  ssopm 2, shcnt, dswpm
naxc2:  nextm
datam

; nareplace - Replace the single-quadsize auxiliary stack entry whose number is passed on the data
; stack with the single-quadsize entry on top of the data stack.

head    "nareplace", mqso
narpl:  dq  narp0
textm
narp0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        lea   rsi, [r14+8]              ; Load address of item
        lea   r14, [r14+rcx*8+8]        ; Adjust the stack
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r13+rax*8]          ; Offset to item

        shr   r9, 1                     ; Shift count right
        jnc   narp1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   narp1
        jmp   narp2

narp1:  ssopm 2, shcnt, dmovm

narp2:  nextm
datam

; ndrop

head    "ndrop", mqso
ndrop:  dq  ndrp0
textm
ndrp0:  mov   rcx, [qdsz0]              ; Get quadsize
        lea   r14, [r14+rcx*8]          ; Pop stack
        nextm
datam

; ndup

head    "ndup", mqso
ndup:   dq  ndup0
textm
ndup0:  mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        neg   rcx                       ; Negate count
        mov   rsi, r14                  ; Copy current stack pointer
        lea   r14, [r14+rcx*8]          ; Offset to new stack pointer
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   ndup1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   ndup1
        jmp   ndup2

ndup1:  ssopm 2, shcnt, dmovm

ndup2:  nextm
datam

; nswap

head    "nswap", mqso
nswap:  dq  nswp0
textm
nswp0:  mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy for shifting
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd entry
        shr   r9, 1                     ; Shift count right
        jnc   nswp1                     ; Branch if no carry

        mov   rbx, [rdi+rcx*8-8]        ; Get quad from 2nd entry
        mov   rax, [r14+rcx*8-8]        ; Get quad from 1st entry
        mov   [rdi+rcx*8-8], rax        ; Replace 2nd with 1st
        mov   [r14+rcx*8-8], rbx        ; Replace 1st with 2nd
        sub   rcx,1                     ; One quad
        jnz   nswp1
        jmp   nswp2

nswp1:  ssopm 2, shcnt, dswpm
nswp2:  nextm
datam

; nover

head    "nover", mqso
nover:  dq  novr0
textm
novr0:  mov   rcx, [qdsz0]              ; Copy quad count
        mov   r9, rcx                   ; Copy for shifting
        lea   rsi, [r14+rcx*8]          ; Offset to second stack entry
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   novr1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   novr1
        jmp   novr2

novr1:  ssopm 2, shcnt, dmovm

novr2:  nextm
datam

; ntuck

head    "ntuck", mqso
ntuck:  dq  ntck0
textm
ntck0:  mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        mov   rdx, rcx                  ; Copy qsz
        shl   rdx, 3                    ; Convert to byte offset
        mov   rdi, r14                  ; Copy stack pointer
        sub   r14, rdx                  ; Address of 1st entry
        mov   rsi, rdi                  ; Address of 2nd entry
        add   rsi, rdx                  ; Address of tucked 1st entry

        shr   r9, 1                     ; Shift count right
        jnc   ntck1                     ; Branch if no carry

        mov   rbx, [rdi+rcx*8-8]        ; Get first quad of 1st entry
        mov   rax, [rsi+rcx*8-8]        ; Get first quad of 2nd entry
        mov   [r14+rcx*8-8], rbx        ; Install 1st entry in new location
        mov   [rdi+rcx*8-8], rax        ; Install 2nd entry in vacated 1st
        mov   [rsi+rcx*8-8], rbx        ; Install tucked 1st entry
        sub   rcx, 1                    ; One quad
        jnz   ntck1
        jmp   ntck2

ntck1:  ssopm 2, shcnt, dtckm
ntck2:  nextm
datam

; nrot

head    "nrot", mqso
nrot:   dq  nrot0
textm
nrot0:  mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        lea   rsi, [rdi+rcx*8]          ; Offset to 3rd stack entry

        shr   r9, 1                     ; Shift count right
        jnc   nrot1                     ; Branch if no carry

        mov   rdx, [r14+rcx*8-8]        ; Get 1st stack quad
        mov   rax, [rdi+rcx*8-8]        ; Get 2nd stack quad
        mov   rbx, [rsi+rcx*8-8]        ; Get 3rd stack quad
        mov   [r14+rcx*8-8], rbx        ; Put 3rd in 1st place
        mov   [rsi+rcx*8-8], rax        ; Put 2nd in 3rd place
        mov   [rdi+rcx*8-8], rdx        ; Put 1st in 2nd place
        sub   rcx, 1                    ; One quad
        jnz   nrot1
        jmp   nrot2

nrot1:  ssopm 2, shcnt, drotm
nrot2:  nextm
datam

; nbrot

head    "nbrot", mqso
nbrot:  dq  nbrt0
textm
nbrt0:  mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        lea   rsi, [rdi+rcx*8]          ; Offset to 3rd stack entry

        shr   r9, 1                     ; Shift count right
        jnc   nbrt1                     ; Branch if no carry

        mov   rdx, [r14+rcx*8-8]        ; Get 1st stack quad
        mov   rax, [rdi+rcx*8-8]        ; Get 2nd stack quad
        mov   rbx, [rsi+rcx*8-8]        ; Get 3rd stack quad
        mov   [r14+rcx*8-8], rax        ; Put 3rd in 1st place
        mov   [rsi+rcx*8-8], rdx        ; Put 2nd in 3rd place
        mov   [rdi+rcx*8-8], rbx        ; Put 1st in 2nd place
        sub   rcx, 1                    ; One quad
        jnz   nbrt1
        jmp   nbrt2

nbrt1:  ssopm 2, shcnt, dbrtm
nbrt2:  nextm
datam

; nslip

head    "nslip", mqso
nslip:  dq  nslp0
textm
nslp0:  mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop top stack entry

        shr   r9, 1                     ; Shift count right
        jnc   nslp1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   nslp1
        jmp   nslp2

nslp1:  ssopm 2, shcnt, dmovm

nslp2:  nextm
datam

; nslide

head    "nslide", mqso
nslid:  dq  nsld0
textm
nsld0:  mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop top stack entry
        mov   rdi, r14                  ; Copy stack pointer
        shl   rcx, 1                    ; Double qsz

        ssopm 2, shcnt, dmovm

        nextm
datam

; npick

head    "npick", mqso
npick:  dq  npck0
textm
npck0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        mul   rcx                       ; Multiply item number by qsz
        lea   rsi, [r14+rax*8+8]        ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   npck1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   npck1
        jmp   npck2

npck1:  ssopm 2, shcnt, dmovm

npck2:  nextm
datam

; nxch

head    "nxch", mqso
nxch:   dq  nxch0
textm
nxch0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    nxch2

        mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy for shifting
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r14+rax*8]          ; Offset to item
        shr   r9, 1                     ; Shift count right
        jnc   nxch1                     ; Branch if no carry

        mov   rbx, [rdi+rcx*8-8]        ; Get quad from 2nd entry
        mov   rax, [r14+rcx*8-8]        ; Get quad from 1st entry
        mov   [rdi+rcx*8-8], rax        ; Replace 2nd with 1st
        mov   [r14+rcx*8-8], rbx        ; Replace 1st with 2nd
        sub   rcx,1                     ; One quad
        jnz   nxch1
        jmp   nxch2

nxch1:  ssopm 2, shcnt, dswpm
nxch2:  nextm
datam

; nreplace

head    "nreplace", mqso
nrepl:  dq  nrpl0
textm
nrpl0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        lea   rsi, [r14+8]              ; Load address of item
        lea   r14, [r14+rcx*8+8]        ; Adjust the stack
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r14+rax*8]          ; Offset to item

        shr   r9, 1                     ; Shift count right
        jnc   nrpl1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   nrpl1
        jmp   nrpl2

nrpl1:  ssopm 2, shcnt, dmovm

nrpl2:  nextm
datam

; npluck - Move the nth item to the top of the stack and close the gap left
;         by it

head    "npluck", mqso
nplck:  dq  nplk0
textm
nplk0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    nplk4

        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy for shifting
        mul   rcx                       ; Multiply item number by qsz
        lea   rsi, [r14+rax*8]          ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   rdi, [r14+rcx*8]          ; Make room on stack
        neg   rcx                       ; Restore count
        add   rax, rcx                  ; Add qsz to product
        mov   r8, rax                   ; Save copy

        shr   r9, 1                     ; Shift count right
        jnc   nplk1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   nplk1
        jmp   nplk2

nplk1:  ssopm 2, shcnt, dmovm

; Fill gap left by plucked item

nplk2:  mov   r9, r8                    ; Copy total count for shifting
        mov   rcx, r8                   ; Copy for loop counter
        mov   rsi, rdi                  ; Set up pointers for movem
        mov   rdi, r14

        shr   r9, 1                     ; Shift count right
        jnc   nplk3                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   nplk3
        jmp   nplk4

nplk3:  ssopm 2, shcnt, dmovm

nplk4:  nextm
datam

; npoke - Create a gap at the nth stack position and install the top stack
;        item there.

head    "npoke", mqso
npoke:  dq  npok0
textm
npok0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    npok4

        add   rax, 1                    ; Add 1 for additional stack item
        mov   r10, [qdsz0]              ; Get qsz
        mul   r10                       ; Multiply by qsz for offset to poke
        mov   r9, rax                   ; Save copy for shifting
        mov   rcx, rax                  ; Save copy for count
        lea   rsi, [r14+rax*8]          ; Load offset to location
        neg   r10                       ; Create negative offset
        lea   rdi, [rsi+r10*8]          ; Offset to next lower item addr
        lea   r8, [r14+r10*8]           ; Save addr for copying new item
        neg   r10                       ; Restore qsz
        neg   rcx                       ; Create negative count

; Open slot for new item

        shr   r9, 1                     ; Shift count right
        jnc   npok1                     ; Branch if no carry

        mov   rbx, [rsi+rcx*8]          ; Get first quad
        mov   [rdi+rcx*8], rbx          ; Move first quad
        add   rcx, 1                    ; One quad
        jnz   npok1
        jmp   npok2

npok1:  ssopm 2, -shcnt, dpokm

; Install item in slot

npok2:  mov   r9, r10                   ; Copy qsz for shifting
        mov   rcx, r10                  ; Copy for counter
        mov   rsi, r8                   ; Copy saved pointer

        shr   r9, 1                     ; Shift count right
        jnc   npok3                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   npok3
        jmp   npok4

npok3:  ssopm 2, shcnt, dmovm

npok4:  nextm
datam

; nlsl - Shift the multi-quad entry left by the count passed on the stack.
; Isolate the quad shift count from the bit shift count. Shift quads first,
; then bits.

head    "nlsl", lgco
nlsl:   dq  nlsl0
textm
nlsl0:  mov   r9, [r14]                 ; Get shift count
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get system quadsize
        cmp   r9, 0                     ; Test shift count
        jz    nlsl11                    ; Exit if zero

; Shift operand left.

nlsl1:  mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    nlsl7                     ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a qsz entry, clear
; the entry.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r10                  ; Copy qsz
        sub   rcx, rdx                  ; Subtract shift count from qsz
        ja    nlsl2                     ; Continue if not greater or equal

        mov   rdx, r10                  ; Else set count to qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   nlsl10                    ; and branch

; Move qsz-count quads

nlsl2:  lea   rdi, [r14+rcx*8]          ; Offset to destination base addr
        lea   rsi, [r14+rdx*8]          ; Offset to first quad to shift
        lea   rsi, [rsi+rcx*8]          ; Offset to source base addr
        neg   rcx                       ; Create negative count/index
nlsl3:  mov   rax, [rsi+rcx*8]          ; Get first/next quad
        mov   [rdi+rcx*8], rax          ; Install quad to the left
        add   rcx, 1                    ; Increment count/index
        jnz   nlsl3

; Zero remaining quads

nlsl4:  mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   nlsl4                     ; Loop

nlsl7:  and   r9, 63                    ; Isolate bit shift count
        jz    nlsl11                    ; Branch if no bits to shift

        mov   rcx, r9                   ; Copy bit shift count
        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r10                  ; Copy qsz
        sub   rbx, 1                    ; One less for last shift
        jz    nlsl9

nlsl8:  mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   nlsl8
nlsl9:  shl   qword[r14+rdx*8], cl      ; Shift single quad
        jmp   nlsl11                    ; Branch to exit

nlsl10: mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   nlsl10                    ; Loop

nlsl11: nextm
datam

; nlsr - Shift the multi-quad entry right by the count passed on the stack.
; Isolate the quad shift count from the bit shift count. Shift quads first,
; then bits.

head    "nlsr", lgco
nlsr:   dq  nlsr0
textm
nlsr0:  mov   r9, [r14]                 ; Get shift count
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get system quadsize
        cmp   r9, 0                     ; Test shift count
        jz    nlsr8                     ; Exit if zero

        mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    nlsr4                     ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a qsz entry, clear
; the entry.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r10                  ; Copy qsz
        sub   rcx, rdx                  ; Subtract shift count from qsz
        ja    nlsr1                     ; Continue if not greater or equal

        mov   rdx, r10                  ; Else set count to qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   nlsr7                     ; and branch

; Move qsz-count quads

nlsr1:  lea   rdi, [r14+rdx*8]          ; Offset to first quad to shift
nlsr2:  mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        mov   [rdi+rcx*8-8], rax        ; Move quad right
        sub   rcx, 1                    ; Decrement counter
        jnz   nlsr2

; Zero remaining quads

nlsr3:  mov   qword[r14+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count
        jnz   nlsr3                     ; Loop

nlsr4:  and   r9, 63                    ; Isolate bit shift count
        jz    nlsr8                     ; Branch if no bits to shift

        mov   rcx, r9                   ; Get shift count

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    nlsr6                     ; Only 1 quad to shift

nlsr5:  mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, cl
        sub   rbx, 1                    ; Decrement index/count
        jnz   nlsr5

nlsr6:  shr   qword[r14+rbx*8], cl      ; Shift single quad
        jmp   nlsr8                     ; Branch to exit

nlsr7:  mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   nlsr7                     ; Loop

nlsr8:  nextm
datam

; nasr - Arithmetically shift the multi-quad entry right by the count passed
; on the stack. Isolate the quad shift count from the bit shift count. Shift
; quads first, then bits. If the sign is positive, this is the same as `nlsr`,
; but if it is negative, the high order portion of the shifted number will be
; filled with ones, and if the shift count is larger than qsz*64 the result
; will be multi-quad -1. Do nothing is shift count is zero.

head    "nasr", lgco
nasr:   dq  nasr0
textm
nasr0:  mov   r9, [r14]                 ; Get shift count
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get system quadsize
        cmp   r9, 0                     ; Test shift count
        jz    nasr8                     ; Exit if zero

        bt    qword[r14], 63            ; Test sign of stack entry
        setc  bpl                       ; Set register accordingly
        neg   bpl                       ; Negate and
        movsx rbp, bpl                  ; sign-extend flag
        mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    nasr4                     ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a qsz entry,
; fill according to sign.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r10                  ; Copy qsz
        sub   rcx, rdx                  ; Subtract shift count from qsz
        ja    nasr1                     ; Continue if not greater or equal

        mov   rdx, r10                  ; Else set count to qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   nasr7                     ; and branch

; Move qsz-count quads

nasr1:  lea   rdi, [r14+rdx*8]          ; Offset to first quad to shift
nasr2:  mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        mov   [rdi+rcx*8-8], rax        ; Move quad right
        sub   rcx, 1                    ; Decrement counter
        jnz   nasr2

; Fill remaining quads according to sign.

nasr3:  mov   [r14+rdx*8-8], rbp        ; Fill first/next quad
        sub   rdx, 1                    ; Decrement count
        jnz   nasr3                     ; Loop

nasr4:  and   r9, 63                    ; Isolate bit shift count
        jz    nasr8                     ; Branch if no bits to shift

        mov   rcx, r9                   ; Get shift count

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    nasr6                     ; Only 1 quad to shift

nasr5:  mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, cl
        sub   rbx, 1                    ; Decrement index/count
        jnz   nasr5

nasr6:  sar   qword[r14+rbx*8], cl      ; Shift single quad
        jmp   nasr8                     ; Branch to exit

nasr7:  mov   [rdi+rdx*8-8], rbp        ; Fill first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   nasr7                     ; Loop

nasr8:  nextm
datam

; nshift - Shift the multi-quad entry according to the shift count passed
; on the stack. If the count is positive, shift left, if negative, shift
; right. Isolate the quad shift count from the bit shift count. The quad
; shift takes place first, followed by the bit shift.
; This operator could be optimized by bit shifting only those quads
; that are non-zero.

head    "nshift", lgco
nshf:   dq  nshf0
textm
nshf0:  mov   r9, [r14]                 ; Get shift count
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get system quadsize
        cmp   r9, 0                     ; Test shift count
        jz    nshf30                    ; Exit if zero
        js    nshf11                    ; Branch to shift right if negative

; Shift operand left.

nshf1:  mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    nshf7                     ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a qsz entry, clear
; the entry.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r10                  ; Copy qsz
        sub   rcx, rdx                  ; Subtract shift count from qsz
        ja    nshf2                     ; Continue if not greater or equal

        mov   rdx, r10                  ; Else set count to qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   nshf29                    ; and branch

; Move qsz-count quads

nshf2:  lea   rdi, [r14+rcx*8]          ; Offset to destination base addr
        lea   rsi, [r14+rdx*8]          ; Offset to first quad to shift
        lea   rsi, [rsi+rcx*8]          ; Offset to source base addr
        neg   rcx                       ; Create negative count/index
nshf3:  mov   rax, [rsi+rcx*8]          ; Get first/next quad
        mov   [rdi+rcx*8], rax          ; Install quad to the left
        add   rcx, 1                    ; Increment count/index
        jnz   nshf3

; Zero remaining quads

nshf4:  mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   nshf4                     ; Loop

nshf7:  and   r9, 63                    ; Isolate bit shift count
        jz    nshf30                    ; Branch if no bits to shift

        mov   rcx, r9                   ; Copy bit shift count
        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r10                  ; Copy qsz
        sub   rbx, 1                    ; One less for last shift
        jz    nshf9
nshf8:  mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   nshf8
nshf9:  shl   qword[r14+rdx*8], cl      ; Shift single quad

        jmp   nshf30                    ; Branch to exit

; Shift operand right

nshf11: neg   r9                        ; Negate shift count
        mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    nshf15                    ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a qsz entry, clear
; the entry.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r10                  ; Copy qsz
        sub   rcx, rdx                  ; Subtract shift count from qsz
        ja    nshf12                    ; Continue if not greater or equal

        mov   rdx, r10                  ; Else set count to qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   nshf29                    ; and branch

; Move qsz-count quads

nshf12: lea   rdi, [r14+rdx*8]          ; Offset to first quad to shift
nshf13: mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        mov   [rdi+rcx*8-8], rax        ; Move quad right
        sub   rcx, 1                    ; Decrement counter
        jnz   nshf13

; Zero remaining quads

nshf14: mov   qword[r14+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count
        jnz   nshf14                    ; Loop

nshf15: and   r9, 63                    ; Isolate bit shift count
        jz    nshf30                    ; Branch if no bits to shift

        mov   rcx, r9                   ; Get shift count

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    nshf17                    ; Only 1 quad to shift
nshf16: mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, cl
        sub   rbx, 1                    ; Decrement index/count
        jnz   nshf16
nshf17: shr   qword[r14+rbx*8], cl      ; Shift single quad

        jmp   nshf30                    ; Branch to exit

nshf29: mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   nshf29                    ; Loop

nshf30: nextm
datam

; ncsl - ( n --- ) Shift qsz stack cells left by number passed on stack

head    "ncsl", lgco
ncsl:   dq  ncsl0
textm
ncsl0:  mov   rdx, [r14]                ; Get cell shift count
        add   r14, 8                    ; Pop stack
        cmp   rdx, 0                    ; Exit if count is zero
        jz    ncsl4

        mov   r10, [qdsz0]              ; Get quadsize
        mov   rcx, r10                  ; Copy qsz
        sub   rcx, rdx                  ; Subtract shift count from qsz
        ja    ncsl1                     ; Branch if not below or equal to zero

        mov   rdx, r10                  ; Else set count to qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   ncsl3                     ; and branch

; Move qsz-count quads

ncsl1:  lea   rdi, [r14+rcx*8]          ; Offset to destination base addr
        lea   rsi, [r14+rdx*8]          ; Offset to first quad to shift
        lea   rsi, [rsi+rcx*8]          ; Offset to source base addr
        neg   rcx                       ; Create negative count/index
ncsl2:  mov   rax, [rsi+rcx*8]          ; Get first/next quad
        mov   [rdi+rcx*8], rax          ; Install quad to the left
        add   rcx, 1                    ; Increment count/index
        jnz   ncsl2

; Zero remaining quads

ncsl3:  mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   ncsl3                     ; Loop

ncsl4:  nextm
datam

; ncsr - ( n --- ) Shift qsz stack cells right by number passed on stack

head    "ncsr", lgco
ncsr:   dq  ncsr0
textm
ncsr0:  mov   rdx, [r14]                ; Get cell shift count
        add   r14, 8                    ; Pop stack
        cmp   rdx, 0                    ; Exit if count is zero
        jz    ncsr4

        mov   r10, [qdsz0]              ; Get system quadsize
        mov   rcx, r10                  ; Copy qsz
        sub   rcx, rdx                  ; Subtract shift count from qsz
        ja    ncsr1                     ; Branch if not equal to or below zero

        mov   rdx, r10                  ; Else set count to qsz
        jmp   ncsr3                     ; and branch

; Move qsz-count quads

ncsr1:  lea   rdi, [r14+rdx*8]          ; Offset to first quad to shift
ncsr2:  mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        mov   [rdi+rcx*8-8], rax        ; Move quad right
        sub   rcx, 1                    ; Decrement counter
        jnz   ncsr2

; Zero remaining quads

ncsr3:  mov   qword[r14+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count
        jnz   ncsr3                     ; Loop

ncsr4:  nextm
datam

; ncrol - ( count --- )
;       Rotate qsz number of quads left by cnt = (count) mod (qsz).
;       If cnt is more than half qsz, rotate quads right by qsz-cnt.

head    "ncrol", lgco
ncrol:  dq  ncrl0
textm
ncrl0:  mov   rax, [r14]                ; Get cell shift count
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if count is zero
        jz    ncrl7

        mov   r10, [qdsz0]              ; Get quadsize
        cmp   r10, 1                    ; See if qsz is 1
        jz    ncrl6                     ; Zero single quad if so
        xor   rdx, rdx                  ; Clear high order dividend
        div   r10                       ; Divide by qsz
        test  rdx, rdx                  ; See if remainder is zero
        jz    ncrl7                     ; If so, do nothing
        mov   r8, rdx                   ; Use remainder for shift count
        mov   rdx, r10                  ; Copy qsz
        shr   rdx, 1                    ; Divide qsz by 2
        cmp   rdx, r8                   ; Compare with cnt
        jc    ncrl3                     ; Branch to rotate right

; Rotate qsz quads left

        neg   r8
        lea   r9, [r14+r8*8]            ; Load destination address
        neg   r8
        mov   rcx, r10                  ; Copy qsz
        lea   rdi, [r9+rcx*8]           ; Offset to destination base addr
        lea   rsi, [r14+rcx*8]          ; Offset to source base addr
        neg   rcx                       ; Create negative count

; Shift quads left

ncrl1:  mov   rbx, [rsi+rcx*8]          ; Get first quad
        mov   [rdi+rcx*8], rbx          ; Move first quad
        add   rcx, 1                    ; One quad
        jnz   ncrl1

; Move shifted quads to low order

ncrl2:  mov   rbx, [r9+r8*8-8]
        mov   [rdi+r8*8-8], rbx
        sub   r8, 1
        jnz   ncrl2
        jmp   ncrl7                     ; Branch to exit

; Rotate qsz-cnt quads right

; Move shifted quads to top of stack

ncrl3:  mov   rcx, r10                  ; Copy qsz
        sub   rcx, r8                   ; Subtract shift count
        neg   rcx                       ; Create negative count/index
        lea   r9, [r14+rcx*8]           ; Offset to next source base addr
        mov   rdi, r14                  ; Copy for destination base addr
        lea   rsi, [r14+r10*8]          ; Offset to source base addr

ncrl4:  mov   rbx, [rsi+rcx*8]          ; Get last/next quad
        mov   [rdi+rcx*8], rbx          ; Move to top of stack
        add   rcx, 1                    ; Increment count/index
        jnz   ncrl4                     ; Loop

; Rotate qsz quads right

        mov   rcx, r10                  ; Copy qsz

ncrl5:  mov   rbx, [r9+rcx*8-8]
        mov   [rdi+rcx*8-8], rbx
        sub   rcx, 1
        jnz   ncrl5
        jmp   ncrl7

ncrl6:  mov   qword[r14], 0

ncrl7:  nextm
datam

; ncror - ( count --- )
;       Rotate qsz number of quads right by cnt = (count) mod (qsz).
;       If cnt is more than half qsz, rotate quads left by qsz-cnt.

head    "ncror", lgco
ncror:  dq  ncrr0
textm
ncrr0:  mov   rax, [r14]                ; Get cell shift count
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if count is zero
        jz    ncrr7

        mov   r10, [qdsz0]              ; Get system quadsize
        cmp   r10, 1                    ; See if qsz is 1
        jz    ncrr6                     ; Zero single quad if so
        xor   rdx, rdx                  ; Clear high order dividend
        div   r10                       ; Divide by qsz
        test  rdx, rdx                  ; See if remainder is zero
        jz    ncrr7                     ; If so, do nothing
        mov   r8, rdx                   ; Use remainder for shift count
        mov   rdx, r10                  ; Copy qsz
        shr   rdx, 1                    ; Divide qsz by 2
        cmp   rdx, r8                   ; Compare with cnt
        jnc   ncrr3                     ; Branch to rotate right

; Rotate qsz quads left

        neg   r8                        ; In effect, subtract
        add   r8, r10                   ; shift count from qsz
        neg   r8                        ; Create negative offset
        lea   r9, [r14+r8*8]            ; Load destination address
        neg   r8                        ; Restore count
        mov   rcx, r10                  ; Copy qsz
        lea   rdi, [r9+rcx*8]           ; Offset to destination base addr
        lea   rsi, [r14+rcx*8]          ; Offset to source base addr
        neg   rcx                       ; Create negative count

; Shift quads left

ncrr1:  mov   rbx, [rsi+rcx*8]          ; Get first quad
        mov   [rdi+rcx*8], rbx          ; Move first quad
        add   rcx, 1                    ; One quad
        jnz   ncrr1

; Move shifted quads to low order

ncrr2:  mov   rbx, [r9+r8*8-8]
        mov   [rdi+r8*8-8], rbx
        sub   r8, 1
        jnz   ncrr2
        jmp   ncrr7                     ; Branch to exit

; Rotate qsz-cnt quads right

; Move shifted quads to top of stack

ncrr3:  mov   rcx, r8                   ; Copy shift count
        neg   rcx                       ; Create negative count/index
        lea   r9, [r14+rcx*8]           ; Offset to next source base addr
        mov   rdi, r14                  ; Copy for destination base addr
        lea   rsi, [r14+r10*8]          ; Offset to source base addr

ncrr4:  mov   rbx, [rsi+rcx*8]          ; Get last/next quad
        mov   [rdi+rcx*8], rbx          ; Move to top of stack
        add   rcx, 1                    ; Increment count/index
        jnz   ncrr4                     ; Loop

; Rotate qsz quads right

        mov   rcx, r10                  ; Copy qsz

ncrr5:  mov   rbx, [r9+rcx*8-8]
        mov   [rdi+rcx*8-8], rbx
        sub   rcx, 1
        jnz   ncrr5
        jmp   ncrr7

ncrr6:  mov   qword[r14], 0

ncrr7:  nextm
datam

; Double Multi-quad Operators

; 2n, - Compile a double multi-quad stack entry.
; Modified to install qsz*2 instead of qsz as the container size.

head    "2n,", cmpo
dncom:  dq  dncm0
textm
dncm0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 1                    ; Double qsz
        mov   rdi, [dspo0]              ; Get dsp
        mov   [rdi], rcx                ; Install double qsz
        lea   rdi, [rdi+rcx*8+8]        ; Load constant/literal base addr
        lea   r14, [r14+rcx*8]          ; Pop the stack
        mov   rsi, r14                  ; Copy stack base address
        mov   [dspo0], rdi              ; Update dsp
        neg   rcx                       ; Create negative count/index

        ssopm 2, -shcnt, dpokm

        nextm
datam

head    "2nliteral", -hlfo
dnlite: dq  docl0
        dq  pcomp,dnlit,dncom,semis
dnlit:  dq  dnlt0
textm
dnlt0:  mov   rsi, r12                  ; Get literal address
        mov   rcx, [rsi]                ; Get qsz of literal
        mov   r9, rcx                   ; Save copy for shifting
        shl   rcx, 1                    ; Double qsz
        add   rsi, 8                    ; Offset to literal value value
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2nconstant

head    "2nconstant", hlfo
dncon:  dq  docl0
        dq  qszat,tstar,ckstk
        dq  dfine,lit,dnco,objcom,pcomm,dncn0
        dq  dncom,oszcom,semis
textm
dncn0:  lea   rsi, [r11+16]             ; Load address of in-line constant
        mov   rcx, [rsi-8]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shr   r9, 1                     ; Moving two quads at a time
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2nvariable - Create a double multi-quad variable.
; Note: Code field routine is the same as that for nvariable
; since it simply returns the quadsize of the container and
; its base address.

head    "2nvariable", hlfo
dnvar:  dq  docl0
        dq  dfine,lit,dnvo,objcom,pcomm,nvar0
        dq  zero,uqre,dncom,oszcom,semis

; 2narray - Create a multi-quad array of elements in double the current qsz.
; ( n --- ). Arrays are 1-based.
; Array structure (header not shown):

; | code field | number of elements | element size | elements ... |

head    "2narray", hlfo
dnarr:  dq  docl0
        dq  one,ckstk
        dq  dfine,lit,dnao,objcom,pcomm,narr0,
        dq  dupl,comma,qszat,tstar,dupl,comma,star,here
        dq  over,estar,allot,swp,zero,qfill,oszcom,semis

; 2n@ - Fetch a double multi-quad object to the stack.

head    "2n@", mqmo
dnat:   dq  dnat0
textm
dnat0:  mov   rsi, [r14+8]              ; Get variable address
        mov   rcx, [r14]                ; Get qsz of variable
        mov   r9, rcx                   ; Make copy
        shr   r9, 1                     ; Halve qsz for shift count
        cmp   r9,  [qdsz0]              ; See if variable is right qsz
        jz    dnat1                     ; Branch if they are equal

        throwm 23                       ; Throw container size mismatch

dnat1:  neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+16]       ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2n! - Store a double multi-quad stack entry.

head    "2n!", mqmo
dnstor: dq  dnst0
textm
dnst0:  mov   rdi, [r14+8]              ; Get address of variable
        mov   r9, [r14]                 ; Get qsz
        mov   rcx, r9                   ; Make copy
        shr   r9, 1                     ; Halve qsz
        cmp   r9, [qdsz0]               ; See if variable is right qsz
        jz    dnst1                     ; Branch if they are equal

        throwm 23                       ; Throw container size mismatch

dnst1:  lea   rsi, [r14+16]             ; Load adjusted stack pointer
        lea   r14, [r14+rcx*8+16]       ; Pop the stack

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2n>a

head    "2n>a", mqso
dntoa:  dq  dnta0
textm
dnta0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop stack entry
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        neg   rcx                       ; Restore count
        mov   rdi, r13                  ; Copy auxiliary stack pointer

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2na>

head    "2na>", mqso
dnfma:  dq  dnfa0
textm
dnfa0:  mov   rcx, [qdsz0]              ; Get quadsize of entry
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        mov   rsi, r13                  ; Load addr of entry
        lea   r13, [r13+rcx*8]          ; Pop entry
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2na! - Push the top double-quadsize data stack entry to the auxiliary
; stack without popping the data stack.

head    "2na!", mqso
dnast:  dq  dnas0
textm
dnas0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        mov   rsi, r14                  ; Copy stack pointer
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        neg   rcx                       ; Restore count
        mov   rdi, r13                  ; Copy auxiliary stack pointer

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2na@ - Copy the double-quadsize entry from the auxiliary stack
; to the data stack and leave it on the auxiliary stack.

head    "2na@", mqso
dnaat:  dq  dnaat0
textm
dnaat0: mov   rcx, [qdsz0]              ; Get quadsize
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        mov   rsi, r13                  ; Copy address of entry
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2nadrop - Discard the double-quadsize item on the auxiliary stack.

head    "2nadrop", mqso
dnadrp: dq  dnad0
textm
dnad0:  mov   rcx, [qdsz0]              ; Get quadsize
        shl   rcx, 1                    ; Double qsz
        lea   r13, [r13+rcx*8]          ; Pop the double-quad item
        nextm
datam

; 2napick - Copy the double-quadsize item whose number is passed on the data stack
; from the auxiliary stack to the data stack.

head    "2napick", mqso
dnapck: dq  dnap0
textm
dnap0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        mul   rcx                       ; Multiply item number by qsz
        lea   rsi, [r13+rax*8]          ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2naxch - Exchange the double-quadsize entry on top of the data stack
; with the double-quadsize entry on the auxiliary stack whose number
; is passed on the data stack.

head    "2naxch", mqso
dnaxc:  dq  dnax0
textm
dnax0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 1                    ; Double for 2*qsz data
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r13+rax*8]          ; Offset to item

        ssopm 2, shcnt, dswpm
        nextm
datam

; 2nareplace - Replace the double-quadsize auxiliary stack entry whose number is passed on the data
; stack with the double-quadsize entry on top of the data stack.

head    "2nareplace", mqso
dnarp:  dq  dnrp0
textm
dnrp0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        lea   rsi, [r14+8]              ; Load address of item
        lea   r14, [r14+rcx*8+8]        ; Adjust the stack
        mul   rcx                       ; Multiply item number by 2*qsz
        lea   rdi, [r13+rax*8]          ; Offset to item

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2ndrop

head    "2ndrop", mqso
dndrop: dq  dndr0
textm
dndr0:  mov   rcx, [qdsz0]              ; Get quadsize
        shl   rcx, 1                    ; Double qsz
        lea   r14, [r14+rcx*8]
        nextm
datam

; 2ndup

head    "2ndup", mqso
dndup:  dq  dndp0
textm
dndp0:  mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        neg   rcx                       ; Negate count
        mov   rsi, r14                  ; Copy current stack pointer
        lea   r14, [r14+rcx*8]          ; Offset to new stack pointer
        mov   rdi, r14                  ; Copy new stack pointer
        neg   rcx                       ; Restore count

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2nswap

head    "2nswap", mqso
dnswap: dq  dnsw0
textm
dnsw0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd entry

        ssopm 2, shcnt, dswpm

        nextm
datam

; 2nover

head    "2nover", mqso
dnover: dq  dnov0
textm
dnov0:  mov   rcx, [qdsz0]              ; Get quad count
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 1                    ; Double for count/index
        lea   rsi, [r14+rcx*8]          ; Offset to second stack entry
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2ntuck

head    "2ntuck", mqso
dntuck: dq  dntk0
textm
dntk0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double for count/index
        mov   rdx, rcx                  ; Copy 2*qsz
        shl   rdx, 3                    ; Convert to byte offset
        mov   rdi, r14                  ; Copy stack pointer
        sub   r14, rdx                  ; Address of 1st entry
        mov   rsi, rdi                  ; Address of 2nd entry
        add   rsi, rdx                  ; Address of tucked 1st entry

        ssopm 2, shcnt, dtckm

        nextm
datam

; 2nrot

head    "2nrot", mqso
dnrot:  dq  dnro0
textm
dnro0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        lea   rsi, [rdi+rcx*8]          ; Offset to 3rd stack entry

        ssopm 2, shcnt, drotm

        nextm
datam

; 2nbrot

head    "2nbrot", mqso
dnbrot: dq  dnbr0
textm
dnbr0:  mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        lea   rsi, [rdi+rcx*8]          ; Offset to 3rd stack entry

        ssopm 2, shcnt, dbrtm

        nextm
datam

; 2nslip

head    "2nslip", mqso
dnslip: dq  dnsp0
textm
dnsp0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop top stack entry

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2nslide

head    "2nslide", mqso
dnslid: dq  dnsd0
textm
dnsd0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop top stack entry
        mov   rdi, r14                  ; Copy stack pointer
        shl   rcx, 1                    ; Double double qsz

        ssopm 4, shcnt, qmovm

        nextm
datam

; 2npick

head    "2npick", mqso
dnpick: dq  dnpk0
textm
dnpk0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        mul   rcx                       ; Multiply item number by qsz
        lea   rsi, [r14+rax*8+8]        ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2nxch

head    "2nxch", mqso
dnxch:  dq  dnxc0
textm
dnxc0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    dnxc1

        mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 1                    ; Double for 2*qsz data
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r14+rax*8]          ; Offset to item

        ssopm 2, shcnt, dswpm
dnxc1:  nextm
datam

; 2nreplace

head    "2nreplace", mqso
dnrpl:  dq  dnre0
textm
dnre0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        lea   rsi, [r14+8]              ; Load address of item
        lea   r14, [r14+rcx*8+8]        ; Adjust the stack
        mul   rcx                       ; Multiply item number by 2*qsz
        lea   rdi, [r14+rax*8]          ; Offset to item

        ssopm 2, shcnt, dmovm

        nextm
datam

; 2npluck

head    "2npluck", mqso
dnplk:  dq  dnpl0
textm
dnpl0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    dnpl1

        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        mul   rcx
        lea   rsi, [r14+rax*8]          ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   rdi, [r14+rcx*8]          ; Make room on stack
        neg   rcx                       ; Restore count
        add   rax, rcx                  ; Add for plucked item
        mov   r8, rax                   ; Save copy

        ssopm 2, shcnt, dmovm

; Fill gap left by plucked item

        mov   r9, r8                    ; Copy total shift count
        shr   r9, 1                     ; Shift right by two
        mov   rcx, r8                   ; Copy for loop counter
        mov   rsi, rdi                  ; Set up pointers for dmovm
        mov   rdi, r14

        ssopm 2, shcnt, dmovm

dnpl1:  nextm
datam

; 2npoke

head    "2npoke", mqso
dnpok:  dq  dnpo0
textm
dnpo0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    dnpo1

        add   rax, 1                    ; Add 1 for additional stack item
        mov   r10, [qdsz0]              ; Get qsz
        mov   rcx, r10                  ; Copy quad size
        mul   rcx                       ; Multiply by qsz for offset to poke
        mov   r9, rax                   ; Save copy for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        shl   rax, 1                    ; Double poke number
        lea   rsi, [r14+rax*8]          ; Load offset to location
        neg   rcx                       ; Create negative offset
        lea   rdi, [rsi+rcx*8]          ; Offset to next lower item addr
        lea   r8, [r14+rcx*8]           ; Save addr for copying new item
        neg   rcx                       ; Restore count
        neg   rax                       ; Create negative count
        xchg  rax, rcx                  ; Exchange counts

; Open slot for new item

        ssopm 2, -shcnt, dpokm

; Install item in slot

        mov   r9, r10                   ; Copy qsz for shifting
        mov   rcx, rax                  ; Copy count
        mov   rsi, r8                   ; Copy saved pointer

        ssopm 2, shcnt, dmovm

dnpo1:  nextm
datam

; 2nlsl - Shift the double multi-quad entry left by the count passed
; on the stack. Isolate the quad shift count from the bit shift count.
; Shift quads first, then bits.

head    "2nlsl", lgco
dnsl:   dq  dnsl0
textm
dnsl0:  mov   r9, [r14]                 ; Get shift count
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get system quadsize
        mov   r11, r10                  ; Copy qsz
        shl   r11, 1                    ; Double it
        cmp   r9, 0                     ; Test shift count
        jz    dnsl9                     ; Exit if zero

; Shift operand left.

dnsl1:  mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    dnsl5                     ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a 2*qsz entry,
; clear the entry.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r11                  ; Copy 2*qsz
        sub   rcx, rdx                  ; Subtract shift count from 2*qsz
        ja    dnsl2                     ; Continue if not greater or equal

        mov   rdx, r11                  ; Else set count to 2*qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   dnsl8                     ; and branch

; Move 2*qsz-count quads.

dnsl2:  lea   rdi, [r14+rcx*8]          ; Offset to destination base addr
        lea   rsi, [r14+rdx*8]          ; Offset to first quad to shift
        lea   rsi, [rsi+rcx*8]          ; Offset to source base addr
        neg   rcx                       ; Create negative count/index
dnsl3:  mov   rax, [rsi+rcx*8]          ; Get first/next quad
        mov   [rdi+rcx*8], rax          ; Install quad to the left
        add   rcx, 1                    ; Increment count/index
        jnz   dnsl3

; Zero remaining quads.

dnsl4:  mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   dnsl4                     ; Loop

dnsl5:  and   r9, 63                    ; Isolate bit shift count
        jz    dnsl9                     ; Branch if no bits to shift

        mov   rcx, r9                   ; Copy bit shift count
        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r11                  ; Copy 2*qsz
        sub   rbx, 1                    ; One less for last shift
        jz    dnsl7

dnsl6:  mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   dnsl6

dnsl7:  shl   qword[r14+rdx*8], cl      ; Shift single quad
        jmp   dnsl9                     ; Branch to exit

dnsl8:  mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   dnsl8                     ; Loop

dnsl9:  nextm
datam

; 2nlsr - Shift the double multi-quad entry right by the count passed
; on the stack. Isolate the quad shift count from the bit shift count.
; Shift quads first, then bits.

head    "2nlsr", lgco
dnsr:   dq  dnsr0
textm
dnsr0:  mov   r9, [r14]                 ; Get shift count
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get system quadsize
        mov   r11, r10                  ; Copy qsz
        shl   r11, 1                    ; Double it
        cmp   r9, 0                     ; Test shift count
        jz    dnsr8                     ; Exit if zero

; Shift operand right.

        mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    dnsr4                     ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a 2*qsz entry,
; clear the entry.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r11                  ; Copy 2*qsz
        sub   rcx, rdx                  ; Subtract shift count from 2*qsz
        ja    dnsr1                     ; Continue if not greater or equal

        mov   rdx, r11                  ; Else set count to 2*qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   dnsr7                     ; and branch

; Move 2*qsz-count quads.

dnsr1:  lea   rdi, [r14+rdx*8]          ; Offset to first quad to shift
dnsr2:  mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        mov   [rdi+rcx*8-8], rax        ; Move quad right
        sub   rcx, 1                    ; Decrement counter
        jnz   dnsr2

; Zero remaining quads.

dnsr3:  mov   qword[r14+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count
        jnz   dnsr3                     ; Loop

dnsr4:  and   r9, 63                    ; Isolate bit shift count
        jz    dnsr8                     ; Branch if no bits to shift

        mov   rcx, r9                   ; Get shift count
        mov   rbx, r11                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than 2*qsz
        jz    dnsr6                     ; Only 1 quad to shift

dnsr5:  mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, cl
        sub   rbx, 1                    ; Decrement index/count
        jnz   dnsr5

dnsr6:  shr   qword[r14+rbx*8], cl      ; Shift single quad
        jmp   dnsr8                     ; Branch to exit

dnsr7:  mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   dnsr7                     ; Loop

dnsr8:  nextm
datam

; 2nasr - Arithmetically shift the double multi-quad entry right by the count
; passed on the stack. Isolate the quad shift count from the bit shift count.
; Shift quads first, then bits. If the sign is positive, this is the same as
; `2nlsr`, but if it is negative, the high order portion of the shifted number
; will be filled with ones, and if the shift count is larger than qsz*64,
; the result will be multi-quad -1.0. Do nothing if shift count is zero.

head    "2nasr", lgco
dnar:   dq  dnar0
textm
dnar0:  mov   r9, [r14]                 ; Get shift count
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get system quadsize
        mov   r11, r10                  ; Copy qsz
        shl   r11, 1                    ; Double it
        cmp   r9, 0                     ; Test shift count
        jz    dnar8                     ; Exit if zero

        bt    qword[r14], 63            ; Test sign of stack entry
        setc  bpl                       ; Set register accordingly
        neg   bpl                       ; Negate and
        movsx rbp, bpl                  ; sign-extend flag

; Shift operand right.

        mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    dnar4                     ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a 2*qsz entry,
; fill according to sign.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r11                  ; Copy 2*qsz
        sub   rcx, rdx                  ; Subtract shift count from 2*qsz
        ja    dnar1                     ; Continue if not greater or equal

        mov   rdx, r11                  ; Else set count to 2*qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   dnar7                     ; and branch

; Move 2*qsz-count quads.

dnar1:  lea   rdi, [r14+rdx*8]          ; Offset to first quad to shift
dnar2:  mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        mov   [rdi+rcx*8-8], rax        ; Move quad right
        sub   rcx, 1                    ; Decrement counter
        jnz   dnar2

; Fill remaining quads according to sign.

dnar3:  mov   [r14+rdx*8-8], rbp        ; Fill first/next quad
        sub   rdx, 1                    ; Decrement count
        jnz   dnar3                     ; Loop

dnar4:  and   r9, 63                    ; Isolate bit shift count
        jz    dnar8                     ; Branch if no bits to shift

        mov   rcx, r9                   ; Get shift count
        mov   rbx, r11                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than 2*qsz
        jz    dnar6                     ; Only 1 quad to shift

dnar5:  mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, cl
        sub   rbx, 1                    ; Decrement index/count
        jnz   dnar5

dnar6:  sar   qword[r14+rbx*8], cl      ; Shift single quad
        jmp   dnar8                     ; Branch to exit

dnar7:  mov   [rdi+rdx*8-8], rbp        ; Fill first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   dnar7                     ; Loop

dnar8:  nextm
datam

; 2nshift - Shift the double multi-quad entry according to the shift count
; passed on the stack. If the count is negative, shift right, if positive,
; shift left. Isolate the quad shift count from the bit shift count.
; The quad shift takes place first, followed by the bit shift.
; This operator could be optimized by bit shifting only those quads
; that are non-zero.

head    "2nshift", lgco
dnshf:  dq  dnsh0
textm
dnsh0:  mov   r9, [r14]                 ; Get shift count
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get system quadsize
        mov   r11, r10                  ; Copy qsz
        shl   r11, 1                    ; Double it

        cmp   r9, 0                     ; Test shift count
        jz    dnsh16                    ; Exit if zero
        js    dnsh8                     ; Branch to shift right if negative

; Shift operand left.

dnsh1:  mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    dnsh5                     ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a 2*qsz entry, clear
; the entry.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r11                  ; Copy 2*qsz
        sub   rcx, rdx                  ; Subtract shift count from 2*qsz
        ja    dnsh2                     ; Continue if not greater or equal

        mov   rdx, r11                  ; Else set count to 2*qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   dnsh15                    ; and branch

; Move 2*qsz-count quads

dnsh2:  lea   rdi, [r14+rcx*8]          ; Offset to destination base addr
        lea   rsi, [r14+rdx*8]          ; Offset to first quad to shift
        lea   rsi, [rsi+rcx*8]          ; Offset to source base addr
        neg   rcx                       ; Create negative count/index
dnsh3:  mov   rax, [rsi+rcx*8]          ; Get first/next quad
        mov   [rdi+rcx*8], rax          ; Install quad to the left
        add   rcx, 1                    ; Increment count/index
        jnz   dnsh3

; Zero remaining quads

dnsh4:  mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   dnsh4                     ; Loop

dnsh5:  and   r9, 63                    ; Isolate bit shift count
        jz    dnsh16                    ; Branch if no bits to shift

        mov   rcx, r9                   ; Copy bit shift count
        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r11                  ; Copy 2*qsz
        sub   rbx, 1                    ; One less for last shift
        jz    dnsh7
dnsh6:  mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   dnsh6

dnsh7:  shl   qword[r14+rdx*8], cl      ; Shift single quad

        jmp   dnsh16                    ; Branch to exit

; Shift operand right

dnsh8:  neg   r9                        ; Negate shift count
        mov   r8, r9                    ; Copy shift count
        shr   r8, 6                     ; Find quad count
        jz    dnsh12                    ; Branch if no quads to shift

; If the requested shift count is equal to or larger than a 2*qsz entry,
; clear the entry.

        mov   rdx, r8                   ; Copy quad shift count
        mov   rcx, r11                  ; Copy 2*qsz
        sub   rcx, rdx                  ; Subtract shift count from 2*qsz
        ja    dnsh9                     ; Continue if not greater or equal

        mov   rdx, r11                  ; Else set count to 2*qsz,
        mov   rdi, r14                  ; destination to stack,
        jmp   dnsh15                    ; and branch

; Move 2*qsz-count quads

dnsh9:  lea   rdi, [r14+rdx*8]          ; Offset to first quad to shift
dnsh10: mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        mov   [rdi+rcx*8-8], rax        ; Move quad right
        sub   rcx, 1                    ; Decrement counter
        jnz   dnsh10

; Zero remaining quads

dnsh11: mov   qword[r14+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count
        jnz   dnsh11                    ; Loop

dnsh12: and   r9, 63                    ; Isolate bit shift count
        jz    dnsh16                    ; Branch if no bits to shift

        mov   rcx, r9                   ; Get shift count

        mov   rbx, r11                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than 2*qsz
        jz    dnsh14                    ; Only 1 quad to shift
dnsh13: mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, cl
        sub   rbx, 1                    ; Decrement index/count
        jnz   dnsh13

dnsh14: shr   qword[r14+rbx*8], cl      ; Shift single quad

        jmp   dnsh16                    ; Branch to exit

dnsh15: mov   qword[rdi+rdx*8-8], 0     ; Zero first/next quad
        sub   rdx, 1                    ; Decrement count/index
        jnz   dnsh15                    ; Loop

dnsh16: nextm
datam

; Quadruple Multi-quad Operators

; 4n, - Compile a quadruple multi-quad stack entry.

head    "4n,", cmpo
qncom:  dq  qncm0
textm
qncm0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 2                    ; Quadruple qsz
        mov   rdi, [dspo0]              ; Get dsp
        mov   [rdi], rcx                ; Install double qsz
        lea   rdi, [rdi+rcx*8+8]        ; Load constant/literal base addr
        lea   r14, [r14+rcx*8]          ; Pop the stack
        mov   rsi, r14                  ; Copy stack base address
        mov   [dspo0], rdi              ; Update dsp
        neg   rcx                       ; Create negative count/index

        ssopm 4, -shcnt, qpokm

        nextm
datam

head    "4nliteral", -hlfo
qnlite: dq  docl0
        dq  pcomp,qnlit,qncom,semis
qnlit:  dq  qnlt0
textm
qnlt0:  mov   rsi, r12                  ; Get literal address
        mov   rcx, [rsi]                ; Get qsz of literal
        mov   r9, rcx                   ; Save copy for shifting
        shl   rcx, 2                    ; Quadruple qsz
        add   rsi, 8                    ; Offset to literal value value
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4nconstant - Create a quadruple multi-quad constant.

head    "4nconstant", hlfo
qncon:  dq  docl0
        dq  qszat,fstar,ckstk
        dq  dfine,lit,qnco,objcom,pcomm,qncn0
        dq  qncom,oszcom,semis
textm
qncn0:  lea   rsi, [r11+16]             ; Load address of in-line constant
        mov   rcx, [rsi-8]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shr   r9, 2                     ; Moving four quads at a time
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4nvariable - Create a quadruple multi-quad variable.
; Note: Code field routine is the same as that for nvariable
; since it simply returns the quadsize of the container and
; its base address.

head    "4nvariable", hlfo
qnvar:  dq  docl0
        dq  dfine,lit,qnvo,objcom,pcomm,nvar0
        dq  zero,uqre,dndup,qncom,oszcom,semis

; 4narray - Create a multi-quad array of elements in quadruple the current qsz.
; ( n --- ). Arrays are 1-based.
; Array structure (header not shown):

; | code field | number of elements | element size | elements ... |

head    "4narray", hlfo
qnarr:  dq  docl0
        dq  one,ckstk
        dq  dfine,lit,qnao,objcom,pcomm,narr0
        dq  dupl,comma,qszat,fstar,dupl,comma,star,here
        dq  over,estar,allot,swp,zero,qfill,oszcom,semis

; 8nconstant - Create an octuple multi-quad constant

; 4n@ - Fetch a quadruple multi-quad object to the stack.

head    "4n@", mqso
qnat:   dq  qnat0
textm
qnat0:  mov   rsi, [r14+8]              ; Get variable address
        mov   r9, [r14]                 ; Get qsz of variable
        mov   rcx, r9                   ; Make copy
        shr   r9, 2                     ; Divide qsz by 4
        cmp   r9, qword[qdsz0]          ; See if variable is right qsz
        jz    qnat1                     ; Branch if they are equal

        throwm 23                       ; Throw container size mismatch

qnat1:  neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+16]       ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4n! - Store a quadruple multi-quad stack entry.

head    "4n!", mqso
qnstor: dq  qnst0
textm
qnst0:  mov   rdi, [r14+8]              ; Get address of variable
        mov   r9, [r14]                 ; Get qsz
        mov   rcx, r9                   ; Make copy
        shr   r9, 2                     ; Divide qsz by 4
        cmp   r9, qword[qdsz0]          ; See if variable is right qsz
        jz    qnst1                     ; Branch if they are equal

        throwm 23                       ; Throw container size mismatch

qnst1:  lea   rsi, [r14+16]             ; Load adjusted stack pointer
        lea   r14, [r14+rcx*8+16]       ; Pop the stack

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4n>a

head    "4n>a", mqso
qntoa:  dq  qnta0
textm
qnta0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop stack entry
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        neg   rcx                       ; Restore count
        mov   rdi, r13                  ; Copy auxiliary stack pointer

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4na>

head    "4na>", mqso
qnfma:  dq  qnfa0
textm
qnfa0:  mov   rcx, [qdsz0]              ; Get quadsize
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        lea   rsi, [r13]                ; Load auxiliary stack pointer
        lea   r13, [r13+rcx*8]          ; Pop auxiliary stack
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4na!

head    "4na!", mqso
qnast:  dq  qnas0
textm
qnas0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        mov   rsi, r14                  ; Copy stack pointer
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        neg   rcx                       ; Restore count
        mov   rdi, r13                  ; Copy auxiliary stack pointer

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4na@

head    "4na@", mqso
qnaat:  dq  qnaat0
textm
qnaat0: mov   rcx, [qdsz0]              ; Get quadsize
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        lea   rsi, [r13]                ; Load auxiliary stack pointer
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4nadrop - Discard the quadruple-quadsize item on the auxiliary stack.

head    "4nadrop", mqso
qnadrp: dq  qnad0
textm
qnad0:  mov   rcx, [qdsz0]              ; Get quad size
        shl   rcx, 2                    ; Quadruple qsz
        lea   r13, [r13+rcx*8]          ; Pop auliliary stack
        nextm
datam

; 4napick - Copy the quadruple-quadsize item whose number is passed on the data stack
; from the auxiliary stack to the data stack.

head    "4napick", mqso
qnapck: dq  qnap0
textm
qnap0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        mul   rcx                       ; Multiply item number by 4*qsz
        lea   rsi, [r13+rax*8]          ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4naxch - Exchange the quadruple-quadsize entry on top of the data stack
; with the quadruple-quadsize entry on the auxiliary stack whose number
; is passed on the data stack.

head    "4naxch", mqso
qnaxc:  dq  qnax0
textm
qnax0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 2                    ; Quadruple for 4*qsz data
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r13+rax*8]          ; Offset to item

        ssopm 4, shcnt, qswpm
        nextm
datam

; 4nareplace - Replace the quadruple-quadsize auxiliary stack entry whose number is passed on the data
; stack with the quadruple-quadsize entry on top of the data stack.

head    "4nareplace", mqso
qnarp:  dq  qnar0
textm
qnar0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        lea   rsi, [r14+8]              ; Load address of item
        lea   r14, [r14+rcx*8+8]        ; Adjust the stack
        mul   rcx                       ; Multiply item number by 4*qsz
        lea   rdi, [r13+rax*8]          ; Offset to item

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4ndrop

head    "4ndrop", mqso
qndrop: dq  qndr0
textm
qndr0:  mov   rcx, [qdsz0]              ; Get quad size
        shl   rcx, 2                    ; Quadruple qsz
        lea   r14, [r14+rcx*8]
        nextm
datam

; 4ndup

head    "4ndup", mqso
qndup:  dq  qndp0
textm
qndp0:  mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        neg   rcx                       ; Negate count
        mov   rsi, r14                  ; Copy current stack pointer
        lea   r14, [r14+rcx*8]          ; Offset to new stack pointer
        mov   rdi, r14                  ; Copy new stack pointer
        neg   rcx                       ; Restore count

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4nswap

head    "4nswap", mqso
qnswap: dq  qnsw0
textm
qnsw0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd entry

        ssopm 4, shcnt, qswpm

        nextm
datam

; 4nover

head    "4nover", mqso
qnover: dq  qnov0
textm
qnov0:  mov   rcx, [qdsz0]              ; Get quad count
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 2                    ; Quadruple for count/index
        lea   rsi, [r14+rcx*8]          ; Offset to second stack entry
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4ntuck

head    "4ntuck", mqso
qntuck: dq  qntk0
textm
qntk0:  mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple for count/index
        mov   rdx, rcx                  ; Copy 4*qsz
        shl   rdx, 3                    ; Convert to byte offset
        mov   rdi, r14                  ; Copy stack pointer
        sub   r14, rdx                  ; Address of 1st entry
        mov   rsi, rdi                  ; Address of 2nd entry
        add   rsi, rdx                  ; Address of tucked 1st entry

        ssopm 4, shcnt, qtckm

        nextm
datam

; 4nrot

head    "4nrot", mqso
qnrot:  dq  qnro0
textm
qnro0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        lea   rsi, [rdi+rcx*8]          ; Offset to 3rd stack entry

        ssopm 4, shcnt, qrotm

        nextm
datam

; 4nbrot

head    "4nbrot", mqso
qnbrot: dq  qnbr0
textm
qnbr0:  mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        lea   rsi, [rdi+rcx*8]          ; Offset to 3rd stack entry

        ssopm 4, shcnt, qbrtm

        nextm
datam

; 4nslip

head    "4nslip", mqso
qnslip: dq  qnsp0
textm
qnsp0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop top stack entry

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4nslide

head    "4nslide", mqso
qnslid: dq  qnsd0
textm
qnsd0:  mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop top stack entry
        mov   rdi, r14                  ; Copy stack pointer
        shl   rcx, 1                    ; Double quadruple qsz

        ssopm 8, shcnt, omovm

        nextm
datam

; 4npick

head    "4npick", mqso
qnpick: dq  qnpk0
textm
qnpk0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        mul   rcx                       ; Multiply item number by 4*qsz
        lea   rsi, [r14+rax*8+8]        ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4nxch

head    "4nxch", mqso
qnxch:  dq  qnxc0
textm
qnxc0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    qnxc1

        mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 2                    ; Quadruple for 4*qsz data
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r14+rax*8]          ; Offset to item

        ssopm 4, shcnt, qswpm
qnxc1:  nextm
datam

; 4nreplace

head    "4nreplace", mqso
qnrpl:  dq  qnrp0
textm
qnrp0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        lea   rsi, [r14+8]              ; Load address of item
        lea   r14, [r14+rcx*8+8]        ; Adjust the stack
        mul   rcx                       ; Multiply item number by 4*qsz
        lea   rdi, [r14+rax*8]          ; Offset to item

        ssopm 4, shcnt, qmovm

        nextm
datam

; 4npluck

head    "4npluck", mqso
qnplk:  dq  qnpl0
textm
qnpl0: mov   rax, [r14]                 ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    qnpl1

        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        mul   rcx
        lea   rsi, [r14+rax*8]          ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   rdi, [r14+rcx*8]          ; Make room on stack
        neg   rcx                       ; Restore count
        add   rax, rcx                  ; Add for plucked item
        mov   r8, rax                   ; Save copy

        ssopm 4, shcnt, qmovm

; Fill gap left by plucked item

        mov   r9, r8                    ; Copy total shift count
        shr   r9, 2                     ; Shift right by four
        mov   rcx, r8                   ; Copy for loop counter
        mov   rsi, rdi                  ; Set up pointers for qmovm
        mov   rdi, r14

        ssopm 4, shcnt, qmovm

qnpl1:  nextm
datam

; 4npoke

head    "4npoke", mqso
qnpok:  dq  qnpo0
textm
qnpo0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    qnpo1

        add   rax, 1                    ; Add 1 for additional stack item
        mov   r10, [qdsz0]              ; Get qsz
        mov   rcx, r10                  ; Copy quad size
        mul   rcx                       ; Multiply by qsz for offset to poke
        mov   r9, rax                   ; Save copy for shifting
        shl   rcx, 2                    ; Quadruple qsz for count/index
        shl   rax, 2                    ; Quadruple poke number
        lea   rsi, [r14+rax*8]          ; Load offset to location
        neg   rcx                       ; Create negative offset
        lea   rdi, [rsi+rcx*8]          ; Offset to next lower item addr
        lea   r8, [r14+rcx*8]           ; Save addr for copying new item
        neg   rcx                       ; Restore count
        neg   rax                       ; Create negative count
        xchg  rax, rcx                  ; Exchange counts

; Open slot for new item

        ssopm 4, -shcnt, qpokm

; Install item in slot

        mov   r9, r10                   ; Copy qsz for shifting
        mov   rcx, rax                  ; Copy count
        mov   rsi, r8                   ; Copy saved pointer

        ssopm 4, shcnt, qmovm

qnpo1:  nextm
datam

; Octuple Multi-quad Operators

; 8n, - Compile an octuple multi-quad stack entry.

head    "8n,", cmpo
oncom:  dq  oncm0
textm
oncm0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 3                    ; 8*qsz
        mov   rdi, [dspo0]              ; Get dsp
        mov   [rdi], rcx                ; Install double qsz
        lea   rdi, [rdi+rcx*8+8]        ; Load constant/literal base addr
        lea   r14, [r14+rcx*8]          ; Pop the stack
        mov   rsi, r14                  ; Copy stack base address
        mov   [dspo0], rdi              ; Update dsp
        neg   rcx                       ; Create negative count/index

        ssopm 8, -shcnt, opokm

        nextm
datam

head    "8nliteral", -hlfo
onlite: dq  docl0
        dq  pcomp,onlit,oncom,semis
onlit:  dq  onlt0
textm
onlt0:  mov   rsi, r12                  ; Get literal address
        mov   rcx, [rsi]                ; Get qsz of literal
        mov   r9, rcx                   ; Save copy for shifting
        shl   rcx, 3                    ; 8*qsz
        add   rsi, 8                    ; Offset to literal value value
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        ssopm 8, shcnt, omovm

        nextm
datam

head    "8nconstant", hlfo
oncon:  dq  docl0
        dq  qszat,estar,ckstk
        dq  dfine,lit,onco,objcom,pcomm,oncn0
        dq  oncom,oszcom,semis
textm
oncn0:  lea   rsi, [r11+16]             ; Load address of in-line constant
        mov   rcx, [rsi-8]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shr   r9, 3                     ; Moving eight quads at a time
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        ssopm 8, shcnt, omovm

        nextm
datam

; 8nvariable - Create an octuple multi-quad variable.
; Note: Code field routine is the same as that for nvariable
; since it simply returns the quadsize of the container and
; its base address.

head    "8nvariable", hlfo
onvar:  dq  docl0
        dq  dfine,lit,onvo,objcom,pcomm,nvar0
        dq  zero,uqre,dndup,qndup,oncom,oszcom,semis

; 8narray - Create a multi-quad array of elements in octuple the current qsz.
; ( n --- ). Arrays are 1-based.
; Array structure (header not shown):

; | code field | number of elements | element size | elements ... |

head    "8narray", hlfo
onarr:  dq  docl0
        dq  one,ckstk
        dq  dfine,lit,onao,objcom,pcomm,narr0
        dq  dupl,comma,qszat,estar,dupl,comma,star,here
        dq  over,estar,allot,swp,zero,qfill,oszcom,semis

; 8n@ - Fetch a quadruple multi-quad object to the stack.

head    "8n@", mqso
onat:   dq  onat0
textm
onat0:  mov   rsi, [r14+8]              ; Get variable address
        mov   r9, [r14]                 ; Get qsz of variable
        mov   rcx, r9                   ; Make copy
        shr   r9, 8                     ; Divide qsz by 8
        cmp   r9, qword[qdsz0]          ; See if variable is right qsz
        jz    onat1                     ; Branch if they are equal

        throwm 23                       ; Throw container size mismatch

onat1:  neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+16]       ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        ssopm 8, shcnt, omovm

        nextm
datam

; 8n! - Store a quadruple multi-quad stack entry.

head    "8n!", mqso
onstor: dq  onst0
textm
onst0:  mov   rdi, [r14+8]              ; Get address of variable
        mov   r9, [r14]                 ; Get qsz
        mov   rcx, r9                   ; Make copy
        shr   r9, 3                     ; Divide qsz by 8
        cmp   r9, qword[qdsz0]          ; See if variable is right qsz
        jz    onst1                     ; Branch if they are equal

        throwm 23                       ; Throw container size mismatch

onst1:  lea   rsi, [r14+16]             ; Load adjusted stack pointer
        lea   r14, [r14+rcx*8+16]       ; Pop the stack

        ssopm 8, shcnt, omovm

        nextm
datam

; 8n>a

head    "8n>a", mqso
ontoa:  dq  onta0
textm
onta0:  mov   rcx, [qdsz0]              ; Get quadsize
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop stack entry
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        neg   rcx                       ; Restore count
        mov   rdi, r13                  ; Copy auxiliary stack pointer

        ssopm 8, shcnt, omovm

        nextm
datam

; 8na>

head    "8na>", mqso
onfma:  dq  onfa0
textm
onfa0:  mov   rcx, [qdsz0]              ; Get quadsize
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        lea   rsi, [r13]                ; Copy auxiliary stack pointer
        lea   r13, [r13+rcx*8]          ; Pop auxiliary stack
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 8, shcnt, omovm

        nextm
datam

; 8na!

head    "8na!", mqso
onast:  dq  onas0
textm
onas0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        mov   rsi, r14                  ; Copy stack pointer
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        neg   rcx                       ; Restore count
        mov   rdi, r13                  ; Copy auxiliary stack pointer

        ssopm 8, shcnt, omovm

        nextm
datam

; 8na@

head    "8na@", mqso
onaat:  dq  onaat0
textm
onaat0: mov   rcx, [qdsz]               ; Get quadsize of entry
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        lea   rsi, [r13]                ; Load auxiliary stack pointer
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 8, shcnt, omovm

        nextm
datam

; 8nadrop - Discard the octuple-quadsize item on the auxiliary stack.

head    "8nadrop", mqso
onadrp: dq  onad0
textm
onad0:  mov   rcx, [qdsz0]              ; Get quad size
        shl   rcx, 3                    ; Multiply by 8
        lea   r13, [r13+rcx*8]          ; Pop the auxiliary stack
        nextm
datam

; 8napick - Copy the octuple-quadsize item whose number is passed on the data stack
; from the auxiliary stack to the data stack.

head    "8napick", mqso
onapck: dq  onap0
textm
onap0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        mul   rcx                       ; Multiply item number by 4*qsz
        lea   rsi, [r13+rax*8]          ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 8, shcnt, omovm

        nextm
datam

; 8naxch - Exchange the octuple-quadsize entry on top of the data stack
; with the octuple-quadsize entry on the auxiliary stack whose number
; is passed on the data stack.

head    "8naxch", mqso
onaxc:  dq  onax0
textm
onax0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 3                    ; 8*qsz for octaquad data
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r13+rax*8]          ; Offset to item

        ssopm 8, shcnt, oswpm
        nextm
datam

; 8nareplace - Replace the octuple-quadsize auxiliary stack entry whose number is passed on the data
; stack with the octuple-quadsize entry on top of the data stack.

head    "8nareplace", mqso
onarp:  dq  onar0
textm
onar0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        lea   rsi, [r14+8]              ; Load address of item
        lea   r14, [r14+rcx*8+8]        ; Adjust the stack
        mul   rcx                       ; Multiply item number by 4*qsz
        lea   rdi, [r13+rax*8]          ; Offset to item

        ssopm 8, shcnt, omovm

        nextm
datam

; 8ndrop

head    "8ndrop", mqso
ondrop: dq  ondr0
textm
ondr0:  mov   rcx, [qdsz0]              ; Get quad size
        shl   rcx, 3                    ; Multiply by 8
        lea   r14, [r14+rcx*8]
        nextm
datam

; 8ndup

head    "8ndup", mqso
ondup:  dq  ondp0
textm
ondp0:  mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        neg   rcx                       ; Negate count
        mov   rsi, r14                  ; Copy current stack pointer
        lea   r14, [r14+rcx*8]          ; Offset to new stack pointer
        mov   rdi, r14                  ; Copy new stack pointer
        neg   rcx                       ; Restore count

        ssopm 8, shcnt, omovm

        nextm
datam

; 8nswap

head    "8nswap", mqso
onswap: dq  onsw0
textm
onsw0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd entry

        ssopm 8, shcnt, oswpm

        nextm
datam

; 8nover

head    "8nover", mqso
onover: dq  onov0
textm
onov0:  mov   rcx, [qdsz0]              ; Get quad count
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        lea   rsi, [r14+rcx*8]          ; Offset to second stack entry
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 8, shcnt, omovm

        nextm
datam

; 8ntuck

head    "8ntuck", mqso
ontuck: dq  ontk0
textm
ontk0:  mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        mov   rdx, rcx                  ; Copy 8*qsz
        shl   rdx, 3                    ; Convert to byte offset
        mov   rdi, r14                  ; Copy stack pointer
        sub   r14, rdx                  ; Address of 1st entry
        mov   rsi, rdi                  ; Address of 2nd entry
        add   rsi, rdx                  ; Address of tucked 1st entry

        ssopm 8, shcnt, ontkm

        nextm
datam

; 8nrot

head    "8nrot", mqso
onrot:  dq  onro0
textm
onro0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        lea   rsi, [rdi+rcx*8]          ; Offset to 3rd stack entry

        ssopm 8, shcnt, orotm

        nextm
datam

; 8nbrot

head    "8nbrot", mqso
onbrot: dq  onbr0
textm
onbr0:  mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        lea   rsi, [rdi+rcx*8]          ; Offset to 3rd stack entry

        ssopm 8, shcnt, obrtm

        nextm
datam

; 8nslip

head    "8nslip", mqso
onslip: dq  onsp0
textm
onsp0:  mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd stack entry
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop top stack entry

        ssopm 8, shcnt, omovm

        nextm
datam

; 8nslide

head    "8nslide", mqso
onslid: dq  onsd0
textm
onsd0:  mov   rcx, [qdsz0]              ; Copy quad size
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop top stack entry
        mov   rdi, r14                  ; Copy stack pointer
        shl   rcx, 1                    ; Double quadruple qsz

        ssopm 16, shcnt, hdmovm

        nextm
datam

; 8npick

head    "8npick", mqso
onpick: dq  onpk0
textm
onpk0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        mul   rcx                       ; Multiply item number by 4*qsz
        lea   rsi, [r14+rax*8+8]        ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        neg   rcx                       ; Restore count
        mov   rdi, r14                  ; Copy stack pointer

        ssopm 8, shcnt, omovm

        nextm
datam

; 8nxch

head    "8nxch", mqso
onxch:  dq  onxc0
textm
onxc0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    onxc1

        mov   rcx, [qdsz0]              ; Get quad size
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 3                    ; 8*qsz for octaquad data
        mul   rcx                       ; Multiply item number by qsz
        lea   rdi, [r14+rax*8]          ; Offset to item

        ssopm 8, shcnt, oswpm
onxc1:  nextm
datam

; 8nreplace

head    "8nreplace", mqso
onrpl:  dq  onrp0
textm
onrp0:  mov   rax, [r14]                ; Get item number
        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        lea   rsi, [r14+8]              ; Load address of item
        lea   r14, [r14+rcx*8+8]        ; Adjust the stack
        mul   rcx                       ; Multiply item number by 4*qsz
        lea   rdi, [r14+rax*8]          ; Offset to item

        ssopm 8, shcnt, omovm

        nextm
datam

; 8npluck

head    "8npluck", mqso
onplk:  dq  onpl0
textm
onpl0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    onpl1

        mov   rcx, [qdsz0]              ; Get qsz
        mov   r9, rcx                   ; Copy for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        mul   rcx
        lea   rsi, [r14+rax*8]          ; Offset to item
        neg   rcx                       ; Create negative offset
        lea   rdi, [r14+rcx*8]          ; Make room on stack
        neg   rcx                       ; Restore count
        add   rax, rcx                  ; Add for plucked item
        mov   r8, rax                   ; Save copy

        ssopm 8, shcnt, omovm

; Fill gap left by plucked item

        mov   r9, r8                    ; Copy total shift count
        shr   r9, 3                     ; Divide by 8
        mov   rcx, r8                   ; Copy for loop counter
        mov   rsi, rdi                  ; Set up pointers for qmovm
        mov   rdi, r14

        ssopm 8, shcnt, omovm

onpl1:  nextm
datam

; 8npoke

head    "8npoke", mqso
onpok:  dq  onpo0
textm
onpo0:  mov   rax, [r14]                ; Get item number
        add   r14, 8                    ; Pop stack
        cmp   rax, 0                    ; Do nothing if item number is zero
        jz    onpo1

        add   rax, 1                    ; Add 1 for additional stack item
        mov   r10, [qdsz0]              ; Get qsz
        mov   rcx, r10                  ; Copy quad size
        mul   rcx                       ; Multiply by qsz for offset to poke
        mov   r9, rax                   ; Save copy for shifting
        shl   rcx, 3                    ; 8*qsz for count/index
        shl   rax, 3                    ; 8*poke number
        lea   rsi, [r14+rax*8]          ; Load offset to location
        neg   rcx                       ; Create negative offset
        lea   rdi, [rsi+rcx*8]          ; Offset to next lower item addr
        lea   r8, [r14+rcx*8]           ; Save addr for copying new item
        neg   rcx                       ; Restore count
        neg   rax                       ; Create negative count
        xchg  rax, rcx                  ; Exchange counts

; Open slot for new item

        ssopm 8, -shcnt, opokm

; Install item in slot

        mov   r9, r10                   ; Copy qsz for shifting
        mov   rcx, rax                  ; Copy count
        mov   rsi, r8                   ; Copy saved pointer

        ssopm 8, shcnt, omovm

onpo1:  nextm
datam

; Operators That Work with Any Operand Size

; bset

head    "bset", lgco
bsetf:  dq  bset0
textm
bset0:  mov   rdx, [r14]                ; Get bit#
        add   r14, 8                    ; Pop stack
        bts   [r14], rdx                ; Set bit in stack entry
        nextm
datam

; bclr

head    "bclr", lgco
bclrf:  dq  bclr0
textm
bclr0:  mov   rdx, [r14]                ; Get bit#
        add   r14, 8                    ; Pop stack
        btr   [r14], rdx                ; Clear bit in stack entry
        nextm
datam

; bcmp

head    "bcmp", lgco
bcmpf:  dq  bcmp0
textm
bcmp0:  mov   rdx, [r14]                ; Get bit#
        add   r14, 8                    ; Pop stack
        btc   [r14], rdx                ; Complement bit in stack entry
        nextm
datam

; btst - ( n bit# --- n true | false ) Return true flag is bit is set,
; else return false flag. The tested quad is retained on the stack.

head    "btst", lgco
btstf:  dq  btst0
textm
btst0:  mov   rcx, [r14]                ; Get bit#
        bt    [r14+8], rcx              ; Test bit in stack entry
        setc  dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx
        nextm
datam

; (btst) - ( addr bit# --- true | false ) Test the bit at the given address
; and return true if set, else return false flag.

head    "(btst)", lgco
pbtst:  dq  pbts0
textm
pbts0:  mov   rcx, [r14]                ; Get bit#
        add   r14, 8                    ; Pop bit#
        mov   rsi, [r14]                ; Get address
        bt    [rsi], rcx                ; Test bit at address
        setc  dl
        neg   dl
        movsx rdx, dl
        mov   [r14], rdx                ; Return flag
        nextm
datam

; Multiprecision Integer Operators

head    "inliteral", -hlfo
inlite: dq  docl0
        dq  pcomp,inlit,ncomma,semis
inlit:  dq  inlt0
textm
inlt0:  lea   rsi, [r12+8]              ; Load literal address
        mov   rdx, [rsi-8]              ; Get quad size of literal
        lea   r12, [r12+rdx*8+8]        ; Offset past literal
        mov   r10, [qdsz0]              ; Get qsz
        neg   r10                       ; Use system qsz for negative offset
        lea   r14, [r14+r10*8]          ; Load new stack address
        neg   r10                       ; Restore system qsz
        mov   rdi, r14                  ; Set temporary stack pointer
        cmp   rdx, r10                  ; See if quadsizes are the same
        jz    inlt6                     ; Branch if so

; Set quad for testing and possible sign-extension.

        bt    qword[rsi], 63            ; Test sign of literal
        setc  bl                        ; Set register accordingly
        neg   bl                        ; Negate and
        movsx rbx, bl                   ; sign-extend flag

; Find quadsize difference.

        mov   r8, rdx                   ; Copy qsz
        sub   r8, r10                   ; Subtract system quad size
        jna   inlt3                     ; Branch if literal qsz not greater

; Literal quad size is greater than system quad size. See if the literal
; can be represented in the smaller quad size.

        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
inlt1:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   inlt2                     ; Overflow if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement qsz difference
        jnz   inlt1

        lea   rsi, [rsi+r8*8]           ; Adjust literal base address
        mov   rdx, r10                  ; Set counter/index to system qsz
        jmp   inlt6                     ; Branch to move literal to stack

inlt2:   throwm 21                      ; Throw overflow on fetch

inlt3:  neg   r8                        ; Make qsz difference positive
        lea   rbp, [rdi+r8*8]           ; Adjust/save temporary stack pointer

; Pre-sign-extend literal.

        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   inlt4                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   inlt4
        jmp   inlt5

inlt4:  ssopm 2, shcnt, dfilm

inlt5:  mov   rdi, rbp                  ; Restore saved stack pointer

inlt6:  mov   r9, rdx                   ; Set for shift count
        mov   rcx, rdx                  ; Set for quad count
        shr   r9, 1                     ; Shift count right
        jnc   inlt7                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   inlt7
        jmp   inlt8

inlt7:  ssopm 2, shcnt, dmovm

inlt8:  nextm
datam

; inconstant - Define a multi-quad integer constant of the current quadsize.

head    "inconstant", hlfo
incon:  dq  docl0
        dq  qszat,ckstk
        dq  dfine,lit,icno,objcom,pcomm,incn0
        dq  ncomma,oszcom,semis
textm
incn0:  lea   rsi, [r11+16]             ; Get address of constant
        mov   rdx, [rsi-8]              ; Get quad size of constant
        mov   r10, [qdsz0]              ; Get system quadsize
        neg   r10                       ; Use system qsz for negative offset
        lea   r14, [r14+r10*8]          ; Load new stack address
        neg   r10                       ; Restore system qsz
        mov   rdi, r14                  ; Set temporary stack pointer
        cmp   rdx, r10                  ; See if quadsizes are the same
        jz    incn6                     ; Branch if so

; Set quad for testing and possible sign-extension.

        bt    qword[rsi], 63            ; Test sign of constant
        setc  bl                        ; Set register accordingly
        neg   bl                        ; Negate and
        movsx rbx, bl                   ; sign-extend flag

; Find quadsize difference.

        mov   r8, rdx                   ; Copy qsz
        sub   r8, r10                   ; Subtract system quad size
        jna   incn3                     ; Branch if constant qsz not greater

; Constant quad size is greater than system quad size. See if the constant
; can be represented in the smaller quad size.

        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
incn1:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   incn2                     ; Overflow if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement qsz difference
        jnz   incn1

        lea   rsi, [rsi+r8*8]           ; Adjust constant base address
        mov   rdx, r10                  ; Set counter/index to system qsz
        jmp   incn6                     ; Branch to move constant to stack

incn2:  throwm 21                       ; Throw overflow on fetch

incn3:  neg   r8                        ; Make qsz difference positive
        lea   rbp, [rdi+r8*8]           ; Adjust/save temporary stack pointer

; Pre-sign-extend constant.

        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   incn4                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   incn4
        jmp   incn5

incn4:  ssopm 2, shcnt, dfilm

incn5:  mov   rdi, rbp                  ; Restore saved stack pointer

incn6:  mov   r9, rdx                   ; Set for shift count
        mov   rcx, rdx                  ; Set for quad count
        shr   r9, 1                     ; Shift count right
        jnc   incn7                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   incn7
        jmp   incn8

incn7:  ssopm 2, shcnt, dmovm

incn8:  nextm
datam

; invariable - Create a multi-quad integer variable.

head    "invariable", hlfo
invar:  dq  docl0
        dq  dfine,lit,ivro,objcom,pcomm,nvar0
        dq  zero,uqtin,ncomma,oszcom,semis

; inarray - Create an array of multi-quad integers in the current qsz.
; ( n --- ). Arrays are 1-based.
; Array structure (header not shown):

; | code field | number of elements | element size | elements ... |

head    "inarray", hlfo
inarr:  dq  docl0
        dq  one,ckstk
        dq  dfine,lit,inao,objcom,pcomm,narr0
        dq  dupl,comma,qszat,dupl,comma,star,here,over
        dq  estar,allot,swp,zero,qfill,oszcom,semis

; in@ - Fetch a multi-quad integer.

head    "in@", mqmo
inat:   dq  inat0
textm
inat0:  mov   rsi, [r14+8]              ; Get address of variable
        mov   rdx, [r14]                ; Get quadsize of variable
        mov   r10, [qdsz0]              ; Get system quadsize
        neg   r10                       ; Use system qsz for negative offset
        lea   r14, [r14+r10*8+16]       ; Load new stack address
        neg   r10                       ; Restore system qsz
        mov   rdi, r14                  ; Set temporary stack pointer
        cmp   rdx, r10                  ; See if quadsizes are the same
        jz    inat6                     ; Branch if so

; Set quad for testing and possible sign-extension.

        bt    qword[rsi], 63            ; Test sign of variable
        setc  bl                        ; Set register accordingly
        neg   bl                        ; Negate and
        movsx rbx, bl                   ; sign-extend flag

; Find quadsize difference.

        mov   r8, rdx                   ; Copy variable qsz
        sub   r8, r10                   ; Subtract system quad size
        jna   inat3                     ; Branch if variable qsz not greater

; Variable quad size is greater than system quad size. See if the variable
; can be represented in the smaller quad size.

        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
inat1:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   inat2                     ; Overflow if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement qsz difference
        jnz   inat1

        lea   rsi, [rsi+r8*8]           ; Adjust variable base address
        mov   rdx, r10                  ; Set counter/index to system qsz
        jmp   inat6                     ; Branch to move variable to stack

inat2:  throwm 21                       ; Throw overflow on fetch

inat3:  neg   r8                        ; Make qsz difference positive
        lea   rbp, [rdi+r8*8]           ; Adjust/save temporary stack pointer

; Pre-sign-extend variable.

        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   inat4                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   inat4
        jmp   inat5

inat4:  ssopm 2, shcnt, dfilm

inat5:  mov   rdi, rbp                  ; Restore saved stack pointer

inat6:  mov   r9, rdx                   ; Set for shift count
        mov   rcx, rdx                  ; Set for quad count
        shr   r9, 1                     ; Shift count right
        jnc   inat7                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   inat7
        jmp   inat8

inat7:  ssopm 2, shcnt, dmovm

inat8:  nextm
datam

; in! - Store a multi-quad integer.

head    "in!", mqmo
insto:  dq  inst0
textm
inst0:  mov   rdi, [r14+8]              ; Get address of variable
        mov   rdx, [r14]                ; Get quadsize of variable
        mov   r10, [qdsz0]              ; Get system quadsize
        lea   rsi, [r14+16]             ; Load address of stack entry
        lea   r14, [r14+r10*8+16]       ; Pop stack
        cmp   rdx, r10                  ; See if quadsizes are the same
        jz    inst6                     ; Branch if so

; Set quad for testing and possible sign-extension.

        bt    qword[rsi], 63            ; Test sign of stack entry
        setc  bl                        ; Set register accordingly
        neg   bl                        ; Negate and
        movsx rbx, bl                   ; sign-extend flag

; Find quadsize difference.

        mov   r8, r10                   ; Copy system qsz
        sub   r8, rdx                   ; Subtract variable qsz

        jna   inst3                     ; Branch if system qsz not greater

; System quadsize is greater than the variable quadsize. See if the stack
; entry can be represented in the smaller quadsize.

        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
inst1:  cmp   [rsi+rax*8], rbx          ; Compare first/next quad
        jnz   inst2                     ; Leave loop if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement counter
        jnz   inst1                     ; Loop for quadsize difference

        lea   rsi, [rsi+r8*8]           ; Adjust stack base address
        jmp   inst6                     ; Branch to move variable from stack

inst2:  throwm 20                       ; Throw overflow on store

inst3:  neg   r8                        ; Make qsz difference positive
        lea   rbp, [rdi+r8*8]           ; Adjust/save variable pointer

; Pre-sign-extend variable.

        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   inst4                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   inst4
        jmp   inst5

inst4:  ssopm 2, shcnt, dfilm

inst5:  mov   rdi, rbp                  ; Restore saved variable pointer
        mov   rdx, r10                  ; Use system qsz for count

inst6:  mov   r9, rdx                   ; Set for shift count
        mov   rcx, rdx                  ; Set for quad count
        shr   r9, 1                     ; Shift count right
        jnc   inst7                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   inst7
        jmp   inst8

inst7:  ssopm 2, shcnt, dmovm

inst8:  nextm
datam

; in*2 - Double multiprecision integer.

head    "in*2", ario
instt:  dq  istt0
textm
istt0:  xor   rdx, rdx                  ; Clear index register
        mov   rbx, [qdsz0]              ; Get quadsize

        mov   rax, [r14+rdx*8+8]        ; Shift first quad
        shld  [r14+rdx*8], rax, 1
        jno   istt1                     ; Test for overflow

        throwm 27                       ; Throw multiplication overflow

istt1:  sub   rbx, 1                    ; One less for last shift
        jz    istt4                     ; Exit if only one quad

        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jz    istt3

istt2:  mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, 1
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   istt2

istt3:  shl   qword[r14+rdx*8], 1       ; Shift low order quad

istt4:  nextm
datam

; in/2 - Halve multiprecision integer.

head    "in/2", ario
inslt:  dq  islt0
textm
islt0:  mov   rdx, [qdsz0]              ; Get quadsize
        bt    qword[r14], 63            ; Test sign bit
        setc  r8b                       ; Set register accordingly
        jnc   islt5                     ; Branch if positive

islt1:  cmp   qword[r14+rcx*8-8], 0     ; Scan for non-zero quad
        jnz   islt2
        sub   rdx, 1
        jnz   islt1

; If loop falls through, number is zero. Do nothing

        jmp   islt10

; Negate number

islt2:  mov   rbx, rdx
        mov   rcx, rdx
islt3:  not   qword[r14+rcx*8-8]
        sub   rcx, 1
        jnz   islt3
islt4:  add   qword[r14+rbx*8-8], 1
        jnc   islt5
        sub   rbx, 1
        jnz   islt4

; Shift number

islt5:  mov   rbx, rdx                  ; Copy quadsize
        sub   rbx, 1                    ; Count is one less than qsz
        jz    islt7                     ; Only 1 quad to shift
islt6:  mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   islt6
islt7:  sar   qword[r14+rbx*8], 1       ; Shift low order quad

        test  r8b, r8b                  ; See if negative
        jz    islt10                    ; Exit if not

; Negate number

        mov   rbx, rdx
        mov   rcx, rdx
islt8:  not   qword[r14+rcx*8-8]
        sub   rcx, 1
        jnz   islt8
islt9:  add   qword[r14+rbx*8-8], 1
        jnc   islt10
        sub   rbx, 1
        jnz   islt9

islt10: nextm
datam

; in+sq - Add a single signed quad to a multi-quad integer.

head    "in+sq", ario
inpsq:  dq  ipsq0
textm
ipsq0:  mov   rdx, [r14]                ; Pop addend
        add   r14, 8
        mov   rcx, [qdsz0]              ; Get quadsize
        sub   rcx, 1                    ; Decrement for 1st quad
        xor   rbx, rbx                  ; Zero carry/borrow register
        bt    rdx, 63                   ; Test sign bit
        jc    ipsq2                     ; Branch if operand is negative
        add   [r14+rcx*8], rdx          ; Add addend
        jnc   ipsq4                     ; Exit if no carry
ipsq1:  add   qword[r14+rcx*8-8], 1     ; Add carry to next quad
        jnc   ipsq4                     ; Exit if no carry results
        sub   rcx, 1                    ; Decrement index/counter
        jnz   ipsq1                     ; Loop for quad count
        jmp   ipsq4                     ; Branch to exit

ipsq2:  neg   rdx                       ; Negate operand
        sub   [r14+rcx*8], rdx          ; Subtract
        jnc   ipsq4                     ; Exit if no borrow
ipsq3:  sub   qword[r14+rcx*8-8], 1     ; Subtract borrow from next quad
        jnc   ipsq4                     ; Exit if no borrow results
        sub   rcx, 1                    ; Decrement index/counter
        jnz   ipsq3                     ; Loop for quad count
ipsq4:  nextm
datam

; in*uq - Multiply a multi-quad integer by a single unsigned quad.

head    "in*uq"
instu:  dq   istu0
textm
istu0:  mov   r8, [r14]                 ; Pop multiplier quad
        add   r14, 8

; Find leading non-zero quad.

        xor   r9, r9                    ; Clear overflow flag register
        mov   r10, [qdsz0]              ; Get quadsize
        mov   rcx, r10                  ; Copy quadsize
        xor   rdx, rdx                  ; Zero index
istu1:  cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   istu2                     ; Exit loop if not
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   istu1

; If loop falls through, product is zero. Branch to exit.

        jmp   istu6                     ; Branch to exit

istu2:  cmp   rdx, 0                    ; See if there were leading zero quads
        jnz   istu3                     ; Branch if so

        setz  r9b                       ; Set register to flag overflow

istu3:  lea   rdi, [r14+rdx*8]          ; Load addr of high order quad
        xor   rbx, rbx                  ; Clear for high order result
        mov   rcx, r10                  ; Get qsz
        sub   rcx, rdx                  ; Subtract number of leading zero quads
istu4:  mov   rax, [rdi+rcx*8-8]        ; Get first/next multiplicand quad
        mul   r8                        ; Multiply by multiplier quad
        add   rax, rbx                  ; Add high order from previous loop
        jnc   istu5                     ; Brach if no carry
        add   rdx, 1                    ; Else add carry to high order
istu5:  mov   [rdi+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order
        sub   rcx, 1                    ; Decrement count
        jnz   istu4                     ; Loop for non-zero quad count

; Note that installing the high order product on the stack could result
; in the stack having an additional quad, but if this is the case it won't
; matter because the multiplication overflow exception will be taken.

        mov   [rdi-8], rdx              ; Install high order product on stack

        test  r9b, r9b                  ; Test overflow flag
        jz    istu6                     ; Finish if clear

        cmp   rdx, 0                    ; Test high order result
        jz    istu6                     ; Done if zero

        throwm 27                       ; Throw multiplication overflow

istu6:  nextm
datam

; in*sq - Multiply a multi-quad integer by a single signed quad.

head    "in*sq"
istsq:  dq   istq0
textm
istq0:  xor   rbp, rbp                  ; Zero flags register
        mov   r8, [r14]                 ; Pop multiplier quad
        add   r14, 8
        mov   r10, [qdsz0]              ; Get quadsize
        bt    r8, 63                    ; Test sign of multiplier
        jnc   istq1                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag if negative
        neg   r8                        ; Negate

istq1:  bt    qword[r14], 63            ; Test sign of entry
        jnc   istq4                     ; Branch if positive

; Negate if negative

        btc   rbp, 0                    ; Complement sign flag if negative
        mov   rcx, r10                  ; Set counter
istq2:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   istq2
        mov   rcx, r10                  ; Reset counter
istq3:  add   qword[r14+rcx*8-8], 1
        jnc   istq4
        sub   rcx, 1
        jnz   istq3

; Find leading non-zero quad.

istq4:  xor   r9, r9                    ; Clear overflow flag register
        mov   rcx, r10                  ; Set loop counter
        xor   rdx, rdx                  ; Zero index
istq5:  cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   istq6                     ; Exit loop if not
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   istq5

; If loop falls through, product is zero. Exit.

        jmp   istq14                    ; Branch to exit

istq6:  cmp   rdx, 0                    ; See if there were lead quads
        jnz   istq7                     ; Branch if so

        setz  r9b                       ; Set register to flag overflow

istq7:  lea   rdi, [r14+rdx*8]          ; Load addr of high order quad
        xor   rbx, rbx                  ; Clear for high order result
        mov   rcx, r10                  ; Get qsz
        sub   rcx, rdx                  ; Subtract number of leading zero quads
istq8:  mov   rax, [rdi+rcx*8-8]        ; Get first/next multiplicand quad
        mul   r8                        ; Multiply by multiplier quad
        add   rax, rbx                  ; Add high order from previous loop
        jnc   istq9                     ; Brach if no carry
        add   rdx, 1                    ; Else add carry to high order
istq9:  mov   [rdi+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order
        sub   rcx, 1                    ; Decrement count
        jnz   istq8                     ; Loop for non-zero quad count

; Note that installing the high order product on the stack could result
; in the stack having an additional quad, but if this is the case it won't
; matter because the multiplication overflow exception will be taken.
; If the overflow flag is not set there is a cell available for the high
; order quad, and the sign of this quad cannot be negative because the high
; bit of the multiplier quad is not set.

        mov   [rdi-8], rdx              ; Install high order product on stack

        test  r9b, r9b                  ; Test overflow flag
        jz    istq11                    ; Finish if clear

        bt    qword[r14], 63            ; See if high order sign bit was changed
        jc    istq10                    ; Throw overflow if so

        cmp   rdx, 0                    ; Test high order result
        jz    istq11                    ; Done if zero

istq10: throwm 27                       ; Throw multiplication overflow

istq11: btr   rbp, 0                    ; Test/clear sign flag
        jnc   istq14                    ; Branch if flag was clear

        mov   rcx, r10                  ; Set counter
istq12: not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   istq12
        mov   rcx, r10                  ; Reset counter
istq13: add   qword[r14+rcx*8-8], 1
        jnc   istq14
        sub   rcx, 1
        jnz   istq13

istq14: nextm
datam

; in/uq - Divide a multi-quad integer by a single unsigned quad

head    "in/uq"
insuq:  dq   islu0
textm
islu0:  mov   r8, [r14]                 ; Pop divisor quad
        add   r14, 8

; Find leading non-zero quad.

        mov   r10, [qdsz0]              ; Get quadsize
        mov   rcx, r10                  ; Set loop counter
        xor   rdx, rdx                  ; Zero index register
islu1:  cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   islu2                     ; Exit loop if not
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   islu1

; If loop falls through dividend is zero. Branch to exit.

        jmp   islu5

; Divide by single divisor quad

islu2:  lea   rdi, [r14+rdx*8]          ; Offset to dividend MS quad
        xor   rbx, rbx                  ; Clear index register
        mov   rcx, r10                  ; Get qsz
        sub   rcx, rdx                  ; Subtract number of leading zero quads
        xor   rdx, rdx                  ; Clear remainder register
        cmp   rcx, 1                    ; See if dividend is a single quad
        jnz   islu4                     ; Branch if not

        mov   rax, [rdi+rbx*8]          ; Get single dividend quad
        div   r8                        ; Divide by single divisor quad
        cmp   rax, 0                    ; See if result is zero
        jnz   islu3                     ; Branch if not

        throwm 48                       ; Throw division underflow

islu3:  mov   [rdi+rbx*8], rax          ; Install single quotient quad
        jmp   islu5                     ; Branch to finish

islu4:  mov   rax, [rdi+rbx*8]          ; Get first/next dividend quad
        div   r8                        ; Divide by single divisor quad
        mov   [rdi+rbx*8], rax          ; Install quotient quad
        add   rbx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   islu4

islu5:  nextm
datam

; in/sq - Divide a multi-quad integer by a single quad.

head    "in/sq"
inslq:  dq   islq0
textm
islq0:  xor   rbp, rbp                  ; Clear flags register
        mov   r8, [r14]                 ; Pop divisor quad
        add   r14, 8
        mov   r10, [qdsz0]              ; Get quadsize
        bt    r8, 63                    ; Test sign of dividend
        jnc   islq1                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag if negative
        neg   r8                        ; Negate

islq1:  bt    qword[r14], 63            ; Test sign of real entry
        jnc   islq4                     ; Branch if positive

; Negate if negative

        btc   rbp, 0                    ; Complement sign flag if negative
        mov   rcx, r10                  ; Set counter
islq2:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   islq2
        mov   rcx, r10                  ; Reset counter
islq3:  add   qword[r14+rcx*8-8], 1
        jnc   islq4
        sub   rcx, 1
        jnz   islq3

; Find leading non-zero quad.

islq4:  mov   rcx, r10                  ; Set loop counter
        xor   rdx, rdx                  ; Zero index register
islq5:  cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   islq6                     ; Exit loop if not
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   islq5

; If loop falls through dividend is zero. Exit.

        jmp   islq13

; Divide by single divisor quad

islq6:  lea   rdi, [r14+rdx*8]          ; Offset to dividend MS quad
        xor   rbx, rbx                  ; Clear index register
        mov   rcx, r10                  ; Get qsz
        sub   rcx, rdx                  ; Subtract number of leading zero quads
        xor   rdx, rdx                  ; Clear remainder register
        cmp   rcx, 1                    ; See if dividend is a single quad
        jnz   islq9                     ; Branch if not

        mov   rax, [rdi+rbx*8]          ; Get single dividend quad
        div   r8                        ; Divide by single divisor quad
        cmp   rax, 0                    ; See if result is zero
        jnz   islq7                     ; Branch if not

        throwm 48                       ; Throw division underflow

islq7:  mov   [rdi+rbx*8], rax          ; Install single quotient quad
        jmp   islq10                    ; Branch to finish

islq9:  mov   rax, [rdi+rbx*8]          ; Get first/next dividend quad
        div   r8                        ; Divide by single divisor quad
        mov   [rdi+rbx*8], rax          ; Install quotient quad
        add   rbx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   islq9

islq10: btr   rbp, 0                    ; Test/clear sign flag
        jnc   islq13                    ; Branch if flag was clear

        mov   rcx, r10                  ; Set counter
islq11: not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   islq11
        mov   rcx, r10                  ; Reset counter
islq12: add   qword[r14+rcx*8-8], 1
        jnc   islq13
        sub   rcx, 1
        jnz   islq12

islq13: nextm
datam

; 2**uqin - ( uq --- in ) Calculate 2**uq as an integer in the current quadsize,
; given an unsigned 64-bit integer argument. Throws error if argument is negative.
; Also throws error if result cannot be represented in current quadsize.

head    "2**uqin"
ttuqi:  dq  ttuq0
textm
ttuq0:  bt    qword[r14], 63            ; Test sign bit
        jnc   ttuq1                     ; Branch if clear

        throwm 117                      ; Error if negative

ttuq1:  xor   rbp, rbp                  ; Zero flags register
        mov   rax, [r14]                ; Get exponent
        add   r14, 8                    ; Pop the stack
        mov   r10, [qdsz0]              ; Get quadsize
        mov   rbx, r10                  ; Copy qsz
        shl   rbx, 6                    ; Find bits in qsz
        sub   rbx, 1                    ; Subtract 1 for sign bit
        cmp   rax, rbx                  ; See if exponent is in range
        jc    ttuq2                     ; Continue if so

        throwm 54                       ; Throw error

ttuq2:  mov   rdx, r10                  ; Get qsz for new stack location
        mov   rcx, rdx                  ; Copy for stack index
        neg   rdx                       ; Make it negative
        lea   r14, [r14+rdx*8]          ; Set stack pointer
        mov   rdi, r14                  ; Copy stack pointer
        mov   r9, r10                   ; Get qsz for shifting
        xor   rbx, rbx                  ; Set fill value to 0

        shr   r9, 1                     ; Shift count right
        jnc   ttuq3                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Clear destination
        sub   rcx, 1                    ; One quad
        jnz   ttuq3
        jmp   ttuq4

; Put multi-quad integer zero on stack.

ttuq3:  ssopm 2, shcnt, dfilm

; Find bit number /mod 64.

ttuq4:  shrd  rbx, rax, 6               ; Shift low order bits out
        sar   rax, 6                    ; Divide by 64
        xor   rcx, rcx                  ; Zero register for bits shifted out
        shld  rcx, rbx, 6               ; Shift low order bits back in.
        mov   rdx, r10                  ; Get qsz
        btr   rbp, 0                    ; Test/clear sign flag
        jc    ttuq5                     ; Branch if flag was set

        sub   rdx, rax                  ; Subtract number of quads in exponent
        bts   [r14+rdx*8-8], rcx        ; Set bit
        jmp   ttuq6                     ; Branch to exit

ttuq5:  add   rdx, rax                  ; Add quads in exponent
        mov   rbx, 64
        sub   rbx, rcx                  ; Subtract bit number from 64
        bts   [r14+rdx*8], rbx          ; Set bit

ttuq6:  nextm
datam

; uqfactin - ( uq --- u!in ) Adaptive precision factorial function. Takes single
; precision unsigned integer argument and calculates the factorial in the current
; quadsize until that overflows, at which point it doubles the quadsize and
; continues. Note that the quadsize is not restored to its original value after
; the calculation! However, a negative argument will result in an error and the
; original quadsize will be restored.

head    "uqfactin"
uftin:  dq   ufti0
textm
ufti0:  bt   qword[r14], 63             ; Test sign bit
        jnc  ufti1                      ; Continue if positive

        throwm 117                      ; Throw error is negative

ufti1:  mov   rbp, [r14]                ; Get argument
        mov   r10, [qdsz0]              ; Get quadsize
        mov   r8, r10                   ; Save original quadsize

; If quadsize is 1, double it.

        cmp   r10, 1                    ; See if qsz is 1
        jnz   ufti2                     ; Branch if not

        shl   r10, 1                    ; Double qsz
        mov   [qdsz0], r10              ; Update system qsz

; Zero-extend argument to quadsize.

ufti2:  mov   rdx, r10
        sub   rdx, 1

ufti3:  sub   r14, 8                    ; Fill upper quads with zero
        mov   qword[r14], 0
        sub   rdx, 1
        jnz   ufti3

; If argument is zero, set it to 1 and exit.

        cmp   rbp, 0
        jnz   ufti4

        mov   qword[r14+r10*8-8], 1
        jmp   ufti12

; If argument is 2 or less, exit.

ufti4:  cmp   rbp, 2
        jle   ufti12

        sub   rbp, 1                    ; Initialize multiplicand
        mov   r9, 1                     ; Initialize multiplication loop count

ufti5:  mov   rdx, r10                  ; Copy quadsize
        sub   rdx, r9                   ; Subtract quad count
        lea   rdi, [r14+rdx*8]          ; Load addr of high order quad

ufti6:  xor   rbx, rbx                  ; Clear for high order result
        mov   rcx, r9                   ; Copy for count/index

ufti7:  mov   rax, [rdi+rcx*8-8]        ; Get first/next multiplicand quad
        mul   rbp                       ; Multiply by multiplier quad
        add   rax, rbx                  ; Add high order from previous loop
        jnc   ufti8                     ; Branch if no carry
        add   rdx, 1                    ; Else add carry to high order
ufti8:  mov   [rdi+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order
        sub   rcx, 1                    ; Decrement count
        jnz   ufti7                     ; Loop for quad count

        cmp   rdx, 0                    ; See if high order is zero
        jnz   ufti9                     ; Branch if not

        sub   rbp, 1                    ; Decrement count
        cmp   rbp, 2                    ; Compare with 2
        jc    ufti12                    ; Finished

        jmp   ufti6                     ; Else loop

ufti9:  mov   [rdi-8], rdx              ; Install high order product on stack
        add   r9, 1                     ; Increment quad count
        cmp   r9, r10                   ; See if equal to quadsize
        jnz   ufti11                    ; Loop if not

        shl   r10, 1                    ; Double qsz
        mov   [qdsz0], r10              ; Update system qsz
        mov   rdx, r10                  ; Copy quadsize
        sub   rdx, r9                   ; Subtract non-zero quads

; Zero-extend argument to new quadsize.

ufti10: sub   r14, 8                    ; Fill upper quads with zero
        mov   qword[r14], 0
        sub   rdx, 1
        jnz   ufti10

ufti11: sub   rbp, 1                    ; Decrement count
        cmp   rbp, 2                    ; Compare with 2
        jc    ufti12                    ; Finished

        jmp   ufti5                     ; Loop

ufti12: nextm
datam

; flsbin - ( umpi --- umpi bit# ) - Return the bit number of the leading
; set bit in the unsigned multi-precision integer on top of the stack.
; Leave the integer there and push the bit number. Throw error if number
; is negative.

head    "flsbin", lgco
flsbi:  dq  flsbi0
textm
flsbi0: bt    qword[r14], 63            ; Test sign bit
        jnc   flsbi1                    ; Branch if clear

        throwm 117                      ; Error if negative

flsbi1: mov   rcx, [qdsz0]              ; Get system quadsize
        mov   rdx, rcx                  ; Make copy
        shl   rdx, 6                    ; Convert to bits
        mov   rsi, r14                  ; Copy stack pointer
flsbi2: cmp   qword[rsi], 0             ; Find leading non-zero quad
        jne   flsbi3                    ; Branch if found

        sub   rdx, 64                   ; Subtract for each zero quad
        add   rsi, 8                    ; Advance pointer
        sub   rcx, 1                    ; Decrement count
        jnz   flsbi2                    ; Loop for count

; If loop falls through, number is zero, return -1.

        mov   rdx, -1
        jmp   flsbi4

flsbi3: bsr   rcx, [rsi]                ; Find leading set bit
        neg   rcx                       ; Subtract from 63
        add   rcx, 64
        sub   rdx, rcx

flsbi4: sub   r14, 8                    ; Push to stack
        mov   [r14], rdx
        nextm
datam

; sgnin - Return 1 if top multiquad integer is positive, -1 if it is negative,
; or 0 if it is zero. The operand is unaffected.

head    "sgnin", ario
sgnin:  dq  sgni0
textm
sgni0:  mov   rbx, [qdsz0]              ; Get quadsize
        bt    qword[r14], 63            ; Test sign of entry
        jnc   sgni1                     ; Branch if not negative

        mov   rax, -1                   ; Set signum to -1
        jmp   sgni4                     ; Branch to finish

sgni1:  lea   rsi, [r14+rbx*8]          ; Offset to ls quad of entry
        mov   rdx, -1                   ; Initialize index register
        mov   rcx, rbx                  ; Set counter to qsz
sgni2:  cmp   qword[rsi+rdx*8], 0       ; Test for zero
        jnz   sgni3                     ; Leave loop if non-zero

        sub   rdx, 1                    ; Decrement index
        sub   rcx, 1                    ; Decrement counter
        jnz   sgni2                     ; Loop

        mov   rax, 0                    ; Set signum to 0
        jmp   sgni4                     ; Branch to finish

sgni3:  mov   rax, 1                    ; Set signum to 1
sgni4:  sub   r14, 8                    ; Make room on stack
        mov   [r14], rax                ; Put signum on stack
        nextm
datam

; absin - Absolute value of multiprecision integer

head    "absin", ario
absin:  dq  absi0
textm
absi0:  bt    qword[r14], 63
        jnc   absi3

        mov   r10, [qdsz0]              ; Get quadsize
        mov   rcx, r10
absi1:  not   qword[r14+rcx*8-8]
        sub   rcx, 1
        jnz   absi1

        mov   rcx, r10
absi2:  add   qword[r14+rcx*8-8], 1
        jnc   absi3

        sub   rcx, 1
        jnz   absi2

absi3:  nextm
datam

; negin - negate multiprecision integer. Modified to start at the lowest
;       order non-zero quad.

head    "negin", ario
negin:  dq  negi0
textm
negi0:  mov   rcx, [qdsz0]              ; Get quadsize

; Find trailing non-zero quad

negi1:  cmp   qword[r14+rcx*8-8], 0     ; Scan for non-zero quad
        jnz   negi2
        sub   rcx, 1
        jnz   negi1

; If loop falls through, number is zero. Do nothing

        jmp   negi5

negi2:  mov   rbx, rcx
negi3:  not   qword[r14+rcx*8-8]
        sub   rcx, 1
        jnz   negi3

negi4:  add   qword[r14+rbx*8-8], 1
        jnc   negi5
        sub   rbx, 1
        jnz   negi4

negi5:  nextm
datam

; +in - Add the top two multi-quad integers on the stack.

head    "+in", ario
plsin:  dq  plsi0
textm
plsi0:  mov   rcx, [qdsz0]              ; Get quadsize
        lea   rdi, [r14-8]              ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Offset to second entry
        xor   rbx, rbx                  ; Zero carry register
plsi1:  mov   rdx, [rdi+rcx*8]          ; Get first/next addend
        add   [r14+rcx*8-8], rbx        ; Add carry register
        setc  al                        ; If carry results,
        movzx rax, al                   ; set rax
        add   [r14+rcx*8-8], rdx        ; Add to result
        setc  bl                        ; If carry results,
        movzx rbx, bl                   ; set rbx
        or    rbx, rax                  ; Set carry for next quad
        sub   rcx, 1                    ; Decrement counter
        jnz   plsi1                     ; Loop for quad count

        nextm
datam

; -in - Subtract the top multi-quad integer from the 2nd.

head    "-in", ario
mnsin:  dq  mnsi0
textm
mnsi0:  mov   rcx, [qdsz0]              ; Get quadsize
        lea   rdi, [r14-8]              ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Offset to second entry
        xor   rbx, rbx                  ; Zero borrow register
mnsi1:  mov   rdx, [rdi+rcx*8]          ; Get first subtrahend quad
        sub   [r14+rcx*8-8], rbx        ; Subtract borrow
        setc  al                        ; If borrow results,
        movzx rax, al                   ; set rax
        sub   [r14+rcx*8-8], rdx        ; Subtract from result
        setc  bl                        ; If borrow results,
        movzx rbx, bl                   ; set rbx
        or    rbx, rax                  ; Set borrow for next quad
        sub   rcx, 1
        jnz   mnsi1
        nextm
datam

; *in - Multiprecision integer product. If the sum of the bits in the
; absolute values of the operands (minus 1, if either operand has 0
; as its 2nd most significant bit) exceeds the number of bits in (qsz*64)-2,
; overflow will occur. 
; This operator is modeled after m*i, but it is only a single qsz operator,
; and it will throw multiplication overflow (throwm 27) if the result would
; extend beyond the current qsz or if the sign of the result changes. 

; Rstack frame usage:

;   [r15+16] - r12
;   [r15+8]  - product MS address
;   [r15]    - flags

; Register usage:

;   r12 - product pointer
;   r11 - multiplier bit count/carry register
;   r9  - multiplicand quad count
;   r8  - multiplier quad count
;   rbp - bit accumulator/inner multiplication loop counter
;   rdi - multiplicand pointer
;   rsi - multiplier pointer
;   rdx - high order product
;   rcx - counter/index register
;   rbx - multiplier
;   rax - low order product

head    "*in", ario
stri:   dq  stri0
textm
stri0:  sub   r15, 24                   ; Create frame on return stack
        mov   [r15+16], r12             ; Free up r12
        mov   qword[r15], 0             ; Initialize flags to zero
        mov   qword[r15+8], 0           ; Initialize product MS address to zero
        mov   rsi, r14                  ; Set multiplier MS address
        mov   r10, [qdsz0]              ; Get quadsize
        lea   rdi, [r14+r10*8]          ; Set multiplicand MS address

; Test sign of multiplier and negate if negative.

        bt    qword[rsi], 63            ; Test sign of multiplier
        jnc   stri3                     ; Branch if positive

        btc   qword[r15], 0             ; Complement sign flag if negative
        mov   rcx, r10                  ; Set index/counter
stri1:  not   qword[rsi+rcx*8-8]        ; Negate multiplier
        sub   rcx, 1
        jnz   stri1

        mov   rcx, r10
stri2:  add   qword[rsi+rcx*8-8], 1
        jnc   stri3
        sub   rcx, 1
        jnz   stri2

; Test sign of multiplicand and negate if negative.

stri3:  bt    qword[rdi], 63            ; Test sign of multiplicand
        jnc   stri6                     ; Branch if positive

        btc   qword[r15], 0             ; Complement sign flag if negative
        mov   rcx, r10                  ; Set counter
stri4:  not   qword[rdi+rcx*8-8]        ; Negate multiplicand
        sub   rcx, 1
        jnz   stri4

        mov   rcx, r10
stri5:  add   qword[rdi+rcx*8-8], 1
        jnc   stri6
        sub   rcx, 1
        jnz   stri5

; Find quad count and high-order bit of multiplier.

stri6:  mov   rbp, r10                  ; Copy quadsize
        shl   rbp, 6                    ; Convert to bits
        mov   r8, r10                   ; Set counter
        xor   rdx, rdx                  ; Initialize index
stri7:  cmp   qword[rsi+rdx*8], 0       ; Scan forward
        jnz   stri9

        sub   rbp, 64                   ; Subtract for each zero quad
        add   rdx, 1                    ; Increment index
        sub   r8, 1                     ; Decrement count
        jnz   stri7                     ; Loop

; If loop falls through, multiplier is zero. Overwrite multiplicand
; with multiplier.

        lea   r14, [r14+r10*8]          ; Offset stack past multiplier
        mov   rcx, r10                  ; Get qsz
stri8 : mov   rax, [rsi+rcx*8-8]        ; Overwrite multiplicand
        mov   [r14+rcx*8-8], rax
        sub   rcx, 1
        jnz   stri8

        jmp   stri25

stri9:  bsr   rcx, [rsi+rdx*8]          ; Find leading set bit
        mov   rbx, rcx                  ; Save copy
        neg   rcx                       ; Subtract from 63
        add   rcx, 64
        sub   rbp, rcx

; Add 1 to bit# for bit count

        add   rbp, 1
        mov   r11, rbp                  ; Save multiplier bit count
        cmp   rbx, 0                    ; See if bit number was zero
        jz    stri10                    ; I so, branch to set 2nd MS bit flag

        sub   rbx, 1                    ; Bit# of 2nd MS bit
        bt    [rsi+rdx*8], rbx
        jc    stri11                    ; Branch if 1

stri10: bts   qword[r15], 1             ; Set 2nd most significant digit flag

; Find quad count and high-order bit of multiplicand.

stri11: mov   rbp, r10                  ; Copy quadsize
        shl   rbp, 6                    ; Convert to bits
        mov   r9, r10                   ; Set counter
        xor   rdx, rdx                  ; Initialize index
stri12: cmp   qword[rdi+rdx*8], 0       ; Scan forward
        jnz   stri13

        sub   rbp, 64                   ; Subtract for each zero quad
        add   rdx, 1                    ; Increment index
        sub   r9, 1                     ; Decrement count
        jnz   stri12                    ; Loop

; If loop falls through, multiplicand is zero. Drop multiplier.

        lea   r14, [r14+r10*8]          ; Pop multiplicand
        jmp   stri25

stri13: bsr   rcx, [rdi+rdx*8]          ; Find leading set bit
        mov   rbx, rcx                  ; Save copy
        neg   rcx                       ; Subtract from 63
        add   rcx, 64
        sub   rbp, rcx

        cmp   rbx, 0                    ; See if bit number was zero
        jz    stri14                    ; I so, subtract 1 from combined bit

; Add 1 to bit# for bit count

        add   rbp, 1
        add   r11, rbp                  ; Add to multiplier bit count

        btr   qword[r15], 1             ; Test 2nd most bit digit flag
        jc    stri14                    ; Branch if set

; If 2nd most significant bit of either operand is zero subtract
; 1 from combined bit count.

        sub   rbx, 1
        bt    [rdi+rdx*8], rbx
        jc    stri15

stri14: sub   r11, 1                    ; Subtract 1

; Determine if overflow will occurr.

stri15: mov   rcx, r10                  ; Copy quadsize
        shl   rcx, 6                    ; Convert to bits
        sub   rcx, 2                    ; Subtract 2
        cmp   rcx, r11                  ; Compare combined operand bits
        jnc   stri16

        throwm 27                       ; Throw multiplication overflow

; Clear stack space for product and set product MS address.

stri16: mov   r12, r14                  ; Copy stack pointer
        mov   rcx, r10                  ; Copy qsz
stri17: sub   r12, 8                    ; Clear stack space for product
        mov   qword[r12], 0
        sub   rcx, 1                    ; Decrement counter
        jnz   stri17                    ; Loop

        mov   [r15+8], r12              ; Save result MS address

; Use operand with the biggest quad count for inner loop.

        cmp   r8, r9
        jna   stri18                    ; Multiplicand quad count greater or equal

        xchg  r9, r8                    ; Else exchange counts
        xchg  rsi, rdi                  ; and addresses

; Begin multiplication loop

stri18: lea   rsi, [rsi+r10*8-8]        ; Set pointer to low order multiplier

stri19: xor   r11, r11                  ; Clear carry register
        mov   rbx, [rsi]                ; Get first/next multiplier quad.
        test  rbx, rbx                  ; Skip multiplication if operand
        jz    stri21                    ; is zero
        mov   rcx, r10                  ; Set/reset index register
        mov   rbp, r9                   ; Set/reset inner loop counter

; Begin inner multiplication loop

stri20: mov   rax, rbx                  ; Copy multiplier quad
        mul   qword[rdi+rcx*8-8]        ; Multiply by first/next multiplicand quad
        add   rdx, r11                  ; Add carry from previous loop
        add   [r12+rcx*8-8], rax        ; Add low order to result
        adc   [r12+rcx*8-16], rdx       ; Add high order to result
        setc  r11b                      ; Save state of carry
        movzx r11, r11b                 ; Extend for adding in on next loop
        sub   rcx, 1                    ; Decrement index
        sub   rbp, 1                    ; Decrement counter
        jnz   stri20                    ; Loop

stri21: sub   r12, 8                    ; Decrement product pointer
        sub   rsi, 8                    ; Decrement operand pointer
        sub   r8, 1                     ; Decrement outer loop counter
        jnz   stri19                    ; Loop

; Overwrite multiplicand with result.

        mov   r12, [r15+8]              ; Get saved product MS address
        lea   r14, [r14+r10*8]          ; Offset stack past multiplier
        mov   rcx, r10                  ; Get qsz
stri22: mov   rax, [r12+rcx*8-8]
        mov   [r14+rcx*8-8], rax
        sub   rcx, 1
        jnz   stri22

; Negate result if one of the operands is negative.

        btr   qword[r15], 0             ; Test and clear sign flag
        jnc   stri25                    ; Branch if flag was clear
        mov   rcx, r10                  ; Copy qsz
stri23: not   qword[r14+rcx*8-8]        ; Negate product
        sub   rcx, 1
        jnz   stri23
        mov   rcx, r10
stri24: add   qword[r14+rcx*8-8], 1
        jnc   stri25
        sub   rcx, 1
        jnz   stri24

stri25: mov   r12, [r15+16]             ; Restore r12
        add   r15, 24                   ; Release rstack frame
        nextm
datam

; m*in - Multiply two qsz integers for a 2*qsz product. Overflow can't
; happen.
;
; Rstack frame usage:

;   [r15+16] - r12
;   [r15+8]  - sign flag
;   [r15]    - product MS address

; Register usage:

;   r12 - product pointer
;   r11 - carry register
;   r9  - multiplicand quad count
;   r8  - multiplier quad count
;   rbp - inner multiplication loop counter
;   rdi - multiplicand pointer
;   rsi - multiplier pointer
;   rdx - high order product
;   rcx - counter/index register
;   rbx - multiplier
;   rax - low order product

head    "m*in", ario
msti:   dq  msti0
textm
msti0:  sub   r15, 24                   ; Create frame on return stack
        mov   [r15+16], r12             ; Free up r12

; Clear slots for product MS address and sign flag.

        mov   qword[r15], 0             ; Initialize rstack frame space to zero
        mov   qword[r15+8], 0

; Clear stack space for product and set product MS address.

        mov   r12, r14                  ; Copy stack pointer
        mov   r10, [qdsz0]              ; Get quadsize
        mov   rcx, r10                  ; Copy qsz
        shl   rcx, 1                    ; Double it
msti1:  sub   r12, 8                    ; Clear stack space for product
        mov   qword[r12], 0
        sub   rcx, 1                    ; Decrement counter
        jnz   msti1                     ; Loop

        mov   [r15], r12                ; Save result MS address
        lea   r12, [r12+r10*8]          ; Load product pointer
        mov   rsi, r14                  ; Set multiplier MS address
        lea   rdi, [r14+r10*8]          ; Set multiplicand MS address

; Test sign of multiplier and negate if negative.

        bt    qword[rsi], 63            ; Test sign of multiplier
        jnc   msti4                     ; Branch if positive

        btc   qword[r15+8], 0           ; Complement sign flag if negative
        mov   rcx, r10                  ; Set counter
msti2:  not   qword[rsi+rcx*8-8]        ; Negate multiplier
        sub   rcx, 1
        jnz   msti2

        mov   rcx, r10
msti3:  add   qword[rsi+rcx*8-8], 1
        jnc   msti4

        sub   rcx, 1
        jnz   msti3

; Test sign of multiplicand and negate if negative.

msti4:  bt    qword[rdi], 63            ; Test sign of multiplicand
        jnc   msti7                     ; Branch if positive

        btc   qword[r15+8], 0           ; Complement sign flag if negative
        mov   rcx, r10                  ; Set counter
msti5:  not   qword[rdi+rcx*8-8]        ; Negate multiplicand
        sub   rcx, 1
        jnz   msti5

        mov   rcx, r10
msti6:  add   qword[rdi+rcx*8-8], 1
        jnc   msti7

        sub   rcx, 1
        jnz   msti6

; Find lead quad of multiplier.

msti7:  xor   rdx, rdx
        mov   r8, r10
msti8:  cmp   qword[rsi+rdx*8], 0       ; Scan forward
        jnz   msti9

        add   rdx, 1
        sub   r8, 1
        jnz   msti8

; If loop falls through, multiplier is zero. Clear sign flag in case other
; operand is negative.

        btr   qword[r15+8], 0
        jmp   msti16

; Find lead quad of multiplicand.

msti9:  xor   rdx, rdx
        mov   r9, r10
msti10: cmp   qword[rdi+rdx*8], 0       ; Scan forward
        jnz   msti11

        add   rdx, 1
        sub   r9, 1
        jnz   msti10

; If loop falls through, multiplicand is zero. Clear sign flag in case other
; operand is negative.

        btr   qword[r15+8], 0
        jmp   msti16

; Use operand with the biggest quad count for inner loop.

msti11: cmp   r8, r9
        jna   msti12                    ; Multiplicand quad count greater or equal

        xchg  r9, r8                    ; Else exchange counts
        xchg  rsi, rdi                  ; and addresses

; Begin multiplication loop

msti12: lea   rsi, [rsi+r10*8-8]        ; Set pointer to low order multiplier

msti13: xor   r11, r11                  ; Clear carry register
        mov   rbx, [rsi]                ; Get first/next multiplier quad.
        test  rbx, rbx                  ; Skip multiplication if operand
        jz    msti15                    ; is zero

        mov   rcx, r10                  ; Set/reset index register
        mov   rbp, r9                   ; Set/reset inner loop counter

; Begin inner multiplication loop

msti14: mov   rax, rbx                  ; Copy multiplier quad
        mul   qword[rdi+rcx*8-8]        ; Multiply by first/next multiplicand quad
        add   rdx, r11                  ; Add carry from previous loop
        add   [r12+rcx*8-8], rax        ; Add low order to result
        adc   [r12+rcx*8-16], rdx       ; Add high order to result
        setc  r11b                      ; Save state of carry
        movzx r11, r11b                 ; Extend for adding in on next loop
        sub   rcx, 1                    ; Decrement index
        sub   rbp, 1                    ; Decrement counter
        jnz   msti14                    ; Loop

msti15: sub   r12, 8                    ; Decrement product pointer
        sub   rsi, 8                    ; Decrement operand pointer
        sub   r8, 1                     ; Decrement outer loop counter
        jnz   msti13

; Overwrite operands with result.

msti16: mov   r12, [r15]                ; Get saved product MS address
        mov   r8, r10
        shl   r8, 1
        mov   rcx, r8
msti17: mov   rax, [r12+rcx*8-8]
        mov   [r14+rcx*8-8], rax
        sub   rcx, 1
        jnz   msti17

; Negate result if one of the operands is negative.

        btr   qword[r15+8], 0           ; Test and clear sign flag
        jnc   msti20

        mov   rcx, r8                   ; Copy double qsz
msti18: not   qword[r14+rcx*8-8]        ; Negate product
        sub   rcx, 1
        jnz   msti18

msti19: add   qword[r14+r8*8-8], 1
        jnc   msti20

        sub   r8, 1
        jnz   msti19

msti20: mov   r12, [r15+16]             ; Restore r12
        add   r15, 24
        nextm
datam

; /modin - Multiprecision division with remainder. Normalization puts
; the trial quotient at most two more than the actual quotient.

; (c) Copyright 2013-2018 John F. Healy

; Rstack frame usage:

;  [r15+112] - r13
;  [r15+104] - r12
;  [r15+96]  - r11
;  [r15+88]  - flags
;  [r15+80]  - auxiliary track vector
;  [r15+72]  - shift count
;  [r15+64]  - extra dividend cell
;  [r15+56]  - quotient ms address / scratch area ls address
;  [r15+48]  - divisor ls address / dividend ms address
;  [r15+40]  - quad count for addback
;  [r15+32]  - subtraction point in dividend
;  [r15+24]  - qhat
;  [r15+16]  - quotient quad count
;  [r15+8]   - dividend quad count
;  [r15]     - divisor quad count

; Register usage

;    r13 - divisor ms address
;    r12 - dividend ms address
;    r11 - quotient ms address
;    r10 - quad size
;    r9  - loop vector / shift count
;    r8  - scratch
;    rbp - return address for subroutines
;    rdi - scratch / addressing
;    rsi - scratch / addressing
;    rdx - scratch index / division & multiplication
;    rcx - scratch / counter
;    rbx - scratch
;    rax - scratch / division & multiplication

head    "/modin", ario
slmi:   dq  slmi0
textm
slmi0:  sub   r15, 112                  ; Create frame on return stack
        mov   [r15+104], r13            ; Free up registers
        mov   [r15+96], r12
        mov   qword[r15+88], 0          ; Zero flags
        mov   qword[r15+72], 0          ; Zero shift count

; Clear stack space for quotient and save quotient MS address

        mov   rdi, r14                  ; Copy stack pointer
        mov   r10, [qdsz0]              ; Get quadsize
        mov   rcx, r10
slmi1:  sub   rdi, 8                    ; Clear stack space for quotient
        mov   qword[rdi], 0
        sub   rcx, 1                    ; Decrement counter
        jnz   slmi1                     ; Loop
        mov   [r15+56], rdi             ; Save quotient MS addr

; Test sign of divisor and negate if negative

        bt    qword[r14], 63            ; Test sign of divisor
        jnc   slmi4                     ; Branch if positive
        btc   qword[r15+88], 0          ; Complement sign flag if negative
        mov   rcx, r10                  ; Set counter
slmi2:  not   qword[r14+rcx*8-8]        ; Negate divisor
        sub   rcx, 1
        jnz   slmi2
        mov   rcx, r10
slmi3:  add   qword[r14+rcx*8-8], 1
        jnc   slmi4
        sub   rcx, 1
        jnz   slmi3

; Test sign of dividend and negate if negative

slmi4:  lea   rdi, [r14+r10*8]          ; Offset to dividend
        bt    qword[rdi], 63            ; Test sign of dividend
        jnc   slmi7                     ; Branch if positive
        btc   qword[r15+88], 0          ; Complement sign flag if negative
        mov   rcx, r10                  ; Set counter
slmi5:  not   qword[rdi+rcx*8-8]        ; Negate dividend
        sub   rcx, 1
        jnz   slmi5
        mov   rcx, r10
slmi6:  add   qword[rdi+rcx*8-8], 1
        jnc   slmi7
        sub   rcx, 1
        jnz   slmi6

; Find lead quad of divisor. Set divisor ms address and quad count.
; Put divisor lead quad in rstack frame in case no shift is needed.

slmi7:  mov   r13, r14                  ; Copy stack pointer
        mov   rcx, r10                  ; Copy qsz
slmi8:  cmp   qword[r13], 0             ; Test for zero
        jnz   slmi9                     ; If non-zero, leave loop
        add   r13, 8                    ; Increment pointer
        sub   rcx, 1                    ; Decrement qsz count
        jnz   slmi8                     ; Loop
        jz    slmi91                    ; If loop falls through, divisor is zero

slmi9:  cmp   rcx, 1                    ; If divisor is only one quad
        jz    slmi89                    ; use simpler routine
        mov   [r15], rcx                ; Save divisor quad count

; Find lead quad of dividend. Set dividend ms address and quad count.

        lea   r12, [r14+r10*8]          ; Load offset to dividend
        mov   [r15+48], r12             ; Save as divisor LS addr

; Here the quotient pointer is initialized to the low order divisor quad
; in case there is only one quotient quad.

        lea   r11, [r12-8]              ; Initialize quotient pointer

; Save dividend ls address as initial dividend subtraction point

        lea   rsi, [r12+r10*8]          ; Load dividend ls address
        mov   [r15+32], rsi             ; Save in rstack frame

        mov   rcx, r10                  ; Copy qsz
slmi10: cmp   qword[r12], 0             ; Test for zero
        jnz   slmi11                    ; If non-zero, leave loop
        add   r12, 8                    ; Increment pointer
        sub   rcx, 1                    ; Decrement qsz count
        jnz   slmi10                    ; Loop
        jmp   slmi75                    ; Dividend is zero

slmi11: mov   [r15+8], rcx              ; Save dividend quad count

; Calculate lead-quad difference between dividend and divisor.
; Eliminate case of divisor greater than dividend.

slmi12: sub   rcx, [r15]                ; Find quadword difference
        jc    slmi75                    ; Divisor is greater than dividend
        jnz   slmi14                    ; Dividend > divisor, continue

; If divisor and dividend quad counts are equal, there are three cases.
; The divisor may be larger than the dividend. The divisor and dividend
; may be the same. Or the dividend may be larger than the divisor.
; If the divisor is larger, the quotient is zero and the remainder is equal
; to the dividend.
; If the operands are equal, the quotient is 1, and the remainder is zero.
; If the dividend is larger, the quotient will be a single quad.
; This case will also be treated as special.

        mov   rbx, [r15]                ; Use divisor quadsize for count
        xor   rdx, rdx                  ; Zero index register
slmi13: mov   rax, [r13+rdx*8]          ; Compare first/next quad of divisor
        cmp   [r12+rdx*8], rax          ; with dividend quad
        jc    slmi75                    ; Branch if divisor is greater
        jnz   slmi77                    ; If not equal, dividend is greater
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   slmi13                    ; Loop for count

; If loop falls through, divisor and dividend are equal. Deal with special
; case

        jmp   slmi72

; Tentatively set the number of quotient quads to n-m+1 and the quotient
; lead-quad address and dividend subtraction point accordingly. Then if the
; divisor lead quad is greater than the dividend lead quad, subtract 1 from
; the quotient quad count and add 8 to the quotient pointer and to the
; dividend subtraction point.

slmi14: add   rcx, 1                    ; Add 1 to quotient digit count
        mov   [r15+16], rcx             ; Save quotient digit count in rstack frame
        shl   rcx, 3                    ; Convert count to byte offset
        mov   r11, r14                  ; Copy stack pointer
        sub   r11, rcx                  ; Offset to quotient ms address
        sub   [r15+32], rcx             ; Set dividend subtraction point
        bts   qword[r15+88], 1          ; Set quotient adjustment flag

; Single out cases of identical divisor and dividend lead quads and
; establish quotient digit count and lead quad address.

        mov   rbx, [r15]                ; Use divisor quadsize for count
        xor   rdx, rdx                  ; Zero index register
slmi16: mov   rax, [r13+rdx*8]          ; Compare first/next quad of divisor
        cmp   [r12+rdx*8], rax          ; with dividend quad
        jc    slmi26                    ; Branch if divisor is greater
        jnz   slmi17                    ; If not equal, dividend is greater
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   slmi16                    ; Loop for count

; If loop falls through, all of the divisor quads are equal to the leading
; dividend quads.

; If there is at least one identical lead quad pair, jump to leaf function
; to subtract divisor from dividend and set quotient digit to 1.

slmi17: cmp   rdx, 1                    ; At least one identical lead quad pair?
        jc    slmi28                    ; Branch if not

; Jump to subroutine to subtract divisor from dividend and set quotient digit
; to 1.

        lea   rbp, [slmi18]             ; Set return vector
        jmp   sbdv0                     ; Subtract and install quotient digit

slmi18: add   qword[r15+32], 8          ; Advance dividend subtraction point
        add   r11, 8                    ; Advance quotient pointer
        sub   qword[r15+16], 1          ; Decrement quotient quad count
        jz    slmi68                    ; Division finished if count exhausted
        sub   rdx, 1                    ; Decrement identical quad count
        jz    slmi20                    ; Branch if count exhausted

slmi19: add   r12, 8                    ; Advance dividend pointer
        add   qword[r15+32], 8          ; Advance dividend subtraction point
        sub   qword[r15+8], 1           ; Decrement dividend quad count
        mov   qword[r11], 0             ; Install 0 in quotient
        add   r11, 8                    ; Advance quotient pointer
        sub   qword[r15+16], 1          ; Decrement quotient quad count
        jz    slmi68                    ; Leave loop if count exhausted
        sub   rdx, 1                    ; Decrement identical quad count
        jnz   slmi19                    ; Loop until counter exhausted

slmi20: btr   qword[r15+88], 1          ; Clear quotient adjustment flag

; Continue comparing divisor and dividend quads. If the divisor quad count
; is greater than the remaining dividend quad count, division is finished.
; If the quad counts are the same, treat this case as special.

        xor   rdx, rdx                  ; Zero index register
        mov   rbx, [r15]                ; Get divisor quadsize
        cmp   rbx, [r15+8]              ; Compare with dividend quad count
        jc    slmi16                    ; Branch if divisor quad count is less
        jz    slmi22                    ; Branch if equal
        jmp   slmi70                    ; Else division is finished

slmi22: mov   rax, [r13+rdx*8]          ; Compare first/next quad of divisor
        cmp   [r12+rdx*8], rax          ; with dividend quad
        jc    slmi24                    ; Branch if divisor is greater
        jnz   slmi17                    ; If not equal, dividend is greater
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   slmi22                    ; Loop for count

; If loop falls through, the dividend and divisor quads are equal.

        jmp   slmi17

; If dividend is less than divisor, all remaining quotient quads are 0.

slmi24: mov   rcx, [r15+16]             ; Get quotient quad count
slmi25: mov   qword[r11], 0             ; Zero remaining quotient quads
        add   r11, 8                    ; Advance quotient pointer
        sub   rcx, 1                    ; Decrement count
        jnz   slmi25                    ; Loop for count
        jmp   slmi70                    ; Division is finished

; Divisor is greater. If quotient adjustment flag is set, decrement quotient
; digit count, advance quotient pointer, and set starting point for
; subtraction from dividend.

slmi26: bt    qword[r15+88], 1          ; Test quotient adjustment flag
        jnc   slmi28                    ; Branch if flag is clear
        sub   qword[r15+16], 1          ; Decrement quotient digit count
        add   r11, 8                    ; Advance quotient digit pointer
        add   qword[r15+32], 8          ; Advance dividend subtraction point

; See if divisor lead quad is already normalized

slmi28: btr   qword[r15+88], 1          ; Clear quotient adjustment flag
        mov   rax, [r13]                ; Get first divisor quad
        bt    rax, 63                   ; See if high order divisor bit is set
        jnc   slmi29                    ; Branch if not

        lea   r9, [slmi44]              ; Set vector to Track2
        jmp   r9                        ; Take vector

; See if shifting needed. No shifting is needed if divisor lead quad is
; greater than or equal to the 2nd quad.

slmi29: cmp   rax, [r13+8]              ; Compare 2nd divisor quad with 1st
        jc    slmi30                    ; Shift if 2nd is greater

        lea   r9, [slmi40]              ; Set vector to Track1
        jmp   r9                        ; Take vector

; Find divisor shift count. We have already tested for a shift count
; of zero.

slmi30: xor   r8, r8                    ; Zero register
        bsr   r8, [r13]                 ; Find leading set bit of divisor
        mov   r9, r8                    ; Save copy
        neg   r8                        ; Negate
        add   r8, 63                    ; Add 63 for shift count
        mov   [r15+72], r8              ; Put shift count in rstack frame

; Shift divisor

        mov   rbx, [r15]                ; Get divisor quad count
        mov   rcx, r8                   ; Copy shift count
        xor   rdx, rdx                  ; Clear index register
        sub   rbx, 1                    ; One less for last shift
        jz    slmi32                    ; Branch if divisor is only 1 quad
slmi31: mov   rax, [r13+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r13+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   slmi31                    ; Loop

slmi32: shl   qword[r13+rdx*8], cl      ; Shift last quad

; Find lead bit of dividend.

        xor   rbx, rbx                  ; Zero register
        bsr   rbx, [r12]                ; Find lead bit of dividend

; If lead bit of dividend is to the left of divisor lead bit, test to see
; if the dividend quad count is the same as the system quad size. If so,
; use special subroutine to eliminate 1st dividend quad.

        cmp   r9, rbx                   ; Compare lead bits
        jnc   slmi35                    ; Branch if within same quad

        cmp   r10, [r15+8]              ; Compare dividend quad count with qsz
        jz    slmi33                    ; Branch if they are equal

        sub   r12, 8                    ; Back up dividend quad pointer
        add   qword[r15+8], 1           ; Increment dividend quad count
        jmp   slmi35                    ; Go shift dividend

; Jump to subroutine to handle special case of extra dividend cell.

slmi33: lea   rbp, [slmi37]
        jmp   slmdx

; Shift dividend.

slmi35: xor   rdx, rdx                  ; Clear index register
        mov   rbx, [r15+8]              ; Get dividend quad count
        sub   rbx, 1                    ; One less for last shift
slmi36: mov   rax, [r12+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r12+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   slmi36                    ; Loop

        shl   qword[r12+rdx*8], cl      ; Shift single quad

slmi37: lea   r9, [slmi44]              ; Set vector to Track2
        jmp   r9                        ; Take vector

; Beginning of main loop. Compare dividend lead quad with divisor lead quad,
; and deal with the situation where the high order dividend quad is greater
; than or equal to the divisor lead quad, since this will result in overflow
; if the division is carried out.

; Track1 - No shifting is needed.

slmi40: mov   rdx, [r12]                ; Get 1st dividend quad
        cmp   [r13], rdx                ; Compare with 1st divisor quad
        jz    slmi50                    ; Branch if quads are equal
        jc    slmi41                    ; Overflow if dividend quad greater
        mov   rax, [r12+8]              ; Get 2nd dividend quad
        jmp   slmi55                    ; Go divide

; Track1 overflow procedure. Put new vector in register to handle dividend
; pointer upon return.

slmi41: lea   r9, [slmi42]              ; Set return vector
        mov   rax, rdx                  ; Put high order dividend in low order
        xor   rdx, rdx                  ; Zero high order
        jmp   slmi55                    ; Go divide

slmi42: sub   r12, 8                    ; Back up dividend pointer
        add   qword[r15+8], 1           ; Increment dividend quad co
        lea   r9, [slmi40]              ; Restore vector
        jmp   r9                        ; Take vector

; Track2 - Operand quads shifted.

slmi44: mov   rdx, [r12]                ; Get 1st dividend quad
        cmp   [r13], rdx                ; Compare with 1st divisor quad
        jz    slmi50                    ; Branch if quads are equal
        jc    slmi45                    ; Overflow if dividend quad greater
        mov   rax, [r12+8]              ; Get 2nd dividend quad
        jmp   slmi55                    ; Go divide

; Track2 overflow procedure. Subtract divisor from high order dividend and
; set quotient digit to 1. Since the current dividend quad won't be
; eliminated by the subtraction, the dividend quad pointer and quad count
; are not changed, but the dividend subtraction point must be advanced
; with each quotient digit!

slmi45: lea   rbp, [slmi46]
        jmp   sbdv0

slmi46: add   qword[r15+32], 8          ; Advance dividend subtraction point
        add   r11, 8                    ; Advance quotient pointer
        sub   qword[r15+16], 1          ; Decrement quotient quad count
        jz    slmi68                    ; Division finished if count exhausted
        jmp   r9                        ; Take vector

; If lead quads are identical, set qhat to b-1 and carry out
; multiplication/subtraction step.

slmi50: mov   qword[r15+24], -1         ; Set qhat to b-1
        lea   rbp, [slmi51]             ; Set return address
        jmp   muls0                     ; Carry out multiplication/subtraction

slmi51: lea   rbp, [slmi52]             ; Set return address
        jmp   qdig0                     ; Install quotient quad and adjust pointers

slmi52: cmp   qword[r15+16], 0          ; See if quotient quad count exhausted
        jz    slmi68                    ; Leave loop if count exhausted

        jmp   r9                        ; Else continue

; Divide for qhat. Although the algorithm works without checking for a
; quotient of 0 or 1, the multiplication/subtraction/correction step is
; unnecessary in these cases. If quotient is 0, simply install it,
; if quotient is 1, subtract divisor from dividend and install it.
; Actually, the latter approach may not work, since when the quotient digit
; is 1, the subtraction may produce a borrow!

slmi55: div   qword[r13]                ; Divide u1'*b+u2' by v1' for qhat
        mov   [r15+24], rax             ; Save qhat

        lea   rbp, [slmi57]             ; Set return address
        jmp   muls0                     ; Carry out multiplication/subtraction

slmi57: lea   rbp, [slmi59]             ; Set return address
        jmp   qdig0                     ; Install quotient quad and adjust pointers

slmi59: cmp   qword[r15+16], 0          ; See if quotient quad count exhausted
        jz    slmi68                    ; Leave loop if count exhausted
        jmp   r9                        ; Else loop

; Shift remainder right. The divisor quad count plus 1 is used
; as the counter, which is ordinarily decremented by 1 for the shift
; operation. Here we just don't add the 1.The count is always more than
; 1 since the case of a single divisor quad is handled separately.

slmi68: mov   rcx, [r15+72]             ; Get shift count
        test  rcx, rcx                  ; See if count is zero
        jz    slmi70                    ; Branch if so

        mov   rdi, [r15+48]             ; Get dividend ms address
        lea   rdi, [rdi+r10*8-8]        ; Offset to low order quad
        mov   rbx, [r15]                ; Use divisor quad count
slmi69: mov   rax, [rdi-8]              ; Shift q[n-1] into q[n]
        shrd  [rdi], rax, cl
        sub   rdi, 8                    ; Decrement remainder pointer
        sub   rbx, 1                    ; Decrement count
        jnz   slmi69

; Overwrite divisor with quotient

slmi70: mov   rcx, r10                  ; Copy quad size
        mov   rdi, r14                  ; Copy stack pointer/divisor ms address
        mov   rsi, [r15+56]             ; Get quotient ms address
slmi71: mov   rdx, [rsi+rcx*8-8]        ; Overwrite divisor
        mov   [rdi+rcx*8-8], rdx        ; with quotient
        sub   rcx, 1
        jnz   slmi71                    ; Loop for quad size
        jmp   slmi92                    ; Go test sign flag

; If divisor and dividend are equal, quotient is one and remainder zero

slmi72: mov   rcx, r10                  ; Copy quad size for index
        mov   rbx, r10                  ; and count
        shl   rcx, 1                    ; Double qsz for index
slmi73: mov   qword[r14+rcx*8-8], 0     ; Zero remainder
        sub   rcx, 1                    ; Decrement index
        sub   rbx, 1                    ; Decrement count
        jnz   slmi73
        mov   qword[r14+rcx*8-8], 1     ; Install 1 for quotient
        mov   rbx, r10                  ; Reset counter
        sub   rbx, 1                    ; and subtract one for installed digit
        sub   rcx, 1
slmi74: mov   qword[r14+rcx*8-8], 0     ; Zero remaining quotient digits
        sub   rcx, 1
        sub   rbx, 1
        jnz   slmi74
        jmp   slmi92                    ; Go test sign flag

; If divisor is greater than dividend, overwrite dividend
; with divisor and clear divisor cell for zero quotient

slmi75: mov   rcx, r10                  ; Copy quad size
        mov   rsi, r14                  ; Copy stack pointer/divisor ms address
        lea   rdi, [r14+r10*8]
slmi76: mov   rdx, [rsi+rcx*8-8]        ; Overwrite dividend with divisor
        mov   qword[rsi+rcx*8-8], 0     ; and install zero in quotient
        mov   [rdi+rcx*8-8], rdx
        sub   rcx, 1
        jnz   slmi76                    ; Loop for quad size
        jmp   slmi92                    ; Go test sign flag

; If divisor and dividend quad counts are equal, but the dividend
; is larger, one quotient quad will result. If the lead quads of divisor
; and dividend are equal, the quotient will be 1, and the remainder will be
; the dividend minus the divisor. This is also true if the divisor is
; already normalized, or if the divisor and dividend have the same lead bit.

slmi77: sub   qword[r15+32], 8          ; Set subtraction point to low dividend
        cmp   rdx,1                     ; See if lead quads are equal
        jnc   slmi85                    ; Branch if so
        bt    qword[r13], 63            ; Test high order bit of divisor
        jc    slmi85                    ; Branch if bit set

        mov   r8, [r13]                 ; Get first divisor quad
        mov   r9, [r13+8]               ; Get second divisor quad
        cmp   r9, r8                    ; Compare 1st quad with 2nd
        jnc   slmi78                    ; Go find lead bits

; No shift is needed

        xor   rdx, rdx
        mov   rax, [r12]                ; Get first dividend quad
        jmp   slmi80                    ; Go divide

slmi78: bsr   rcx, [r13]                ; Find lead bit of divisor
        bsr   rbx, [r12]                ; Find lead bit of dividend
        cmp   rcx, rbx                  ; Compare lead bits
        jz    slmi85                    ; Branch if they are equal

        neg   rcx                       ; Calculate shift count
        add   rcx, 63                   ; Add 63 for shift count
        shld  r8, r9, cl                ; Shift 2nd quad into 1st quad
        mov   rbx, [r13+16]             ; Get 3rd divisor quad
        shld  r9, rbx, cl               ; Shift 3rd into 2nd

        xor   rdx, rdx                  ; Clear high order dividend for shift
        mov   rax, [r12]                ; Get 1st dividend quad
        mov   rbx, [r12+8]              ; Get 2nd dividend quad
        shld  rdx, rax, cl              ; Shift 1st quad into high order dividend
        shld  rax, rbx, cl              ; Shift 2nd quad into 1st

slmi80: div   r8                        ; Divide for qhat
        mov   [r15+24], rax             ; Save qhat

; Clear out space for product, multiply divisor by estimated quotient
; digit, and subtract the result from the dividend. If the result is
; negative, decrement qhat.

        lea   rbp, [slmi81]             ; Set return address
        jmp   muls0                     ; Carry out multiplication/subtraction

slmi81: lea   rbp, [slmi82]             ; Set return address
        jmp   qdig0                     ; Install quotient quad and adjust pointers

slmi82: sub   r11, 8                    ; Back up quotient pointer
        jmp   slmi86                    ; Finish installing quotient

; Subtract divisor from dividend and install 1 for quotient digit.

slmi85: lea   rbp, [slmi86]             ; Set return address
        jmp   sbdv0

; At this point the single quotient quad is installed in the low order quad
; of the divisor. Zero the remaining divisor quads.

slmi86: mov   rcx, r10                  ; Get qsz
        sub   rcx, 1                    ; Subtract 1 for quotient quad
slmi87: sub   r11, 8                    ; Decrement pointer
        mov   qword[r11], 0             ; Install 0
        sub   rcx, 1                    ; Decrement count
        jnz   slmi87                    ; Loop

        jmp   slmi92                    ; Go test sign flags

; Divide by single divisor quad

slmi89: xor   rdx, rdx                  ; Clear remainder register
        lea   rsi, [r14+r10*8]          ; Offset to dividend
        mov   rdi, r14                  ; Copy stack pointer/divisor ms address
        mov   rbx, [rsi-8]              ; Get single divisor quad
        mov   rcx, r10                  ; Copy qsz
slmi90: mov   rax, [rsi]                ; Get first/next dividend quad
        mov   qword[rsi], 0             ; Replace it with zero
        div   rbx
        mov   [rdi], rax                ; Install quotient quad
        add   rdi, 8                    ; Advance pointers
        add   rsi, 8
        sub   rcx, 1                    ; Decrement count
        jnz   slmi90
        mov   [rsi-8], rdx              ; Install single remainder quad
        jmp   slmi92                    ; Go test sign flags

; Subroutine for handling an extra dividend quad.

; slmdx
; This is a subroutine that takes care of the first dividend quad
; if an extra cell is required. The division that eliminates the
; extra quad is carried out before continuing with the other quads.

slmdx   xor   rdi, rdi                  ; Clear shift register
        mov   rax, [r12]
        shld  rdi, rax, cl              ; Shift leading bits into extra cell
        mov   [r15+64], rdi             ; Save shifted lead quad in rstack frame

        xor   rdx, rdx                  ; Clear index register
        mov   rbx, [r15+8]              ; Get dividend quad count
        sub   rbx, 1                    ; One less for last shift
slmx1:  mov   rax, [r12+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r12+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   slmx1
        shl   qword[r12+rdx*8], cl      ; Shift single quad

        mov   rdx, rdi                  ; Put u1'*b+u2' in dividend registers
        mov   rax, [r12]

        div   qword[r13]                ; Divide u1'*b+u2' by v1' for qhat
        mov   [r15+24], rax             ; Save qhat

; Clear out space for product, multiply divisor by estimated quotient
; digit. The product will be either the same number of digits as the divisor
; or one more digit than the divisor. Determine which at the end of
; multiplication by testing the high order result. This information will be
; needed by the subtraction process.

        mov   rdi, [r15+56]             ; Get LS addr of scratch area
        mov   rsi, rdi                  ; Make copy
        mov   rcx, [r15]                ; Get divisor quad count
        mov   rbx, rcx                  ; Save copy
        add   rcx, 1                    ; Clear one more cell
slmx2:  sub   rdi, 8                    ; Clear stack space for product
        mov   qword[rdi], 0             ; of divisor and estimated quotient
        sub   rcx, 1                    ; Decrement counter
        jnz   slmx2                     ; Loop

        mov   r8,  [r15+24]             ; Get qhat
        mov   rdi, [r15+48]             ; Get divisor ls addr
        mov   rcx, rbx                  ; Copy divisor quad count
        xor   rbx, rbx                  ; Clear register for carry
        sub   rdi, 8                    ; Offset to first quad
        sub   rsi, 8                    ; of divisor and product
slmx3:  mov   rax, [rdi]                ; Get first/next divisor quad
        mul   r8                        ; Multiply by qhat
        add   rdx, rbx                  ; Add carry from previous loop
        add   [rsi], rax                ; Add low order to product
        adc   [rsi-8], rdx              ; Add high order with carry to product
        setc  bl                        ; Save state of carry in bl.
        movzx rbx, bl                   ; Zero-extend for adding to next result
        sub   rsi, 8                    ; Decrement pointers
        sub   rdi, 8
        sub   rcx, 1
        jnz   slmx3

        mov   rcx, [r15]                ; Get divisor quad count
        cmp   qword[rsi], 0             ; See if high order product is zero
        jz    slmx4                     ; Branch if so
        add   rcx, 1                    ; Else add 1 to product quad count

; Subtract properly aligned product from dividend

slmx4:  mov   rsi, [r15+56]             ; Get product ls address
        sub   rsi, 8                    ; Offset to low order quad
        mov   rdi, [r15+32]             ; Get dividend subtraction point
        mov   r8, rdi                   ; Save subtraction point for addback
        mov   [r15+40], rcx             ; Save quad count for addback
        xor   rbx, rbx                  ; Zero borrow register
slmx5:  mov   rdx, [rsi]                ; Get first/next subtrahend quad
        sub   [rdi], rbx                ; Subtract borrow
        setc  al                        ; If borrow results,
        movzx rax, al                   ; set rax
        sub   [rdi], rdx                ; Subtract from result
        setc  bl                        ; If borrow results,
        movzx rbx, bl                   ; set rbx
        or    rbx, rax                  ; Set borrow for next quad
        sub   rdi, 8                    ; Decrement pointers
        sub   rsi, 8
        sub   rcx, 1                    ; Decrement count
        jnz   slmx5                     ; Loop for quad count

        mov   rdx, [rsi]                ; Get extra subtrahend quad
        sub   [r15+64], rbx             ; Subtract borrow
        sub   [r15+64], rdx             ; Subtract extra quad
        setc  bl                        ; If borrow results,
        movzx rbx, bl                   ; set rbx

; If borrow generated by subtraction, decrease
; qhat by 1, and add divisor. If result is still negative,
; decrement qhat once more and add divisor again.

        test  rbx, rbx                  ; See if carry generated
        jz    slmx17                    ; Branch if not

slmx7:  mov   rdi, r8                   ; Copy dividend addition point
        mov   rsi, [r15+48]             ; Get divisor ls address
        mov   rcx, [r15+40]             ; Get divisor quad count
        sub   rsi, 8

        xor   rbx, rbx                  ; Zero carry register
slmx9:  mov   rdx, [rsi]                ; Get first/next addend
        add   [rdi], rbx                ; Add carry register
        setc  al                        ; If carry results,
        movzx rax, al                   ; set rax
        add   [rdi], rdx                ; Add to result
        setc  bl                        ; If carry results,
        movzx rbx, bl                   ; set rbx
        or    rbx, rax                  ; Set carry for next quad
        sub   rdi, 8                    ; Decrement pointers
        sub   rsi, 8
        sub   rcx, 1                    ; Decrement counter
        jnz   slmx9                     ; Loop for quad count

        mov   rdx, [rsi]                ; Get extra addend quad
        add   [r15+64], rbx             ; Add carry register
        add   [r15+64], rdx             ; Add to extra quad
        bt    qword[r15+64], 63         ; Test high order bit
        setc  bl
        movzx rbx, bl

        sub   qword[r15+24], 1          ; Decrement qhat
        test  rbx, rbx                  ; See if remainder still negative
        jnz   slmx7                     ; Try again

; Here the quotient quad pointer is advanced, but the quad count
; is left as it is (one less than the actual count at the beginning).

slmx17: mov   rax, [r15+24]             ; Get qhat
        mov   [r11], rax                ; Install digit in quotient
        add   r11, 8                    ; Advance quotient quad pointer
        sub   qword[r15+16], 1          ; Decrement quotient quad count
        add   qword[r15+32], 8          ; Advance dividend subtraction pointer

        jmp   rbp                       ; Return

; Subroutine to subtract the divisor from the high order dividend and
; install 1 as the quotient digit.

sbdv0:  mov   rcx, [r15]                ; Set counter to divisor quad count
        xor   rbx, rbx                  ; Zero borrow register
sbdv1:  mov   r8, [r13+rcx*8-8]         ; Get first/next subtrahend quad
        sub   [r12+rcx*8-8], rbx        ; Subtract borrow
        setc  al                        ; If borrow results,
        movzx rax, al                   ; set register
        sub   [r12+rcx*8-8], r8         ; Subtract from result
        setc  bl                        ; If borrow results,
        movzx rbx, bl                   ; set register
        or    rbx, rax                  ; Set borrow for next quad
        sub   rcx, 1                    ; Decrement count
        jnz   sbdv1                     ; Loop for quad count

        mov   qword[r11], 1             ; Install 1 for quotient digit

        jmp   rbp                       ; Return

; Subroutine to clear space for product, multiply the divisor by the
; estimated quotient digit, and subtract the result from the dividend.
; If the result of the subtaction is negative, the divisor is added to the
; dividend, and the estimated quotient digit is decremented by one.
; If the result is still negative this process is repeated, at which time
; the estimated quotient digit is correct.

muls0:  mov   rdi, [r15+56]             ; Get LS addr of scratch area
        mov   rsi, rdi                  ; Make copy
        mov   rcx, [r15]                ; Get divisor quad count
        mov   rbx, rcx                  ; Save copy
        add   rcx, 1                    ; Clear one more cell
muls1:  sub   rdi, 8                    ; Clear stack space for product
        mov   qword[rdi], 0             ; of divisor and estimated quotient
        sub   rcx, 1                    ; Decrement counter
        jnz   muls1                     ; Loop

        mov   r8,  [r15+24]             ; Get qhat
        mov   rdi, [r15+48]             ; Get divisor ls addr
        mov   rcx, rbx                  ; Copy divisor quad count
        xor   rbx, rbx                  ; Clear register for carry
        sub   rdi, 8                    ; Offset to first quad
        sub   rsi, 8                    ; of divisor and product
muls2:  mov   rax, [rdi]                ; Get first/next divisor quad
        mul   r8                        ; Multiply by qhat
        add   rdx, rbx                  ; Add carry from previous loop
        add   [rsi], rax                ; Add low order to product
        adc   [rsi-8], rdx              ; Add high order with carry to product
        setc  bl                        ; Save state of carry in bl.
        movzx rbx, bl                   ; Zero-extend for adding to next result
        sub   rsi, 8                    ; Decrement pointers
        sub   rdi, 8
        sub   rcx, 1
        jnz   muls2

; If the difference between the dividend subtraction point and the dividend ms
; address is greater than the divisor quad count, add 1 to subtraction quad
; count.

        mov   rcx, [r15]                ; Get divisor quad count
        mov   rdi, [r15+32]             ; Get dividend subtraction point
        mov   rsi, [r15+48]             ; Get dividend ms address
        lea   rsi, [rsi+rcx*8-8]        ; Load offset from ms address
        cmp   rsi, rdi                  ; Compare
        jnc   muls3                     ; If subtraction point not less,
        add   rcx, 1                    ; increment quad count

; Subtract product from dividend.

muls3:  mov   rsi, [r15+56]             ; Get product ls address
        sub   rsi, 8                    ; Offset to low order quad
        mov   r8, rdi                   ; Save subtraction point for addback
        mov   [r15+40], rcx             ; Save quad count for addback
        xor   rbx, rbx                  ; Zero borrow register
muls4:  mov   rdx, [rsi]                ; Get first/next subtrahend quad
        sub   [rdi], rbx                ; Subtract borrow
        setc  al                        ; If borrow results,
        movzx rax, al                   ; set rax
        sub   [rdi], rdx                ; Subtract from result
        setc  bl                        ; If borrow results,
        movzx rbx, bl                   ; set rbx
        or    rbx, rax                  ; Set borrow for next quad
        sub   rdi, 8                    ; Decrement pointers
        sub   rsi, 8
        sub   rcx, 1                    ; Decrement count
        jnz   muls4                     ; Loop for quad count

; If borrow occurs, decrement qhat by 1 and add divisor.

        test  rbx, rbx                  ; See if borrow generated
        jz    muls7                     ; Branch if no borrow occurs

muls5:  sub   qword[r15+24], 1          ; Decrement qhat
        mov   rdi, r8                   ; Copy dividend addition point
        mov   rsi, [r15+48]             ; Get divisor ls address
        mov   rcx, [r15+40]             ; Get product quad count
        sub   rsi, 8                    ; Offset to first quad of divisor

        xor   rbx, rbx                  ; Zero carry register
muls6:  mov   rdx, [rsi]                ; Get first/next addend
        add   [rdi], rbx                ; Add carry register
        setc  al                        ; If carry results,
        movzx rax, al                   ; set register
        add   [rdi], rdx                ; Add to result
        setc  bl                        ; If carry results,
        movzx rbx, bl                   ; set register
        or    rbx, rax                  ; Set carry for next quad
        sub   rdi, 8                    ; Decrement pointers
        sub   rsi, 8
        sub   rcx, 1                    ; Decrement counter
        jnz   muls6                     ; Loop for quad count

        bt    qword[rdi+8], 63          ; Test high order bit
        jnc   muls7                     ; Branch if clear
        jmp   muls5                     ; Else try again

muls7:  jmp   rbp                       ; Return

; Subroutine to install qhat in quotient, advance dividend and quotient
; quad pointers, and decrement dividend and quotient quad counters.

qdig0:   mov   rax, [r15+24]            ; Get qhat
        add   r12, 8                    ; Advance dividend pointer
        sub   qword[r15+8], 1           ; Decrement dividend quad count
        mov   [r11], rax                ; Install digit in quotient
        add   r11, 8                    ; Advance quotient pointer
        add   qword[r15+32], 8          ; Advance dividend subtraction point
        sub   qword[r15+16], 1          ; Decrement quotient quad count

        jmp   rbp                       ; Return

; Zero-divide exception. Restore registers and THROW 15 for zero-divide.

slmi91: mov   r13, [r15+104]            ; Restore registers
        mov   r12, [r15+96]
        add   r15, 112                  ; Pop return stack frame

        throwm 12

slmi92: btr   qword[r15+88], 0          ; Test/clear sign flag
        jnc   slmi99

; If sign flag is set, negate quotient and remainder (symmetric division).

        mov   rcx, r10                  ; Set counter
slmi93: not   qword[r14+rcx*8-8]        ; Negate quotient
        sub   rcx, 1                    ; Decrement counter
        jnz   slmi93
        mov   rcx, r10
slmi94: add   qword[r14+rcx*8-8], 1
        jnc   slmi95
        sub   rcx, 1
        jnz   slmi94

slmi95: lea   rdi, [r14+r10*8]          ; Offset to remainder
        mov   rcx, r10                  ; Set counter
slmi96: not   qword[rdi+rcx*8-8]        ; Negate remainder
        sub   rcx, 1
        jnz   slmi96
        mov   rcx, r10
slmi97: add   qword[rdi+rcx*8-8], 1
        jnc   slmi99
        sub   rcx, 1
        jnz   slmi97

slmi99: mov   r13, [r15+104]            ; Restore registers
        mov   r12, [r15+96]
        add   r15, 112                  ; Pop return stack frame
        nextm
datam

; /in - Multiprecision division

; : /in   /modin nslip ;

head    "/in", hlfo
slshin: dq  docl0
        dq  slmi,nslip,semis

; modin - Multiprecision remainder

; : modin   slmi ndrop ;

head    "modin", hlfo
modin:  dq  docl0
        dq  slmi,ndrop,semis

; */in - Multiprecision */

; : */in   n>a m*in na> in>2in qsz*2 slmi nslip qsz/2 ndrop ;

head    "*/in", hlfo
stslin: dq  docl0
        dq  ntoa,msti,nfrma,inttin,qstt
        dq  slmi,nslip,qsst,ndrop,semis

; */modin - Multiprecision */mod

; : */modin   n>a m*in na> in>2in qsz*2 /modin qsz/2 ndrop nslip ;

head    "*/modin", hlfo
sslmi:  dq  docl0
        dq  ntoa,msti,nfrma,inttin,qstt
        dq  slmi,qsst,ndrop,nslip,semis

; gcdin - Find greatest common divisor of two multi-precision integers.
;
; : gcdin   nover nover <i if nswap then begin nswap nover /modin
;           ndrop ndup 0=i until ndrop ;

head    "gcdin", hlfo
gcdin:  dq  docl0
        dq  nover,nover,inlss,izbrn,gcdin1
        dq  nswap
gcdin1: dq  nswap,nover,slmi,ndrop
        dq  ndup,inzq,uzbrn,gcdin1
        dq  ndrop,semis

head    "bgcdin", ario
bgcdin: dq  bgdi0
textm
bgdi0:  mov   rdi, r14                  ; Copy stack pointer
        xor   rbp, rbp                  ; Zero flag register
        mov   r10, [qdsz0]              ; Get quadsize
        lea   rsi, [rdi+r10*8]          ; Load address of 2nd argument - X
        bt    qword[rdi], 63            ; See if 1st argument is negative
        jnc   bgdi3                     ; Branch if not

; If Y is negative, negate it.

        mov   rcx, r10                  ; Copy qsz
bgdi1:  not   qword[rdi+rcx*8-8]        ; Negate 1st argument
        sub   rcx, 1
        jnz   bgdi1
        mov   rcx, r10
bgdi2:  add   qword[rdi+rcx*8-8], 1
        jnc   bgdi3
        sub   rcx, 1
        jnz   bgdi2

; If X is negative, negate it.

bgdi3:  bt    qword[rsi], 63            ; See if 2nd argument is negative
        jnc   bgdi6                     ; Branch if not

        mov   rcx, r10                  ; Copy qsz
bgdi4:  not   qword[rsi+rcx*8-8]        ; Negate 2nd argument
        sub   rcx, 1
        jnz   bgdi4
        mov   rcx, r10
bgdi5:  add   qword[rsi+rcx*8-8], 1
        jnc   bgdi6
        sub   rcx, 1
        jnz   bgdi5

; See if Y argument is zero or one.

bgdi6:  mov   rcx, r10                  ; Set counter
        xor   rdx, rdx                  ; Zero index register
bgdi7:  cmp   qword[rdi+rdx*8], 0       ; Test first/next quad
        jnz   bgdi8                     ; Leave loop if not zero
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement counter
        jnz   bgdi7                     ; Loop

; If loop falls through, Y is 0

        bts   rbp, 0                    ; Set zero argument flag

        jmp   bgdi9                     ; Go test X

bgdi8:  cmp   rcx, 1                    ; If counter not at last quad,
        jnz   bgdi9                     ; continue
        cmp   qword[rdi+rdx*8], 1       ; If Y is not equal to 1
        jnz   bgdi9                     ; continue

; If Y is equal to one, return Y as GCD

        jmp   bgdi11                    ; Overwrite X with Y

; See if X argument is zero or one.

bgdi9:  mov   rcx, r10                  ; Set counter
        xor   rdx, rdx                  ; Zero index register
bgdi10: cmp   qword[rsi+rdx*8], 0       ; Test first/next quad
        jnz   bgdi13                    ; Leave loop if not zero
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement counter
        jnz   bgdi10                    ; Loop

; If loop falls through, X is 0

        btr   rbp, 0                    ; See if Y is zero
        jc    bgdi44                    ; Throw if both arguments are zero

; If Y is not zero, return Y as GCD

bgdi11: mov   rcx, r10                  ; Copy quad size
        lea   rdi, [r14+r10*8]          ; Load address of X
bgdi12: mov   rax, [r14+rcx*8-8]        ; Overwrite X with Y
        mov   [rdi+rcx*8-8], rax
        sub   rcx, 1
        jnz   bgdi12                    ; Loop for quad size

        lea   r14, [r14+r10*8]          ; Pop Y

        jmp   bgdi45

bgdi13: cmp   rcx, 1                    ; If counter not at last quad,
        jnz   bgdi14                    ; continue
        cmp   qword[rsi+rdx*8], 1       ; If X is one,
        jz    bgdi15                    ; drop Y from stack

bgdi14: btr   rbp, 0                    ; See if Y is zero
        jnc   bgdi16                    ; Branch if not

; Return X as GCD

bgdi15: lea   r14, [r14+r10*8]          ; Drop Y from stack, leaving X

        jmp   bgdi45

bgdi16: xor   rcx, rcx                  ; Initialize counter

; See if Y and X are even

bgdi17: bt    qword[rdi+r10*8-8], 0     ; See if Y is even
        jc    bgdi22                    ; Branch if odd
        bt    qword[rsi+r10*8-8], 0     ; See if X is even
        jc    bgdi25                    ; Branch if odd

; Divide Y by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    bgdi19                    ; Only 1 quad to shift
bgdi18: mov   rax, [rdi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rdi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   bgdi18
bgdi19: shr   qword[rdi+rbx*8], 1       ; Shift single quad

; Divide X by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    bgdi21                    ; Only 1 quad to shift
bgdi20: mov   rax, [rsi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rsi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   bgdi20
bgdi21: shr   qword[rsi+rbx*8], 1       ; Shift single quad

; Decrement counter

        sub   rcx, 1

        jmp   bgdi17                    ; Loop

; See if X is even

bgdi22: bt    qword[rsi+r10*8-8], 0     ; See if X is even
        jc    bgdi28                    ; Branch if odd

; Divide X by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    bgdi24                    ; Only 1 quad to shift
bgdi23: mov   rax, [rsi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rsi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   bgdi23
bgdi24: shr   qword[rsi+rbx*8], 1       ; Shift single quad

        jmp   bgdi22                    ; Loop

; See if Y is even

bgdi25: bt    qword[rdi+r10*8-8], 0     ; See if Y is even
        jc    bgdi28                    ; Branch if odd

; Divide Y by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    bgdi27                    ; Only 1 quad to shift
bgdi26: mov   rax, [rdi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rdi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   bgdi26
bgdi27: shr   qword[rdi+rbx*8], 1       ; Shift single quad

        jmp   bgdi25                    ; Loop

; Compare X and Y

bgdi28: xor   rdx, rdx                  ; Clear index register
        mov   rbx, r10                  ; Copy qsz
bgdi29: mov   rax, [rdi+rdx*8]          ; Get first/next denominator quad
        cmp   rax, [rsi+rdx*8]          ; Compare numerator quad
        jnz   bgdi30                    ; Leave loop if different
        add   rdx, 1                    ; Advance index
        sub   rbx, 1                    ; Decrement counter
        jnz   bgdi29                    ; Loop for qsz
        jmp   bgdi36                    ; Finished if Y = X

bgdi30: jnc   bgdi31                    ; Branch if Y > X

        xchg  rdi, rsi                  ; Else exchange Y and X

; Y = Y - X

bgdi31: mov   r8, r10                   ; Set index/count
        xor   rbx, rbx                  ; Zero borrow register
bgdi32: mov   rax, [rsi+r8*8-8]         ; Get first/next X quad
        sub   [rdi+r8*8-8], rbx         ; Subtract borrow from Y
        setc  dl                        ; If borrow results,
        movzx rdx, dl                   ; set register
        sub   [rdi+r8*8-8], rax         ; Subtract quad from Y
        setc  bl                        ; If borrow results,
        movzx rbx, bl                   ; set register
        or    rbx, rdx                  ; Set borrow for next quad
        sub   r8, 1                     ; Decrement index/count
        jnz   bgdi32                    ; Loop

; See if Y is now even

bgdi33: bt    qword[rdi+r10*8-8], 0     ; See if Y is even
        jc    bgdi28                    ; Branch if odd

; Divide Y by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    bgdi35                    ; Only 1 quad to shift
bgdi34: mov   rax, [rdi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rdi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   bgdi34
bgdi35: shr   qword[rdi+rbx*8], 1       ; Shift single quad

        jmp   bgdi33                    ; Loop

; Shift X left by counter value

bgdi36: neg   rcx                       ; Make shift count positive
        mov   r8, rcx                   ; Copy count
        and   rcx, 63                   ; And with 63 for bits to shift
        shr   r8, 6                     ; Divide by 64 for quads to shift
        jz    bgdi39                    ; Branch if no quads to shift

        mov   r9, r10                   ; Copy qsz
        sub   r9, r8                    ; Subtract shift count from qsz

; Shift quads

        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r9                   ; Initialize counter
        lea   rdi, [rsi+r8*8]           ; Offset to first quad to shift
bgdi37: mov   rax, [rdi+rdx*8]          ; Get first/next quad
        mov   [rsi+rdx*8], rax          ; Shift left
        add   rdx, 1                    ; Advance index
        sub   rbx, 1                    ; Decrement counter
        jnz   bgdi37

; Zero remaining shift count quads

bgdi38: mov   qword[rsi+rdx*8], 0       ; Zero first/next quad
        add   rdx, 1                    ; Advance index
        sub   r8, 1                     ; Decrement count
        jnz   bgdi38                    ; Loop

; See if there are bits to shift

bgdi39: test  rcx, rcx                  ; See if there are bits to shift
        jz    bgdi43                    ; Exit if no bits to shift

; Shift X left by count bits

        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r10                  ; Copy qsz
        sub   rbx, 1                    ; One less for last shift
        jz    bgdi41
bgdi40: mov   rax, [rsi+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [rsi+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   bgdi40
bgdi41: shl   qword[rsi+rdx*8], cl      ; Shift single quad

        cmp   r14, rsi                  ; See if X is top entry
        jnz   bgdi43                    ; Branch if not

; Overwrite Y with X

        mov   rcx, r10                  ; Copy quad size
        lea   rdi, [rsi+r10*8]          ; Load address of X
bgdi42: mov   rax, [rsi+rcx*8-8]        ; Overwrite Y with X
        mov   [rdi+rcx*8-8], rax
        sub   rcx, 1
        jnz   bgdi42                    ; Loop for quad size

bgdi43: lea   r14, [r14+r10*8]          ; Pop Y from stack

        jmp   bgdi45

bgdi44: throwm 29

bgdi45: nextm
datam

; Multi-quad Integer Relational Operators

; 0=in - Push a true flag (-1) if the top multiquad integer stack entry
; is zero, push a false flag (0) if not. The operand is unaffected.

head    "0=in", rlto
inzq:   dq  inzq0
textm
inzq0:  xor   rbx, rbx                  ; Initialize flag register
        mov   rdx, [qdsz0]              ; Get qsz for index/counter
        mov   rcx, rdx                  ; Copy for counter
inzq1:  cmp   qword[r14+rcx*8-8], 0     ; Test for zero
        jnz   inzq2                     ; Leave loop if non-zero

        sub   rcx, 1                    ; Decrement index/counter
        jnz   inzq1                     ; Loop

        mov   rbx, -1                   ; Return true flag if loop falls through

inzq2:  sub   r14, 8                    ; Make room for flag
        mov   [r14], rbx                ; Put flag on stack
        nextm
datam

; =in - Push a true flag (-1) to the stack if the top two multiquad integers
; are equal, push a false flag (0) if not. The operands are unaffected.

head    "=in", rlto
ineq:   dq  ineq0
textm
ineq0:  xor   rbx, rbx                  ; Initialize flag register
        mov   r10, [qdsz0]              ; Get qsz for index/counter
        lea   rdi, [r14+r10*8]          ; Load offset to second entry
        mov   rcx, r10                  ; Get qsz for index/counter
ineq1:  mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        cmp   [rdi+rcx*8-8], rax        ; Compare quads
        jnz   ineq2                     ; Branch if not equal

        sub   rcx, 1                    ; Decrement index/counter
        jnz   ineq1                     ; Loop

        mov   rbx, -1                   ; Return true if loop falls through

ineq2:  sub   r14, 8                    ; Make room for flag
        mov   [r14], rbx                ; Put flag on stack
        nextm
datam

; <in - Push a true flag (-1) if the top multiquad integer is less than
; the second, else push a false flag (0). The operands are unaffected.

head    "<in", rlto
inlss:  dq  ilss0
textm
ilss0:  xor   rbp, rbp                  ; Clear flag register
        mov   r10, [qdsz0]              ; Get qsz for index/counter
        lea   rdi, [r14+r10*8]          ; Offset to 2nd entry
        bt    qword[r14], 63            ; Test sign of 1st entry
        jnc   ilss1                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag

ilss1:  bt    qword[rdi], 63            ; Test sign of 2nd entry
        jnc   ilss2                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag

ilss2:  btr   rbp, 0                    ; Test/clear sign flag
        jnc   ilss3                     ; If flag was clear, signs are the same

        mov   rbx, -1                   ; Set flag to true
        bt    qword[r14], 63            ; Test sign of 1st entry
        jnc   ilss7                     ; Return true flag if positive

        mov   rbx, 0                    ; Else return false flag
        jmp   ilss7

ilss3:  xor   rdx, rdx                  ; Clear index register
        mov   rcx, r10                  ; Set counter
ilss4:  mov   rax, [r14+rdx*8]          ; Get first/next quad
        cmp   [rdi+rdx*8], rax          ; Compare quads
        jnz   ilss5                     ; Branch if not equal

        add   rdx, 1                    ; Advance index
        sub   rcx, 1                    ; Decrement counter
        jnz   ilss4                     ; Loop

ilss5:  setl  bl                        ; Set flag for signed less than
        neg   bl
        movsx rbx, bl

ilss7:  sub   r14, 8                    ; Push flag to stack
        mov   [r14], rbx
        nextm
datam

; uq>in - Extend unsigned 64-bit stack entry to integer in the current
; quadsize.

head    "uq>in", nbco
uqtin:  dq  uqin0
textm
uqin0:  mov   rdx, [qdsz0]              ; Get quadsize
        sub   rdx, 1                    ; Subtract one
        jz    uqin2                     ; Nothing to do if qsz is one

uqin1:  sub   r14, 8                    ; Fill upper quads with zero
        mov   qword[r14], 0
        sub   rdx, 1
        jnz   uqin1
uqin2:  nextm
datam

; sq>in - Sign-extend a 64-bit value to integer in the current quad size.

head    "sq>in", nbco
sqtin:  dq  sqin0
textm
sqin0:  mov   rdx, [qdsz0]              ; Get quad size
        sub   rdx, 1                    ; Subtract one
        jz    sqin2                     ; Nothing to do if qsz is one
        bt    qword[r14], 63            ; Test sign of entry
        setc  bl                        ; Set to 0 if no carry, 1 if carry
        neg   bl                        ; Negate result
        movsx rbx, bl                   ; Sign-extend result
sqin1:  sub   r14, 8                    ; Fill quads with result
        mov   [r14], rbx
        sub   rdx, 1
        jnz   sqin1
sqin2:  nextm
datam

; in>sq - Convert a multi-quad integer to single precision, if possible.
; Throw error if number can't be represented.

head    "in>sq", nbco
intsq:  dq  insq0
textm
insq0:  mov   r10, [qdsz0]              ; Get quadsize

; If the sign of number is not the same as the sign of the low order quad,
; the number is not representable in 64 bits. Throw error.

        bt    qword[r14], 63            ; Test sign bit
        setc  dl
        bt    qword[r14+r10*8-8], 63    ; Test sign of low order quad
        setc  bl
        xor   bl, dl
        jnz   insq3

        neg   dl
        movsx rdx, dl

; Locate significant lead quad.

        mov   rcx, r10                  ; Copy qsz
        mov   rdi, r14                  ; Copy stack pointer
insq1:  cmp   [rdi], rdx
        jnz   insq2
        add   rdi, 8
        sub   rcx, 1
        jnz   insq1

; If loop falls through, integer is either 0 or -1 and result is already
; in rdx.

        jmp   insq5

; If count is not 1, number is not representable in 64 bits. Throw error.

insq2:  cmp   rcx, 1
        jz    insq4

insq3:  throwm 41

insq4:  mov   rdx, [r14+r10*8-8]        ; Get low order integer quad
insq5:  lea   r14, [r14+r10*8-8]        ; Pop all but 1 quad
        mov   [r14], rdx                ; Install 64-bit integer
        nextm
datam

; uin>2in - Double the quad size of the multiprecision integer on top of the
; stack without sign extension.

head    "uin>2in", nbco
uitti:  dq  uiti0
textm
uiti0:  mov  rdx, [qdsz0]               ; Get qsz
uiti1:  sub  r14, 8                     ; Fill upper multiprecision cell with zero
        mov  qword[r14], 0
        sub  rdx, 1
        jnz  uiti1
        nextm
datam

; in>2in - Double the quad size of the multiprecision integer on top
; of the stack with sign extension.

head    "in>2in", nbco
inttin: dq  itti0
textm
itti0:  bt    qword[r14], 63            ; Test sign of entry
        setc  bl                        ; Set to 0 if no carry, 1 if carry
        neg   bl                        ; Negate result
        movsx rbx, bl                   ; Sign-extend result
        mov   rdx, [qdsz0]              ; Get quadsize
itti1:  sub   r14, 8                    ; Fill quads with result
        mov   [r14], rbx
        sub   rdx, 1
        jnz   itti1
        nextm
datam

; .in - Output the multi-quad integer on the top of the stack according
;      to the current quadsize.

; : .in  qsz@ ckstk nob0 base @ mpi>bsn bsn>ascii count strout space ;

head    ".in", hlfo
dotin:  dq  docl0
        dq  qszat,ckstk
        dq  nobn,base,qat,mpbsn
        dq  bsasc,count,strout,space,semis

; u.in - Output the multi-quad integer on the top of the stack as an unsigned
;       integer according to the current quadsize.

; : u.in  qsz@ ckstk nob0 base @ umpi>bsn bsn>ascii count strout space ;

head    "u.in", hlfo
udotin: dq  docl0
        dq  qszat,ckstk
        dq  nobn,base,qat,umbsn
        dq  bsasc,count,strout,space,semis

; Real Number Operators

; reliteral

head    "reliteral", -hlfo
relite: dq  docl0
        dq  pcomp,relit,dncom,semis
relit:  dq  relt0
textm
relt0:  lea   rsi, [r12+8]              ; Get address of literal
        mov   rdx, [rsi-8]              ; Get quad size of literal
        lea   r12, [r12+rdx*8+8]        ; Offset IP past literal

; Create room on stack and set new stack address.

        mov   r10, [qdsz0]              ; Get system quadsize
        mov   rcx, r10                  ; Copy qsz
        shl   rcx, 1                    ; Double it
        neg   rcx                       ; Negate
        lea   r14, [r14+rcx*8]          ; Load new stack address
        neg   rcx                       ; Restore qsz*2
        mov   rdi, r14                  ; Set temporary stack pointer
        mov   r9, r10                   ; Copy system qsz for shift count
        mov   r8, rdx                   ; Copy literal quadsize
        shr   r8, 1                     ; Halve it
        cmp   r8, r10                   ; Compare quadsizes
        jz    relt14                    ; Branch if equal

; Literal is either smaller or larger than the system quadsize, prepare
; a register for comparing or sign-extension.

        xor   rbx, rbx                  ; Clear for comparing/sign extension
        bt    qword[rsi], 63            ; Test sign of literal
        jnc   relt2                     ; Branch if positive

        mov   rbx, -1                   ; Set register if negative

relt2:  sub   r8, r10                   ; Subtract system qsz
        jna   relt9                     ; Branch if literal qsz/2 not greater

; Literal qsz/2 is greater than system qsz. See if the literal can be
; represented in the smaller qsz. There are three parts to this test.
; First see if there are significant lead quads within the quadsize
; difference, and throw if so. Next, see if there are significant quads
; within the new quadsize, and throw if not. Finally, test if the high
; order bit in the new quadsize is the same as that of the literal,
; and throw if not.

        xor   rax, rax                  ; Zero index
        mov   r9, r8                    ; Copy qsz difference
relt3:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   relt8                     ; Error if not equal
        add   rax, 1                    ; Increment index
        sub   r9, 1                     ; Decrement qsz difference
        jnz   relt3

        lea   rsi, [rsi+r8*8]           ; Load new literal address
        xor   rax, rax                  ; Zero index
        mov   r9, rcx                   ; Copy system qsz*2
relt4:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   relt5                     ; Exit if not equal
        add   rax, 1                    ; Increment index
        sub   r9, 1                     ; Decrement qsz difference
        jnz   relt4                     ; Loop for quad count
        jmp   relt8                     ; Fall-through means error

; After successfully testing lead quads, test the high order bit
; of the literal in the smaller quadsize. If it is set while the
; literal is positive, or clear while the literal is negative,
; throw error.

relt5:  bt    rbx, 63                   ; Test sign
        jnc   relt6                     ; Branch if positive

        bt    qword[rsi], 63            ; Test high order bit of result
        jnc   relt8                     ; Error if clear
        jmp   relt7                     ; Else continue

relt6:  bt    qword[rsi], 63            ; Test high order bit of result
        jc    relt8                     ; Error if set

; If literal can be represented, move twice the system qsz of quads
; to the stack, starting with the quad at an offset from the beginning
; of the literal equal to the qsz difference. Use twice the system qsz
; for index and count. The system qsz*2 is already in rcx.

relt7:  mov   r9, r10                   ; Copy system qsz for shift count
        jmp   relt14                    ; Branch to move literal to stack

; Throw "number cannot be represented in current quadsize".

relt8:  throwm 54

; System quadsize greater than literal quadsize.

relt9:  neg   r8                        ; Make qsz difference positive
        lea   rbp, [rdi+r8*8]           ; Adjust/save temporary stack pointer

; Pre-sign-extend literal.

        mov   rcx, r8                   ; Copy qsz difference
        mov   r9, r8                    ; Copy difference for shift count
        shr   r9, 1                     ; Shift count right
        jnc   relt10                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   relt10
        jmp   relt11

relt10: ssopm 2, shcnt, dfilm

; Pad low order literal with zeroes.

relt11: lea   rdi, [rbp+rdx*8]          ; Offset to low order
        mov   rcx, r8                   ; Copy qsz difference
        mov   r9, r8                    ; Copy difference for shift count
        xor   rbx, rbx                  ; Clear fill register
        shr   r9, 1                     ; Shift count right
        jnc   relt12                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Clear 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   relt12
        jmp   relt13

relt12: ssopm 2, shcnt, dfilm

relt13: mov   rdi, rbp                  ; Restore saved stack pointer
        mov   rcx, rdx                  ; Set counter to literal qsz
        mov   r9, rdx                   ; Halve for shift count
        shr   r9, 1

relt14: ssopm 2, shcnt, dmovm

        nextm
datam

; reconstant - Create a multi-quad real constant.

head    "reconstant", hlfo
recon:  dq  docl0
        dq  qszat,tstar,ckstk
        dq  dfine,lit,reco,objcom,pcomm,recn0
        dq  dncom,oszcom,semis
textm
recn0:  lea   rsi, [r11+16]             ; Get address of constant
        mov   rdx, [rsi-8]              ; Get quad size of constant

; Create room on stack and set new stack address.

        mov   r10, [qdsz0]              ; Get system quadsize
        mov   rcx, r10                  ; Copy qsz
        shl   rcx, 1                    ; Double it
        neg   rcx                       ; Negate
        lea   r14, [r14+rcx*8]          ; Load new stack address
        neg   rcx                       ; Restore qsz*2
        mov   rdi, r14                  ; Set temporary stack pointer
        mov   r9, r10                   ; Copy system qsz for shift count
        mov   r8, rdx                   ; Copy constant quadsize
        shr   r8, 1                     ; Halve it
        cmp   r8, r10                   ; Compare quadsizes
        jz    recn13                    ; Branch if equal

; Constant is either smaller or larger than the system quadsize, prepare
; a register for comparing or sign-extension.

        xor   rbx, rbx                  ; Clear for comparing/sign extension
        bt    qword[rsi], 63            ; Test sign of constant
        jnc   recn1                     ; Branch if positive

        mov   rbx, -1                   ; Set register if negative

recn1:  sub   r8, r10                   ; Subtract system qsz
        jna   recn8                     ; Branch if constant qsz/2 not greater

; Constant qsz/2 is greater than system qsz. See if the constant can be
; represented in the smaller qsz. There are three parts to this test.
; First see if there are significant lead quads within the quadsize
; difference, and throw if so. Next, see if there are significant quads
; within the new quadsize, and throw if not. Finally, test if the high
; order bit in the new quadsize is the same as that of the constant,
; and throw if not.

        xor   rax, rax                  ; Zero index
        mov   r9, r8                    ; Copy qsz difference
recn2:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   recn7                     ; Error if not equal
        add   rax, 1                    ; Increment index
        sub   r9, 1                     ; Decrement qsz difference
        jnz   recn2

        lea   rsi, [rsi+r8*8]           ; Load new constant address
        xor   rax, rax                  ; Zero index
        mov   r9, rcx                   ; Copy system qsz*2
recn3:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   recn4                     ; Exit if not equal
        add   rax, 1                    ; Increment index
        sub   r9, 1                     ; Decrement qsz difference
        jnz   recn3                     ; Loop for quad count
        jmp   recn7                     ; Fall-through means error

; After successfully testing lead quads, test the high order bit
; of the constant in the smaller quadsize. If it is set while the
; constant is positive, or clear while the constant is negative,
; throw error.

recn4:  bt    rbx, 63                   ; Test sign
        jnc   recn5                     ; Branch if positive

        bt    qword[rsi], 63            ; Test high order bit of result
        jnc   recn7                     ; Error if clear
        jmp   recn6                     ; Else continue

recn5:  bt    qword[rsi], 63            ; Test high order bit of result
        jc    recn7                     ; Error if set

; If constant can be represented, move twice the system qsz of quads
; to the stack, starting with the quad at an offset from the beginning
; of the constant equal to the qsz difference. Use twice the system qsz
; for index and count. The system qsz*2 is already in rcx.

recn6:  mov   r9, r10                   ; Copy system qsz for shift count
        jmp   recn13                    ; Branch to move constant to stack

; Throw "number cannot be represented in current quadsize".

recn7: throwm 54

; System quadsize greater than constant quadsize.

recn8:  neg   r8                        ; Make qsz difference positive
        lea   rbp, [rdi+r8*8]           ; Adjust/save temporary stack pointer

; Pre-sign-extend constant.

        mov   rcx, r8                   ; Copy qsz difference
        mov   r9, r8                    ; Copy difference for shift count
        shr   r9, 1                     ; Shift count right
        jnc   recn9                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   recn9
        jmp   recn10

recn9:  ssopm 2, shcnt, dfilm

; Pad low order constant with zeroes.

recn10: lea   rdi, [rbp+rdx*8]          ; Offset to low order
        mov   rcx, r8                   ; Copy qsz difference
        mov   r9, r8                    ; Copy difference for shift count
        xor   rbx, rbx                  ; Clear fill register
        shr   r9, 1                     ; Shift count right
        jnc   recn11                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Clear 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   recn11
        jmp   recn12

recn11: ssopm 2, shcnt, dfilm

recn12: mov   rdi, rbp                  ; Restore saved stack pointer
        mov   rcx, rdx                  ; Set counter to constant qsz
        mov   r9, rdx                   ; Halve for shift count
        shr   r9, 1

recn13: ssopm 2, shcnt, dmovm

        nextm
datam

; revariable - Create a real number variable.

head    "revariable", hlfo
revar:  dq  docl0
        dq  dfine,lit,revo,objcom,pcomm,nvar0
        dq  zero,uqre,dncom,oszcom,semis

; rearray - Create an array of real numbers in double the current qsz.
; ( n --- ). Arrays are 1-based.
; Array structure (header not shown):

; | code field | number of elements | element size | elements ... |

head    "rearray", hlfo
rear:   dq  docl0
        dq  one,ckstk
        dq  dfine,lit,reao,objcom,pcomm,narr0
        dq  dupl,comma,qszat,tstar,dupl,comma,star,here
        dq  over,estar,allot,swp,zero,qfill,oszcom,semis

; re@ - Fetch real number to stack.

head    "re@", mqmo
reat:   dq  reat0
textm
reat0:  mov   rsi, [r14+8]              ; Get address of variable
        mov   rdx, [r14]                ; Get quad size of variable
        mov   r10, [qdsz0]              ; Get system quadsize

; Create room on stack and set new stack address.

        mov   rcx, r10                  ; Copy system quad size
        shl   rcx, 1                    ; Double it
        neg   rcx                       ; Negate
        lea   r14, [r14+rcx*8+16]       ; Load new stack address
        neg   rcx                       ; Restore qsz*2
        mov   rdi, r14                  ; Set temporary stack pointer
        mov   r9, r10                   ; Copy system qsz for shift count
        cmp   rcx, rdx                  ; Compare quadsizes
        jz    reat14                    ; Branch if equal

; Variable is either smaller or larger than the system quadsize, prepare
; a register for comparing or sign-extension.

        xor   rbx, rbx                  ; Clear for comparing/sign extension
        bt    qword[rsi], 63            ; Test sign of variable
        jnc   reat2                     ; Branch if positive

        mov   rbx, -1                   ; Set register if negative

reat2:  mov   r8, rdx                   ; Copy variable qsz*2
        shr   r8, 1                     ; Halve it
        sub   r8, r10                   ; Subtract system qsz
        jna   reat9                     ; Branch if variable qsz/2 not greater

; Variable qsz/2 is greater than system qsz. See if the variable can be
; represented in the smaller qsz. There are three parts to this test.
; First see if there are significant lead quads within the quadsize
; difference, and throw if so. Next, see if there are significant quads
; within the new quadsize, and throw if not. Finally, test if the high
; order bit in the new quadsize is the same as that of the variable,
; and throw if not.

        xor   rax, rax                  ; Zero index
        mov   r9, r8                    ; Copy qsz difference
reat3:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   reat8                     ; Error if not equal
        add   rax, 1                    ; Increment index
        sub   r9, 1                     ; Decrement qsz difference
        jnz   reat3

        lea   rsi, [rsi+r8*8]           ; Load new variable address
        xor   rax, rax                  ; Zero index
        mov   r9, rcx                   ; Copy system qsz*2
reat4:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   reat5                     ; Exit if not equal
        add   rax, 1                    ; Increment index
        sub   r9, 1                     ; Decrement qsz difference
        jnz   reat4                     ; Loop for quad count
        jmp   reat8                     ; Fall-through means error

; After successfully testing lead quads, test the high order bit
; of the variable in the smaller quadsize. If it is set while the
; variable is positive, or clear while the variable is negative,
; throw error.

reat5:  bt    rbx, 63                   ; Test sign
        jnc   reat6                     ; Branch if positive

        bt    qword[rsi], 63            ; Test high order bit of result
        jnc   reat8                     ; Error if clear
        jmp   reat7                     ; Else continue

reat6:  bt    qword[rsi], 63            ; Test high order bit of result
        jc    reat8                     ; Error if set

; If variable can be represented, move twice the system qsz of quads
; to the stack, starting with the quad at an offset from the beginning
; of the variable equal to the qsz difference. Use twice the system qsz
; for index and count. The system qsz*2 is already in rcx.

reat7:  mov   r9, r10                   ; Copy system qsz for shift count
        jmp   reat14                    ; Branch to move variable to stack

; Throw "number cannot be represented in current quadsize".

reat8:  throwm 54

; System quadsize greater than variable quadsize.

reat9:  neg   r8                        ; Make qsz difference positive
        lea   rbp, [rdi+r8*8]           ; Adjust/save temporary stack pointer

; Pre-sign-extend variable.

        mov   rcx, r8                   ; Copy qsz difference
        mov   r9, r8                    ; Copy difference for shift count
        shr   r9, 1                     ; Shift count right
        jnc   reat10                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   reat10
        jmp   reat11

reat10: ssopm 2, shcnt, dfilm

; Pad low order variable with zeroes.

reat11: lea   rdi, [rbp+rdx*8]          ; Offset to low order
        mov   rcx, r8                   ; Copy qsz difference
        mov   r9, r8                    ; Copy difference for shift count
        xor   rbx, rbx                  ; Clear fill register
        shr   r9, 1                     ; Shift count right
        jnc   reat12                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Clear 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   reat12
        jmp   reat13

reat12: ssopm 2, shcnt, dfilm

reat13: mov   rdi, rbp                  ; Restore saved stack pointer
        mov   rcx, rdx                  ; Set counter to variable qsz
        mov   r9, rdx                   ; Halve for shift count
        shr   r9, 1

reat14: ssopm 2, shcnt, dmovm

        nextm
datam

; re! - Store real number on stack.

head    "re!", mqmo
restr:  dq  rest0
textm
rest0:  mov   rdi, [r14+8]              ; Get address of variable
        mov   rdx, [r14]                ; Get quad size of variable
        mov   r10, [qdsz0]              ; Get system quadsize
        lea   rsi, [r14+16]             ; Load address of stack entry
        mov   rcx, r10                  ; Copy system quad size
        shl   rcx, 1                    ; Double it
        lea   r14, [r14+rcx*8+16]       ; Pop the stack
        mov   r9, rdx                   ; Copy variable qsz
        shr   r9, 1                     ; Halve it
        cmp   r9, r10                   ; See if quadsizes are the same
        jz    rest14                    ; Branch if so

; Variable is either smaller or larger than the system quadsize, prepare
; a register for comparing or sign-extension.

        xor   rbx, rbx                  ; Clear for comparing/sign extension
        bt    qword[rsi], 63            ; Test sign of stack entry
        jnc   rest2                     ; Branch if positive

        mov   rbx, -1                   ; Set register if negative

rest2:  mov   r8, r10                   ; Copy system qsz
        sub   r8, r9                    ; Subtract variable qsz/2
        jna   rest9                     ; Branch variable qsz greater

; System qsz is greater than variable qsz/2. See if stack entry can be
; represented in the smaller qsz. There are three parts to this test.
; First see if there are significant lead quads between the beginning
; of the stack entry and the beginning of the variable and throw if so.
; Next see if there are significant quads within the range of the variable
; and throw if not. Finally, test if the high order bit in the new quadsize
; is the same as that of the stack entry, and throw if not.

        xor   rax, rax                  ; Zero index
        mov   r9, r8                    ; Copy qsz difference
rest3:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   rest8                     ; Error if not equal
        add   rax, 1                    ; Increment index
        sub   r9, 1                     ; Decrement qsz difference
        jnz   rest3                     ; Loop for difference

        lea   rsi, [rsi+r8*8]           ; Load new stack address
        xor   rax, rax                  ; Zero index
        mov   r9, rdx                   ; Copy variable qsz*2
rest4:  cmp   [rsi+rax*8], rbx          ; Compare 1st/next quad
        jnz   rest5                     ; Exit if not equal
        add   rax, 1                    ; Increment index
        sub   r9, 1                     ; Decrement qsz difference
        jnz   rest4                     ; Loop for quad count
        jmp   rest8                     ; Fall-through means error

; After successfully testing lead quads, test the high order bit
; of the variable in the smaller quadsize. If it is set while the
; variable is positive, or clear while the variable is negative,
; throw error.

rest5:  bt    rbx, 63                   ; Test sign
        jnc   rest6                     ; Branch if positive

        bt    qword[rsi], 63            ; Test high order bit of result
        jnc   rest8                     ; Error if clear
        jmp   rest7                     ; Else continue

rest6:  bt    qword[rsi], 63            ; Test high order bit of result
        jc    rest8                     ; Error if set

; If stack entry can be represented, move twice the variable qsz of quads
; to the variable, starting with the quad at an offset from the top of
; the stack equal to the qsz difference. Use twice the variable qsz
; for index and count.

rest7:  mov   r9, rdx                   ; Copy variable qsz*2
        shr   r9, 1                     ; Halve it for shift count
        mov   rcx, rdx                  ; Copy for quad count/index
        jmp   rest14                    ; Branch to move variable to stack

; Throw "container is too small for stack entry".

rest8:  throwm 22

; Variable quadsize greater than system quadsize.

rest9:  neg   r8                        ; Make qsz difference positive
        lea   rbp, [rdi+r8*8]           ; Adjust/save variable address

; Pre-sign-extend variable.

        mov   rcx, r8                   ; Copy qsz difference
        mov   r9, r8                    ; Copy difference for shift count
        shr   r9, 1                     ; Shift count right
        jnc   rest10                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   rest10
        jmp   rest11

rest10: ssopm 2, shcnt, dfilm

; Pad low order variable with zeroes.

rest11: lea   rdi, [rbp+rdx*8]          ; Offset to low order
        mov   rcx, r8                   ; Copy qsz difference
        mov   r9, r8                    ; Copy difference for shift count
        xor   rbx, rbx                  ; Clear fill register
        shr   r9, 1                     ; Shift count right
        jnc   rest12                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Clear 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   rest12
        jmp   rest13

rest12: ssopm 2, shcnt, dfilm

; Move stack entry to variable.

rest13: mov   rdi, rbp                  ; Restore saved stack pointer
        mov   rcx, rdx                  ; Set counter to variable qsz
        mov   r9, rdx                   ; Halve for shift count
        shr   r9, 1

rest14: ssopm 2, shcnt, dmovm

        nextm
datam

; re*2 - Double real number

head    "re*2", ario
restt:  dq  rstt0
textm
rstt0:  xor   rdx, rdx                  ; Clear index register
        mov   rbx, [qdsz0]              ; Get qsz
        shl   rbx, 1                    ; Double for real number
        sub   rbx, 1                    ; One less for last shift

        mov   rax, [r14+rdx*8+8]        ; Shift first quad
        shld  [r14+rdx*8], rax, 1
        jno   rstt1                     ; Test for overflow

        throwm 27                       ; Throw multiplication overflow

rstt1:  add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jz    rstt3

rstt2:  mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, 1
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   rstt2

rstt3:  shl   qword[r14+rdx*8], 1       ; Shift low order quad

        nextm
datam

; re/2 - Halve real number

head    "re/2", ario
reslt:  dq  resl0
textm
resl0:  mov   rbx, [qdsz0]              ; Get quadsize
        shl   rbx, 1                    ; Double count
        sub   rbx, 1                    ; Count is one less than qsz*2
resl1:  mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   resl1
        sar   qword[r14+rbx*8], 1       ; Shift low order quad
        nextm
datam

; re+sq - Add a single signed quad to a real number.

head    "re+sq", ario
repsq:  dq  rpsq0
textm
rpsq0:  mov   rdx, [r14]                ; Pop addend
        add   r14, 8
        mov   rcx, [qdsz0]              ; Get quad counter
        sub   rcx, 1                    ; Decrement for 1st quad
        xor   rbx, rbx                  ; Zero carry/borrow register
        bt    rdx, 63                   ; Test sign bit
        jc    rpsq2                     ; Branch if operand is negative
        add   [r14+rcx*8], rdx          ; Add addend
        jnc   rpsq4                     ; Exit if no carry
rpsq1:  add   qword[r14+rcx*8-8], 1     ; Add carry to next quad
        jnc   rpsq4                     ; Exit if no carry results
        sub   rcx, 1                    ; Decrement index/counter
        jnz   rpsq1                     ; Loop for quad count
        jmp   rpsq4                     ; Branch to exit

rpsq2:  neg   rdx                       ; Negate operand
        sub   [r14+rcx*8], rdx          ; Subtract
        jnc   rpsq4                     ; Exit if no borrow
rpsq3:  sub   qword[r14+rcx*8-8], 1     ; Subtract borrow from next quad
        jnc   rpsq4                     ; Exit if no borrow results
        sub   rcx, 1                    ; Decrement index/counter
        jnz   rpsq3                     ; Loop for quad count
rpsq4:  nextm
datam

; re*sq - Multiply a real number by a single quad. Check for a single quad
; argument of 1 or -1 and simplify accordingly.

head    "re*sq"
rstsq:  dq   rstq0
textm
rstq0:  mov   r8, [r14]                 ; Pop multiplier quad
        add   r14, 8
        mov   r10, [qdsz0]              ; Get quadsize
        xor   rbp, rbp                  ; Zero flags register
        bt    r8, 63                    ; Test sign of multiplier
        jnc   rstq1                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag if negative
        neg   r8                        ; Negate

; If multiplier is 1, use special processing.

rstq1:  cmp   r8, 1
        jnz   rstq2

        btr   rbp, 0                    ; Test/clear sign flag
        jnc   rstq16                    ; Exit if flag was clear

        mov   r9, r10                   ; Copy qsz
        shl   r9, 1                     ; Double for real data
        jmp   rstq13                    ; Branch to negate real number

rstq2:  mov   r9, r10                   ; Copy qsz
        shl   r9, 1                     ; Double for real data

        bt    qword[r14], 63            ; Test sign of real entry
        jnc   rstq5                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag if negative

; Negate if negative.

        mov   rcx, r9                   ; Set counter
rstq3:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   rstq3
        mov   rcx, r9                   ; Reset counter
rstq4:  add   qword[r14+rcx*8-8], 1
        jnc   rstq5
        sub   rcx, 1
        jnz   rstq4

; Find leading non-zero quad.

rstq5:  mov   rcx, r9                   ; Set loop counter
        xor   rdx, rdx                  ; Zero index
rstq6:  cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   rstq7                     ; Exit loop if not
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   rstq6

; If loop falls through number is zero. Exit.

        jmp   rstq16

rstq7:  cmp   rdx, 0                    ; See if there were lead quads
        jnz   rstq8                     ; Branch if so

        bts   rbp, 1                    ; Set flag for possible overflow

rstq8:  lea   rdi, [r14+rdx*8]          ; Load addr of high order quad
        xor   rbx, rbx                  ; Clear for high order result
        mov   rcx, r9                   ; Get qsz
        sub   rcx, rdx                  ; Subtract number of leading zero quads
rstq9:  mov   rax, [rdi+rcx*8-8]        ; Get first/next multiplicand quad
        mul   r8                        ; Multiply by multiplier quad
        add   rax, rbx                  ; Add high order from previous loop
        jnc   rstq10                    ; Brach if no carry
        add   rdx, 1                    ; Else add carry to high order
rstq10: mov   [rdi+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order
        sub   rcx, 1                    ; Decrement count
        jnz   rstq9                     ; Loop for non-zero quad count

        cmp   rdx, 0                    ; Test high order result
        jz    rstq12                    ; Done if zero

        btr   rbp, 1                    ; Test/clear overflow flag
        jnc   rstq11                    ; Branch if flag was clear

        throwm 27                       ; Throw multiplication overflow

rstq11: mov   [rdi-8], rdx              ; Install high order product on stack

rstq12: btr   rbp, 0                    ; Test/clear sign flag
        jnc   rstq16                    ; Branch if flag was clear

rstq13: mov   rcx, r9                   ; Set counter
rstq14: not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   rstq14
rstq15: add   qword[r14+r9*8-8], 1
        jnc   rstq16
        sub   r9, 1
        jnz   rstq15

rstq16: nextm
datam

; re/sq - Divide a real number by a single quad. Check for a single quad argument
; of 1 or -1 and simplify accordingly.
; 5/3/15 - This new version ignores division underflow so that algorithms such as
; e^1 won't bomb out before the stopping criterion is met.

head    "re/sq"
redsq:  dq   redq0
textm
redq0:  mov   r8, [r14]                 ; Pop divisor quad
        add   r14, 8
        mov   r10, [qdsz0]              ; Get quadsize

        xor   rbp, rbp                  ; Clear flags register
        bt    r8, 63                    ; Test sign of dividend
        jnc   redq1                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag if negative
        neg   r8                        ; Negate

; If divisor is 1, use special processing.

redq1:  cmp   r8, 1
        jnz   redq2

        btr   rbp, 0                    ; Test/clear sign flag
        jnc   redq13                    ; Exit if flag was clear

        mov   r9, r10                   ; Copy qsz
        shl   r9, 1                     ; Double for real data
        jmp   redq10                    ; Branch to negate real number

redq2:  mov   r9, r10                   ; Copy qsz
        shl   r9, 1                     ; Double for real data

        bt    qword[r14], 63            ; Test sign of real entry
        jnc   redq5                     ; Branch if positive

; Negate if negative

        btc   rbp, 0                    ; Complement sign flag if negative
        mov   rcx, r9                   ; Set counter
redq3:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   redq3
        mov   rcx, r9                   ; Reset counter
redq4:  add   qword[r14+rcx*8-8], 1
        jnc   redq5
        sub   rcx, 1
        jnz   redq4

; Find leading non-zero quad.

redq5:  mov   rcx, r9                   ; Set loop counter
        xor   rdx, rdx                  ; Zero index register
redq6:  cmp   qword[r14+rdx*8], 0       ; See if quad is zero
        jnz   redq7                     ; Exit loop if not
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   redq6

; If loop falls through dividend is zero. Exit.

        jmp   redq13

; Divide by single divisor quad

redq7:  lea   rdi, [r14+rdx*8]          ; Offset to dividend MS quad
        xor   rbx, rbx                  ; Clear index register
        mov   rcx, r9                   ; Get 2*qsz
        sub   rcx, rdx                  ; Subtract number of leading zero quads
        xor   rdx, rdx                  ; Clear remainder register
        cmp   rcx, 1                    ; See if dividend is a single quad
        jnz   redq8                     ; Branch if not

        mov   rax, [rdi+rbx*8]          ; Get single dividend quad
        div   r8                        ; Divide by single divisor quad

        mov   [rdi+rbx*8], rax          ; Install single quotient quad
        jmp   redq9                     ; Branch to finish

redq8:  mov   rax, [rdi+rbx*8]          ; Get first/next dividend quad
        div   r8                        ; Divide by single divisor quad
        mov   [rdi+rbx*8], rax          ; Install quotient quad
        add   rbx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   redq8

redq9:  btr   rbp, 0                    ; Test/clear sign flag
        jnc   redq13                    ; Branch if flag was clear

redq10: mov   rcx, r9                   ; Set counter
redq11: not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   redq11
redq12: add   qword[r14+r9*8-8], 1
        jnc   redq13
        sub   r9, 1
        jnz   redq12
redq13: nextm
datam

; 2**sqre - ( sq --- re ) Calculate 2**sq as a real number given a signed 64-bit integer
; argument. Throws error if result cannot be represented in current quadsize.

head    "2**sqre"
ttsqr:  dq  ttsq0
textm
ttsq0:  xor   rbp, rbp                  ; Zero flags register
        mov   rax, [r14]                ; Get exponent
        add   r14, 8                    ; Pop the stack
        mov   r10, [qdsz0]              ; Get quadsize
        bt    rax, 63                   ; See if exponent is negative
        jnc   ttsq1                     ; Branch if not
        neg   rax                       ; Else negate and
        bts   rbp, 0                    ; set sign flag

ttsq1:  mov   rbx, r10                  ; Copy qsz
        shl   rbx, 6                    ; Find bits in qsz
        sub   rbx, 1                    ; Subtract 1 for sign bit
        cmp   rax, rbx                  ; See if exponent is in range
        jc    ttsq2                     ; Continue if so

        throwm 54                       ; Throw error

ttsq2:  mov   rdx, r10                  ; Get qsz for new stack location
        shl   rdx, 1                    ; Double qsz for offset
        mov   rcx, rdx                  ; Copy for stack index
        neg   rdx                       ; Make it negative
        lea   r14, [r14+rdx*8]          ; Set stack pointer
        mov   rdi, r14                  ; Copy stack pointer
        mov   r9, r10                   ; Get qsz for shifting
        xor   rbx, rbx                  ; Set fill value to 0

; Put real zero on stack.

        ssopm 2, shcnt, dfilm

; Find bit number /mod 64.

        shrd  rbx, rax, 6               ; Shift low order bits out
        sar   rax, 6                    ; Divide by 64
        xor   rcx, rcx                  ; Zero register for bits shifted out
        shld  rcx, rbx, 6               ; Shift low order bits back in.
        mov   rdx, r10                  ; Get qsz
        btr   rbp, 0                    ; Test/clear sign flag
        jc    ttsq3                     ; Branch if flag was set

        sub   rdx, rax                  ; Subtract number of quads in exponent
        bts   [r14+rdx*8-8], rcx        ; Set bit
        jmp   ttsq4                     ; Branch to exit

ttsq3:  add   rdx, rax                  ; Add quads in exponent
        mov   rbx, 64
        sub   rbx, rcx                  ; Subtract bit number from 64
        bts   [r14+rdx*8], rbx          ; Set bit

ttsq4:  nextm
datam

; re**sq ( re sq --- re ) Single-quad integer power of a real number.
; Warning: No overflow checking!

; : re**sq   dup sgn dup 0= if 2drop 2ndrop 1 uq>re a> drop else
;            >a abs a> 0< if >a 1/re else >a then sgnre dup >a 0< if negre then
;            a> a> 0 btst rot and >a >a 1 uq>re 2nswap
;            begin a> dup 0<> while uq/2rem swap >a 0<> if
;                2na! *re 2na> then 2ndup *re
;            repeat drop 2ndrop
;            a> 0< if negre then then ;

head    "re**sq", hlfo
rettsq: dq  docl0
        dq  dupl,signum,dupl,zequ,zbran,rets1
        dq  ddrop,dndrop,one,uqre,froma,drop,bran,rets8
rets1:  dq  toa,absv,froma,zless,zbran,rets2
        dq  toa,invre,bran,rets3
rets2:  dq  toa
rets3:  dq  sgnre,dupl,toa,zless,zbran,rets4
        dq  negre
rets4:  dq  froma,froma,zero,btstf,rot,andf
        dq  toa,toa,one,uqre,dnswap
rets5:  dq  froma,dupl,znequ,wzbrn,rets7
        dq  utsm,swp,toa,znequ,zbran,rets6
        dq  dnast,strre,dnfma
rets6:  dq  dndup,strre,bran,rets5
rets7:  dq  drop,dndrop,froma,zless,zbran,rets8
        dq  negre
rets8:  dq  semis

; flsbre - ( re --- re bit# ) - Return the bit number of the leading
; set bit in the real number on top of the stack. The bit number is negative
; if the real number is less than 1.0. Leave the number on the stack,
; push the bit number. Throw error if number is negative or zero.
; The bit number can be subtracted from p/2 so that x2^m > 2^(p/2)
; for computing logarithms.

head    "flsbre", lgco
flsbr:  dq  flsbr0
textm
flsbr0: bt    qword[r14], 63            ; Test sign bit
        jnc   flsbr1                    ; Branch if clear

        throwm 117                      ; Error if negative

flsbr1: mov   rcx, [qdsz0]              ; Get system quadsize
        mov   rdx, rcx                  ; Make copy
        shl   rdx, 6                    ; Convert to bits
        mov   rsi, r14                  ; Copy stack pointer
flsbr2: cmp   qword[rsi], 0             ; Find leading non-zero quad
        jne   flsbr5                    ; Branch if found

        sub   rdx, 64                   ; Subtract for each zero quad
        add   rsi, 8                    ; Advance pointer
        sub   rcx, 1                    ; Decrement count
        jnz   flsbr2                    ; Loop for count

; If loop falls through, continue with fractional part.

        mov   rcx, [qdsz0]
flsbr3: cmp   qword[rsi], 0
        jne   flsbr4

        sub   rdx, 64
        add   rsi, 8
        sub   rcx, 1
        jnz   flsbr3

        throwm 118                      ; Error if zero

flsbr4: bsr   rcx, [rsi]
        neg   rcx                       ; Subtract from 63
        add   rcx, 64
        sub   rdx, rcx
        jmp   flsbr6

flsbr5: bsr   rcx, [rsi]                ; Find leading set bit
        neg   rcx                       ; Subtract from 63
        add   rcx, 64
        sub   rdx, rcx

flsbr6: sub   r14, 8                    ; Push to stack
        mov   [r14], rdx
        nextm
datam

; sgnre - Return 1 if top real number is positive, -1 if it is negtive,
; or 0 if it is zero. The operand is unaffected.

head    "sgnre", ario
sgnre:  dq  sgre0
textm
sgre0:  mov   rbx, [qdsz0]              ; Get qsz
        shl   rbx, 1                    ; Double for real number
        bt    qword[r14], 63            ; Test sign of entry
        jnc   sgre1                     ; Branch if not negative

        mov   rax, -1                   ; Set signum to -1
        jmp   sgre4                     ; Branch to finish

sgre1:  lea   rsi, [r14+rbx*8]          ; Offset to ls quad of entry
        mov   rdx, -1                   ; Initialize index register
        mov   rcx, rbx                  ; Copy 2*qsz for counter
sgre2:  cmp   qword[rsi+rdx*8], 0       ; Test for zero
        jnz   sgre3                     ; Leave loop if non-zero

        sub   rdx, 1                    ; Decrement index
        sub   rcx, 1                    ; Decrement counter
        jnz   sgre2                     ; Loop

        mov   rax, 0                    ; Set signum to 0
        jmp   sgre4                     ; Branch to finish

sgre3:  mov   rax, 1                    ; Set signum to 1
sgre4:  sub   r14, 8                    ; Make room on stack
        mov   [r14], rax                ; Put signum on stack
        nextm
datam

; intre - Integer part of real number. If positive, zero fractional part.
; If negative, do nothing if fractional part is zero. Otherwise, increment
; integer part and zero remainder of fractional part. Throw overflow if
; increment loop falls through.

head    "intre", ario
intre:  dq  inre0
textm
inre0:  mov   r10, [qdsz0]              ; Get qsz
        lea   rdi, [r14+r10*8]          ; Load addr of fraction
        bt    qword[r14], 63            ; See if number is negative
        jnc   inre3                     ; Branch if not

        mov   rcx, r10                  ; Copy qsz
inre1:  cmp   qword[rdi], 0             ; Test for non-zero quad
        jnz   inre2                     ; Exit loop if found
        add   rdi, 8                    ; Increment pointer
        sub   r10, 1                    ; Decrement count
        jnz   inre1                     ; Loop

; If loop falls through, fraction is zero.

        jmp   inre4

inre2:  add   qword[r14+rcx*8-8], 1     ; Increment the integer part
        jnc   inre3                     ; Leave loop if no carry generated
        sub   rcx, 1                    ; Decrement count
        jnz   inre2                     ; Loop for quad size

;       throwm 19                       ; Throw rounding overflow

inre3:  mov   qword[rdi], 0             ; Zero fractional part
        add   rdi, 8
        sub   r10, 1
        jnz   inre3

inre4:  nextm
datam

; fracre - Fractional part of real number

head    "fracre", ario
fracre: dq  frre0
textm
frre0:  xor   rdx, rdx                  ; Initialize register
        bt    qword[r14], 63            ; See if number is negative
        jnc   frre1                     ; Branch if not

        mov   rdx, -1                   ; Put -1 in register
frre1:  mov   rcx, [qdsz0]              ; Get quad size
frre2:  mov   [r14+rcx*8-8], rdx        ; Fill integer part
        sub   rcx, 1                    ; with -1 or 0
        jnz   frre2
        nextm
datam

; nintre - Round a real number to the nearest integer using round-to-even procedure.

head    "nintre", ario
nntre:  dq  ntre0
textm
ntre0:  mov   r10, [qdsz0]              ; Get qsz
        mov   rcx, r10                  ; Make copy
        lea   rdi, [r14+r10*8]          ; Load addr of fraction
        mov   rax, [rdi]                ; Get high order fraction quad
ntre1:  mov   qword[rdi], 0             ; Zero fractional part
        add   rdi, 8
        sub   rcx, 1
        jnz   ntre1

        bt    rax, 63                   ; Test guard digit
        jnc   ntre3                     ; Round down if zero

        xor   rbx, rbx                  ; Clear register
        shld  rbx, rax, 2               ; Shift in G & R
        shl   rax, 2                    ; Shift G & R out of low order quad
        cmp   rax, 0                    ; Test S - the sticky bit
        jnz   ntre2                     ; Round up if any bits are set

        bt    rbx, 0                    ; Test R
        jc    ntre2                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    qword[r14+r10*8-8], 0     ; Test even bit
        jnc   ntre3                     ; Round down if even

; Round up.

ntre2:  add   qword[r14+r10*8-8], 1
        jnc   ntre3
        sub   r10, 1
        jnz   ntre2

; Fall-through means there was a carry out of the high order quad.
; Throw overflow.

        throwm 19                       ; Throw rounding overflow

ntre3:  nextm
datam

; floore - Greatest integer less than or equal to real number. Works for two's
; complement real numbers by simply zeroing the fractional part.

head    "floore", ario
flore:  dq  flor0
textm
flor0:  mov   rcx, [qdsz0]              ; Get qsz
        lea   rdi, [r14+rcx*8]          ; Load addr of fraction

        xor   rbx, rbx                  ; Put zero in register
        mov   r9, rcx                   ; Copy qsz for shifting

        shr   r9, 1                     ; Shift count right
        jnc   flor1                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Clear destination
        sub   rcx, 1                    ; One quad
        jnz   flor1
        jmp   flor2

flor1:  ssopm 2, shcnt, dfilm

flor2:  nextm
datam

; ceilre - Least integer greater than or equal to real number. If there is
; a non-zero fractional part, increment the integer and zero the fraction.
; Otherwise, do nothing. Throw overflow if increment loop falls through.

head    "ceilre", ario
cere:   dq  cere0
textm
cere0:  mov   r10, [qdsz0]              ; Get qsz
        lea   rdi, [r14+r10*8]          ; Load addr of fraction
        mov   rcx, r10                  ; Copy qsz
cere1:  cmp   qword[rdi], 0             ; Test for non-zero quad
        jnz   cere2                     ; Exit loop if found
        add   rdi, 8                    ; Increment pointer
        sub   r10, 1                    ; Decrement count
        jnz   cere1                     ; Loop

; If loop falls through, fraction is zero.

        jmp   cere4

cere2:  add   qword[r14+rcx*8-8], 1     ; Increment the integer part
        jnc   cere3                     ; Leave loop if no carry generated
        sub   rcx, 1                    ; Decrement count
        jnz   cere2                     ; Loop for quad size

;       throwm 19                       ; Throw rounding overflow

cere3:  mov   qword[rdi], 0             ; Zero fractional part
        add   rdi, 8
        sub   r10, 1
        jnz   cere3
cere4:  nextm
datam

; absre - Absolute value of real number

head    "absre", ario
absre:  dq  abre0
textm
abre0:  bt    qword[r14], 63
        jnc   abre3

        mov   rcx, [qdsz0]
        shl   rcx, 1
        mov   rbx, rcx
abre1:  not   qword[r14+rcx*8-8]
        sub   rcx, 1
        jnz   abre1
abre2:  add   qword[r14+rbx*8-8], 1
        jnc   abre3
        sub   rbx, 1
        jnz   abre2
abre3:  nextm
datam

; negre - negate a real number. This routine was modified to start not at
;        the lowest order quad, but at the lowest order non-zero quad.

head    "negre", ario
negre:  dq  ngre0
textm
ngre0:  mov   rcx, [qdsz0]              ; Get qsz
        shl   rcx, 1                    ; Double for real data

; Find trailing non-zero quad

ngre1:  cmp   qword[r14+rcx*8-8], 0     ; Scan for non-zero quad
        jnz   ngre2
        sub   rcx, 1
        jnz   ngre1

; If loop falls through, real number is zero. Do nothing

        jmp   ngre5

ngre2:  mov   rbx, rcx                  ; Copy quad count
ngre3:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   ngre3
ngre4:  add   qword[r14+rbx*8-8], 1
        jnc   ngre5
        sub   rbx, 1
        jnz   ngre4
ngre5:  nextm
datam

; +re - Add the top two real numbers on the stack.

head    "+re", ario
plsre:  dq  plre0
textm
plre0:  mov   rcx, [qdsz0]              ; Get quadsize
        shl   rcx, 1                    ; Double quad count
        lea   rdi, [r14-8]              ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Offset to second entry
        xor   rbx, rbx                  ; Zero carry register
plre1:  mov   rdx, [rdi+rcx*8]          ; Get first/next addend
        add   [r14+rcx*8-8], rbx        ; Add carry register
        setc  al                        ; If carry results,
        movzx rax, al                   ; set rax
        add   [r14+rcx*8-8], rdx        ; Add to result
        setc  bl                        ; If carry results,
        movzx rbx, bl                   ; set rbx
        or    rbx, rax                  ; Set carry for next quad
        sub   rcx, 1                    ; Decrement counter
        jnz   plre1                     ; Loop for quad count
        nextm
datam

; -re - Subtract the top real number from the 2nd.

head    "-re", ario
mnsre:  dq  mnre0
textm
mnre0:  mov   rcx, [qdsz0]              ; Get quadsize
        shl   rcx, 1                    ; Double quad count
        lea   rdi, [r14-8]              ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Offset to second entry
        xor   rbx, rbx                  ; Zero borrow register
mnre1:  mov   rdx, [rdi+rcx*8]          ; Get first subtrahend quad
        sub   [r14+rcx*8-8], rbx        ; Subtract borrow
        setc  al                        ; If borrow results,
        movzx rax, al                   ; set rax
        sub   [r14+rcx*8-8], rdx        ; Subtract from result
        setc  bl                        ; If borrow results,
        movzx rbx, bl                   ; set rbx
        or    rbx, rax                  ; Set borrow for next quad
        sub   rcx, 1
        jnz   mnre1
        nextm
datam

; *re - Multiprecision real product. For this operation, the quadsize is doubled
; and the real operands are treated as integers and multiplied to yield a qsz*4
; result. This result can overflow for real numbers if it contains more than
; (qsz*192)-2 bits. The process proceeds as follows:
;
; 1) Double the quadsize.
; 2) Render the absolute values of the operands and determine the sign of result.
; 3) Find the lead quad, while establishing the most significant bit, for each
;   operand. The lead quads will be used in the multiplication step.
; 4) Check for overflow using the sum of the bits in each operand, minus one if
;   the next most significant bit of either operand is 0. For real numbers this
;   value cannot exceed (qsz*192)-2 bits.
; 5) Double the quadsize (from qsz*2) to do the multiplication in qsz*4.
; 6) Round the result from the low order qsz quads.
; 7) Overwrite the multiplicand with the product.

; Rstack frame usage:

;   [r15+24] - r12
;   [r15+16] - multiplicand MS address
;   [r15+8]  - product MS address
;   [r15]    - flags

; Register usage:

;   r12 - product pointer
;   r11 - multiplier bit count/carry register
;   r9  - multiplicand quad count
;   r8  - multiplier quad count
;   rbp - bit accumulator/inner multiplication loop counter
;   rdi - multiplicand pointer
;   rsi - multiplier pointer
;   rdx - high order product
;   rcx - counter/index register
;   rbx - multiplier
;   rax - low order product

head    "*re", ario
strre:  dq  stre0
textm
stre0:  sub   r15, 32                   ; Create frame on return stack
        mov   [r15+24], r12             ; Free up r12
        mov   qword[r15], 0             ; Initialize flags to zero
        mov   rsi, r14                  ; Set multiplier MS address
        mov   r10, [qdsz0]              ; Get quadsize
        shl   r10, 1                    ; Double for real numbers
        lea   rdi, [r14+r10*8]          ; Set multiplicand MS address
        mov   [r15+16], rdi             ; Save multiplicand MS address

; Test sign of multiplier and negate if negative.

        bt    qword[rsi], 63            ; Test sign of multiplier
        jnc   stre3                     ; Branch if positive

        btc   qword[r15], 0             ; Complement sign flag if negative
        mov   rcx, r10                  ; Set index/counter
stre1:  not   qword[rsi+rcx*8-8]        ; Negate multiplier
        sub   rcx, 1
        jnz   stre1

        mov   rcx, r10
stre2:  add   qword[rsi+rcx*8-8], 1
        jnc   stre3

        sub   rcx, 1
        jnz   stre2

; Test sign of multiplicand and negate if negative.

stre3:  bt    qword[rdi], 63            ; Test sign of multiplicand
        jnc   stre6                     ; Branch if positive

        btc   qword[r15], 0             ; Complement sign flag if negative
        mov   rcx, r10                  ; Set counter
stre4:  not   qword[rdi+rcx*8-8]        ; Negate multiplicand
        sub   rcx, 1
        jnz   stre4

        mov   rcx, r10
stre5:  add   qword[rdi+rcx*8-8], 1
        jnc   stre6

        sub   rcx, 1
        jnz   stre5

; Find quad count and high-order bit of multiplier.

stre6:  mov   rbp, r10                  ; Copy quadsize
        shl   rbp, 6                    ; Convert to bits
        mov   r8, r10                   ; Set counter
        xor   rdx, rdx                  ; Initialize index
stre7:  cmp   qword[rsi+rdx*8], 0       ; Scan forward
        jnz   stre9

        sub   rbp, 64                   ; Subtract for each zero quad
        add   rdx, 1                    ; Increment index
        sub   r8, 1                     ; Decrement count
        jnz   stre7                     ; Loop

; If loop falls through, multiplier is zero. Overwrite multiplicand
; with multiplier.

        lea   r14, [r14+r10*8]          ; Offset stack past multiplier
        mov   rcx, r10                  ; Get qsz
stre8:  mov   rax, [rsi+rcx*8-8]        ; Overwrite multiplicand
        mov   [r14+rcx*8-8], rax
        sub   rcx, 1
        jnz   stre8

        jmp   stre25

stre9:  bsr   rcx, [rsi+rdx*8]          ; Find leading set bit
        mov   rbx, rcx                  ; Save copy
        neg   rcx                       ; Subtract from 63
        add   rcx, 64
        sub   rbp, rcx

; Add 1 to bit# for bit count

        add   rbp, 1
        mov   r11, rbp                  ; Save multiplier bit count
        cmp   rbx, 0                    ; See if bit number was zero
        jz    stre10                    ; I so, branch to set 2nd MS bit flag

        sub   rbx, 1                    ; Bit# of 2nd MS bit
        bt    [rsi+rdx*8], rbx
        jc    stre11                    ; Branch if 1

stre10: bts   qword[r15], 1             ; Set 2nd most significant digit flag

; Find quad count and high-order bit of multiplicand.

stre11: mov   rbp, r10                  ; Copy quadsize
        shl   rbp, 6                    ; Convert to bits
        mov   r9, r10                   ; Set counter
        xor   rdx, rdx                  ; Initialize index
stre12: cmp   qword[rdi+rdx*8], 0       ; Scan forward
        jnz   stre13

        sub   rbp, 64                   ; Subtract for each zero quad
        add   rdx, 1                    ; Increment index
        sub   r9, 1                     ; Decrement count
        jnz   stre12                    ; Loop

; If loop falls through, multiplicand is zero. Drop multiplier.

        lea   r14, [r14+r10*8]          ; Pop multiplier
        jmp   stre25

stre13: bsr   rcx, [rdi+rdx*8]          ; Find leading set bit
        mov   rbx, rcx                  ; Save copy
        neg   rcx                       ; Subtract from 63
        add   rcx, 64
        sub   rbp, rcx

        cmp   rbx, 0                    ; See if bit number was zero
        jz    stre14                    ; I so, subtract 1 from combined bit

; Add 1 to bit# for bit count

        add   rbp, 1
        add   r11, rbp                  ; Add to multiplier bit count
        btr   qword[r15], 1             ; Test 2nd most bit digit flag
        jc    stre14                    ; Branch if set

; If 2nd most significant bit of either operand is zero subtract
; 1 from combined bit count.

        sub   rbx, 1
        bt    [rdi+rdx*8], rbx
        jc    stre15

stre14: sub   r11, 1                    ; Subtract 1

; Determine if overflow will occurr.

stre15: mov   rcx, r10                  ; Copy qsz*2
        add   rcx, [qdsz0]              ; Add qsz
        shl   rcx, 6                    ; Convert qsz*2 to bits
        sub   rcx, 2                    ; Subtract 2
        cmp   rcx, r11                  ; Compare combined operand bits
        jnc   stre16

        throwm 27                       ; Throw multiplication overflow

; Clear stack space for product and set product MS address.

stre16: mov   r12, r14                  ; Copy stack pointer
        mov   rcx, r10                  ; Copy qsz
        shl   rcx, 1                    ; Double it
stre17: sub   r12, 8                    ; Clear stack space for product
        mov   qword[r12], 0
        sub   rcx, 1                    ; Decrement counter
        jnz   stre17                    ; Loop

        mov   [r15+8], r12              ; Save result MS address
        lea   r12, [r12+r10*8]          ; Load product pointer

; Use operand with the biggest quad count for inner loop.

        cmp   r8, r9
        jna   stre18                    ; Multiplicand quad count greater or equal

        xchg  r9, r8                    ; Else exchange counts
        xchg  rsi, rdi                  ; and addresses

; Begin multiplication loop

stre18: lea   rsi, [rsi+r10*8-8]        ; Set pointer to low order multiplier

stre19: xor   r11, r11                  ; Clear carry register
        mov   rbx, [rsi]                ; Get first/next multiplier quad.
        test  rbx, rbx                  ; Skip multiplication if operand
        jz    stre21                    ; is zero

        mov   rcx, r10                  ; Set/reset index register
        mov   rbp, r9                   ; Set/reset inner loop counter

; Begin inner multiplication loop

stre20: mov   rax, rbx                  ; Copy multiplier quad
        mul   qword[rdi+rcx*8-8]        ; Multiply by first/next multiplicand quad
        add   rdx, r11                  ; Add carry from previous loop
        add   [r12+rcx*8-8], rax        ; Add low order to result
        adc   [r12+rcx*8-16], rdx       ; Add high order to result
        setc  r11b                      ; Save state of carry
        movzx r11, r11b                 ; Extend for adding in on next loop
        sub   rcx, 1                    ; Decrement index
        sub   rbp, 1                    ; Decrement counter
        jnz   stre20                    ; Loop

stre21: sub   r12, 8                    ; Decrement product pointer
        sub   rsi, 8                    ; Decrement operand pointer
        sub   r8, 1                     ; Decrement outer loop counter
        jnz   stre19                    ; Loop

; Round result from trailing qsz quads.

; Overwrite multiplicand with qsz*4 result, pared by one quadsize at both ends
; to yield a qsz*2 product.

        mov   r12, [r15+8]              ; Get saved product MS address
        mov   rdi, [r15+16]             ; Get saved mulitplicand MS address
        mov   r8, r10                   ; Copy qsz*2
        shl   r8, 2                     ; Multiply by 4 for bytes in qsz
        add   r12, r8                   ; Offset past 1st qsz of result
        mov   rcx, r10                  ; Set counter to qsz*2
stre22: mov   rax, [r12+rcx*8-8]
        mov   [rdi+rcx*8-8], rax
        sub   rcx, 1
        jnz   stre22

; Set stack pointer to multiplicand MS address.

        mov   r14, rdi

; Negate result if one of the operands is negative.

        btr   qword[r15], 0             ; Test and clear sign flag
        jnc   stre25                    ; Branch if flag was clear

        mov   rcx, r10                  ; Copy qsz*2
stre23: not   qword[r14+rcx*8-8]        ; Negate product
        sub   rcx, 1
        jnz   stre23

        mov   rcx, r10
stre24: add   qword[r14+rcx*8-8], 1
        jnc   stre25

        sub   rcx, 1
        jnz   stre24

stre25: mov   r12, [r15+24]             ; Restore r12
        add   r15, 32                   ; Release rstack frame
        nextm
datam

; /re - Quotient of two real numbers

; : /re   qsz*2 0 us>in nbrot in>2in qsz*2 /modin nslip qsz/2 qsz/2 ndrop nslide ;

head    "/re", hlfo
slshre: dq  docl0
        dq  qstt,zero,uqtin,nbrot,inttin,qstt,slmi
        dq  nslip,qsst,qsst,ndrop,nslid,semis

; 1/re - Inverse of a real number

; : 1/re   1 uq>re 2nswap /re ;

head    "1/re", hlfo
invre:  dq  docl0
        dq  one,uqre,dnswap,slshre,semis

; bpowre - Raise the real number on the stack to the integral power
; of the base. ( re n --- re ).

head    "bpowre"
bpowre: dq  bpwr0
textm
bpwr0:  mov   r9, [r14]                 ; Get exponent
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get quadsize
        xor   rbp, rbp                  ; Zero flags register
        cmp   r9, 0                     ; See if exponent is 0
        jz    bpwr18                    ; Do nothing if so

        mov   r8, [base0]               ; Get number base
        shl   r10, 1                    ; Temporarily double qsz
        bt    qword[r14], 63            ; Test sign of real entry
        jnc   bpwr3                     ; Branch if positive

; Negate if negative

        bts   rbp, 0                    ; Set sign flag
        mov   rcx, r10                  ; Set counter
bpwr1:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   bpwr1
        mov   rcx, r10                  ; Reset counter
bpwr2:  add   qword[r14+rcx*8-8], 1
        jnc   bpwr3
        sub   rcx, 1
        jnz   bpwr2

bpwr3:  bt    r9, 63                    ; See if exponent is negative
        jnc   bpwr4                     ; Branch if not
        neg   r9                        ; Negate exponent
        jmp   bpwr8                     ; Branch to divide

bpwr4:  mov   rdi, r14                  ; Copy stack pointer
        xor   rdx, rdx                  ; Clear high order product
        xor   rbx, rbx                  ; Clear high order transfer register
bpwr5:  mov   rcx, r10                  ; Set/reset inner loop counter
bpwr6:  mov   rax, [rdi+rcx*8-8]        ; Get first quad
        mul   r8                        ; Multiply by number base
        add   rax, rbx                  ; Add digit/high order
        jnc   bpwr7                     ; Branch if no carry
        add   rdx, 1                    ; Else add carry
bpwr7:  mov   [rdi+rcx*8-8], rax        ; Install result on stack
        mov   rbx, rdx                  ; Copy high order
        sub   rcx, 1                    ; Decrement count
        jnz   bpwr6                     ; Loop for qsz
        test  rdx, rdx                  ; Check for overflow
        jnz   bpwr16                    ; Branch if overflow
        bt    qword[r14], 63            ; Test sign of high order
        jc    bpwr16                    ; Overflow if set
        sub   r9, 1                     ; Decrement exponent count
        jnz   bpwr5                     ; Loop for count
        jmp   bpwr12                    ; Branch to finish

bpwr8:  xor   rax, rax                  ; Clear quotient register
bpwr9:  btr   rbp, 1                    ; Clear non-zero result flag
        xor   rdx, rdx                  ; Clear remainder register
        mov   rdi, r14                  ; Copy stack pointer
        mov   rcx, r10                  ; Set/reset inner loop counter
bpwr10: mov   rax, [rdi]                ; Get first/next stack quad
        div   r8                        ; Divide by number base
        cmp   rax, 0                    ; See if result is zero
        jz    bpwr11                    ; Branch if so
        bts   rbp, 1                    ; Set non-zero result flag

bpwr11: mov   [rdi], rax                ; Return to stack
        add   rdi, 8                    ; Advance pointer
        sub   rcx, 1                    ; Decrement quad counter
        jnz   bpwr10                    ; Loop for double qsz count
        bt    rbp, 1                    ; Test non-zero result flag
        jnc   bpwr17                    ; Underflow if flag not set

        sub   r9, 1                     ; Decrement exponent counter
        jnz   bpwr9                     ; Loop for count

bpwr12: btr   rbp, 0                    ; Test/clear sign flag
        jnc   bpwr18                    ; Branch if flag was clear

        mov   rcx, r10                  ; Set counter
bpwr13: not   qword[r14+rcx*8-8]        ; Negate result
        sub   rcx, 1
        jnz   bpwr13
        mov   rcx, r10                  ; Reset counter
bpwr14: add   qword[r14+r9*8-8], 1
        jnc   bpwr18
        sub   rcx, 1
        jnz   bpwr14
        jmp   bpwr18                    ; Branch to finish

bpwr16: throwm 27                       ; Throw multiplication overflow

bpwr17: throwm 48                       ; Throw division underflow

bpwr18: nextm
datam

; srexpseed - Seed for square root is derived from the location
; of the lead bit.

; : srexpseed   flsbre dup 0< if negate 2/ 2nlsl else 2/ 2nlsr then ;

head    "srexpseed", hlfo
srexsd: dq  docl0,flsbr,dupl
        dq  zless,zbran,srex1
        dq  negate,tslsh,dnsl
        dq  bran,srex2
srex1:  dq  tslsh,dnsr
srex2:  dq  semis

; sqrtseed - Defer to seed iteration method for square root. Default is to
; seed using `srexpseed`.

head    "sqrtseed", dfro
sqtsd:  dq  ddfr0
        dq  srexsd

; sqrtre - Returns the square root of a real number using Newton's method.
; The stopping criterion is whether there is a change in the result
; from the beginning to the end of an iteration. To get the number of
; iterations when the calculation is complete, use sqtcnt@.
; A negative argument will throw "argument cannot be negative" error.
; The seed value is obtained from the defer, `sqrtseed`, which is set
; by default to obtain the initial value from dividing the exponent
; of the radicand by 2.
; The default startup file is set up so that if FPUmath is loaded,
; the initial value will be obtained from the IEEE extended-precision
; version of the radicand, and if quadmath is loaded the initial value
; will be obtained from the IEEE quad-precision version of the radicand.
; This speeds up the algorithm, but note that very large numbers may not
; be representable in standard floating-point format, resulting in the error
; message, "number cannot be represented in the requested IEEE format". 

; : sqrtre  sgnre 0< if 120 throw then 0 sqtcnt ! 2ndup sqtsd begin
;          2na! 4ndup /re 2nswap +re re/2 1 sqtcnt +! =re2nadrop
;          until 2nslip ;

head    "sqrtre", hlfo
sqtre:  dq  docl0
        dq  sgnre,zless,izbrn,sqrt1
        dq  lit,117,throw
sqrt1:  dq  zero,lit,sqtcnt,stor,dndup,sqtsd
sqrt2:  dq  dnast,qndup,slshre
        dq  dnswap,plsre,reslt,one,lit,sqtcnt,plstor
        dq  aseq,uzbrn,sqrt2
        dq  dnslip,semis
sqtcnt: dq  0

; sqtcnt@ - Returns the current value of the sqrtre iteration count.

head    "sqtcnt@", hlfo
sqtat:  dq  docl0,lit,sqtcnt,qat,semis

; crexpseed - Seed for cube root is derived from the location
; of the lead bit.

; : crexpseed   flsbre dup 0< if negate 3 / 2nlsl else 3 / 2nlsr then ;

head    "crexpseed", hlfo
crexsd: dq  docl0,flsbr,dupl
        dq  zless,zbran,crex1
        dq  negate,three,slash
        dq  dnsl,bran,crex2
crex1:  dq  three,slash,dnsr
crex2:  dq  semis

; cbrtseed - Defer to seed Halley's method for cube root. Default is to
; seed using `crexpseed`.

head    "cbrtseed", dfro
cbtsd:  dq  ddfr0
        dq  crexsd

; cbrtre - Returns the cube root of a real number using Halley's method.
; The stopping criterion is whether there is a change in the result
; from the beginning to the end of an iteration. To get the number of
; iterations when the calculation is complete, use cbtcnt@.
; The seed value is obtained from the defer, `cbrtseed`, which is set
; by default to obtain the initial value from dividing the exponent
; of the radicand by 3. 
; The default startup file is set up so that if FPUmath is loaded,
; the initial value will be obtained from the IEEE extended-precision
; version of the radicand, and if quadmath is loaded the initial value
; will be obtained from the IEEE quad-precision version of the radicand.
; This saves some iterations, but note that very large numbers may not
; be representable in standard floating-point format, resulting in the error
; message, "number cannot be represented in the requested IEEE format". 
;
; : cuberoot   sgnre dup >a 0< if negre then 0 cbtcnt ! 2ndup cbrtseed
;            begin 2na! 2ndup 4ndup *re *re 2 2npick 2nover
;            +re 2ndup 4 2npick +re 2 2nxch +re /re *re 1 cbtcnt +!
;            =re2nadrop until 2nslip a> 0< if negre then ;

head    "cbrtre", hlfo
cbtre:  dq  docl0
        dq  sgnre,dupl,toa,zless,izbrn,cbrt1
        dq  negre
cbrt1:  dq  zero,lit,cbtcnt,stor,dndup,cbtsd
cbrt2:  dq  dnast,dndup,qndup,strre,strre
        dq  two,dnpick,dnover,plsre,dndup,four,dnpick
        dq  plsre,two,dnxch,plsre,slshre,strre,one,lit
        dq  cbtcnt,plstor,aseq,uzbrn,cbrt2
        dq  dnslip,froma,zless,izbrn,cbrt3
        dq  negre
cbrt3:  dq  semis
cbtcnt: dq  0

; cbtcnt@ - Returns the current value of the sqrtre iteration count.

head    "cbtcnt@", hlfo
cbtat:  dq  docl0,lit,cbtcnt,qat,semis

; agmre - Returns the arithmetic-geometric mean of the top two real numbers.
; A count of iterations can be kept in a variable as shown in the
; parentheses.

; : agmre  ( 0 cnt ! ) begin 4ndup +re re/2 2nbrot
;         *re sqrtre 2nswap ( 1 cnt +! ) =re until 2ndrop ;

head    "agmre", hlfo
agmre:  dq  docl0
        dq  zero,lit,agmcnt,stor
agmr1:  dq  qndup,plsre,reslt,dnbrot
        dq  strre,sqtre,dnswap,one,lit,agmcnt,plstor
        dq  requ,uzbrn,agmr1
        dq  dndrop,semis
agmcnt: dq  0

; agmcnt@ - Returns the current value of the sqrtre iteration count.

head    "agmcnt@", hlfo
agmat:  dq  docl0,lit,agmcnt,qat,semis

; Real Number Constants and Operators

; ere - Calculates e using the Taylor Series e = 1 + 1/1! + 1/2! + 1/3! + ...
; Relies on division underflow in re/sq to determine when to stop.

; : ere   1 ecnt ! 1 sq>re 2ndup begin ecnt @ re/sq 0=re not
;        while 2nswap 2nover +re 1 ecnt +! 2nswap repeat 2ndrop ;

head    "ere", hlfo
expn:   dq  docl0
        dq  one,lit,ecnt,stor,one,sqre,dndup
expn1:  dq  lit,ecnt,qat,redsq,rezq
        dq  notf,wzbrn,expn2
        dq  dnswap,dnover,plsre
        dq  one,lit,ecnt,plstor,dnswap
        dq  rbran,expn1
expn2:  dq  dndrop,semis
ecnt:   dq  0

; ecnt@ - Returns the current value of the e iteration count.

head    "ecnt@", hlfo
ecntat: dq  docl0,lit,ecnt,qat,semis

; ln2re - Calculates ln(2) using the Euler transform on the Mercator series:
;      ln 2 = 1/2 + 1/2*2^2 + 1/3*2^3 + 1/4*2^4 ...
; Relies on division underflow in re/sq to determine when to stop.

; : ln2re   2 ln2cnt ! 1 sq>re 2 re/sq 2ndup begin 2 re/sq 2ndup ln2cnt @ re/sq
;         0=re not while 2nrot +re 2nswap 1 ln2cnt +! repeat 2ndrop 2ndrop ;

head    "ln2re", hlfo
lntwo:  dq  docl0
        dq  two,lit,ln2cnt,stor,one,sqre,two,redsq,dndup
lntw1:  dq  two,redsq,dndup,lit,ln2cnt,qat,redsq,rezq
        dq  notf,wzbrn,lntw2
        dq  dnrot,plsre,dnswap,one,lit,ln2cnt,plstor
        dq  rbran,lntw1
lntw2:  dq  dndrop,dndrop,semis
ln2cnt  dq  0

; ln2cnt@ - Returns the current value of the ln2 iteration count.

head    "ln2cnt@", hlfo
ln2cat  dq  docl0,lit,ln2cnt,qat,semis

; ln2-guard - Since the algorithm for ln2 is inaccurate in the last few digits,
; this operator creates a quard quad below the usual bottom of the stack,
; increments qsz by 1, calculates ln2, drops the top stack quad, and restores
; the previous qsz. Thus avoiding having to move the result when reverting
; to the previous quadsize.

; : ln2-guard  qsz@ dup >a 1+ qsz! drop ln2re drop a> qsz! ;

head    "ln2-guard", hlfo
lntgrd: dq  docl0
        dq  qszat,dupl,toa,onep,qszsto
        dq  drop,lntwo,drop,froma,qszsto,semis

; pire - Calculates pi using the Brent-Salamin algorithm.
; Maintains a count of the number of iterations in picnt,
; which is kept in a dedicated cell at the end of the code.
; To get the number of iterations, use picnt@.
;
; : pire   1 picnt ! 2 uq>re 1/re 2n>a 1 uq>re 2ndup 2 uq>re sqrtre /re
;        begin 4ndup =re not while +re re/2 2nbrot *re sqrtre 2nover
;              2ndup *re 2nover 2ndup *re -re picnt @ 2**sqre *re negre
;              2na> +re 2n>a 1 picnt +!
;        repeat 4ndrop *re re*2 2na> /re ;

head    "pire", hlfo
pire:   dq  docl0
        dq  one,lit,picnt,stor,two,uqre,invre,dntoa
        dq  one,uqre,dndup,two,uqre,sqtre,slshre
pire1:  dq  qndup,requ,notf,wzbrn,pire2
        dq  plsre,reslt,dnbrot,strre,sqtre
        dq  dnover,dndup,strre,dnover,dndup,strre
        dq  mnsre,lit,picnt,qat,ttsqr,strre,negre
        dq  dnfma,plsre,dntoa,one,lit,picnt,plstor
        dq  rbran,pire1
pire2:  dq  qndrop,strre,restt,dnfma,slshre,semis
picnt:  dq  0

; picnt@ - Returns the current value of the pire iteration count.

head    "picnt@", hlfo
pcntat: dq  docl0,lit,picnt,qat,semis

; pi-guard - Since the algorithm for pi is inaccurate in the last few digits,
; this operator creates a quard quad below the usual bottom of the stack,
; increments qsz by 1, calculates pi, drops the top stack quad, and restores
; the previous qsz. Thus avoiding having to move the result when reverting
; to the previous quadsize.

; : pi-guard  qsz@ dup >a 1+ qsz! drop pire drop a> qsz! ;

head    "pi-guard", hlfo
pigrd:  dq  docl0
        dq  qszat,dupl,toa,onep,qszsto
        dq  drop,pire,drop,froma,qszsto,semis

; phire - Calculates the golden ratio to the current quadsize
;        using the square root of 5.
; : phire   5 sq>re sqrtre 1 sq>re +re re/2 ;

head    "phire", hlfo
phire:  dq  docl0
        dq  lit,5,sqre,sqtre,one
        dq  sqre,plsre,reslt,semis

; 12throotof2 - Calculates the twelfth root of two - the basis of the equal
; temperament tuning system.

; : 12throotof2   2 sq>re sqrtre sqrtre cbrtre ;

head    "12throotof2", hlfo
twrttw: dq  docl0
        dq  two,sqre,sqtre,sqtre,cbtre,semis

; Real Number Relational Operators

; 0=re - Push a true flag (-1) if the top stack entry is real zero, push
; a false flag (0) if not. The operand is unaffected.

head    "0=re", rlto
rezq:   dq  rezq0
textm
rezq0:  xor   rbx, rbx                  ; Initialize flag register
        mov   rdx, [qdsz0]              ; Get qsz
        shl   rdx, 1                    ; Double for real data
        mov   rcx, rdx                  ; Set index/counter
rezq1:  cmp   qword[r14+rcx*8-8], 0     ; Test for zero
        jnz   rezq2                     ; Leave loop if non-zero

        sub   rcx, 1                    ; Decrement index/counter
        jnz   rezq1                     ; Loop

        mov   rbx, -1                   ; Return true flag if loop falls through

rezq2:  sub   r14, 8                    ; Push flag to stack
        mov   [r14], rbx                ; Put flag on stack
        nextm
datam

; =re - Push a true flag (-1) to the stack if the top two real numbers are
; equal, push a false flag (0) if not. The operands are unaffected.

head    "=re", rlto
requ:   dq  requ0
textm
requ0:  xor   rbx, rbx                  ; Initialize flag register
        mov   rdx, [qdsz0]              ; Get qsz
        shl   rdx, 1                    ; Double for real data
        lea   rdi, [r14+rdx*8]          ; Offset to second entry
        mov   rcx, rdx                  ; Set index/counter
requ1:  mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        cmp   [rdi+rcx*8-8], rax        ; Compare quads
        jnz   requ2                     ; Branch if not equal

        sub   rcx, 1                    ; Decrement index/counter
        jnz   requ1                     ; Loop

        mov   rbx, -1                   ; Return true if loop falls through

requ2:  sub   r14, 8                    ; Push flag to stack
        mov   [r14], rbx                ; Put flag on stack
        nextm
datam

; <re - Push a true flag (-1) if the top real number is less than the second
; real number, else push a false flag (0). The operands are unaffected.

head    "<re", rlto
relss:  dq  rels0
textm
rels0:  xor   rbp, rbp                  ; Zero flags register
        mov   r10, [qdsz0]              ; Get qsz
        mov   rcx, r10                  ; Copy qsz
        shl   rcx, 1                    ; Double for quad count
        lea   rdi, [r14+rcx*8]          ; Offset to 2nd entry
        bt    qword[r14], 63            ; Test sign of first entry
        jnc   rels1                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag

rels1:  bt    qword[rdi], 63            ; Test sign of second entry
        jnc   rels2                     ; Branch if positive

        btc   rbp, 0                    ; Complement sign flag

rels2:  btr   rbp, 0                    ; Test/clear sign flag
        jnc   rels3                     ; If flag was clear, signs are the same

        mov   rbx, -1                   ; Set flag to true
        bt    qword[r14], 63            ; Test sign of first entry
        jnc   rels10                    ; Return true flag if positive

        mov   rbx, 0                    ; Else return false flag
        jmp   rels10

rels3:  xor   rdx, rdx                  ; Clear index register
        mov   rcx, r10                  ; Get qsz
rels4:  mov   rax, [r14+rdx*8]          ; Get first/next quad
        cmp   [rdi+rdx*8], rax          ; Compare quads
        jnz   rels9                     ; Branch if not equal

        add   rdx, 1                    ; Advance index
        sub   rcx, 1                    ; Decrement counter
        jnz   rels4                     ; Loop

; If loop falls through, the integer portions are the same, compare the fraction
; quads using unsigned arithmetic if both operands are positive and signed
; arithmetic if both operands are negative.

        bt    qword[r14], 63            ; See if signs are negative
        jc    rels7                     ; Branch if so

        mov   rcx, r10
rels5:  mov   rax, [r14+rdx*8]          ; Get first/next quad
        cmp   [rdi+rdx*8], rax          ; Compare quads
        jnz   rels6                     ; Branch if not equal

        add   rdx, 1                    ; Advance index
        sub   rcx, 1                    ; Decrement counter
        jnz   rels5                     ; Loop

; If loop falls through both operands are the same, return 0.

        mov   rbx, 0
        jmp   rels10

rels6:  setc  bl                        ; Set flag for unsigned less than
        neg   bl
        movsx rbx, bl
        jmp   rels10

rels7:  mov   rcx, r10
rels8:  mov   rax, [r14+rdx*8]          ; Get first/next quad
        cmp   [rdi+rdx*8], rax          ; Compare quads
        jnz   rels9                     ; Branch if not equal

        add   rdx, 1                    ; Advance index
        sub   rcx, 1                    ; Decrement counter
        jnz   rels8                     ; Loop

; If loop falls through both operands are the same, return 0.

        mov   rbx, 0
        jmp   rels10

rels9:  setl  bl                        ; Set flag for signed less than
        neg   bl
        movsx rbx, bl

rels10: sub   r14, 8                    ; Push flag to stack
        mov   [r14], rbx
        nextm
datam

; =re2nadrop - Compare the real number on the auxiliary stack with the operand
; on top of the data stack, drop the auxiliary stack value, and put the result
; flag  on the data stack. The top data stack item remains in place.
; This operator is specially useful for Newton-Raphson BEGIN...UNTIL loops.

head    "=re2nadrop", rlto
aseq:   dq  aseq0
textm
aseq0:  xor   rbx, rbx                  ; Initialize flag register
        mov   rdx, [qdsz0]              ; get qsz
        shl   rdx, 1                    ; Double for real data
        lea   rdi, [r13]                ; Load address of auxiliary stack operand
        lea   r13, [r13+rdx*8]          ; Pop auxiliary stack
        mov   rcx, rdx                  ; Set index/counter
aseq1:  mov   rax, [r14+rcx*8-8]        ; Get first/next quad
        cmp   [rdi+rcx*8-8], rax        ; Compare quads
        jnz   aseq2                     ; Branch if not equal

        sub   rcx, 1                    ; Decrement index/counter
        jnz   aseq1                     ; Loop

        mov   rbx, -1                   ; Return true if loop falls through

aseq2:  sub   r14, 8                    ; Make room for flag
        mov   [r14], rbx                ; Put flag on data stack
        nextm
datam

; Real Number Format Conversion Operators

; uq>re - Extend unsigned 64-bit stack entry to a real number in the current qsz.

head    "uq>re", nbco
uqre:   dq  uqre0
textm
uqre0:  mov   r8, [r14]                 ; Get integer
        mov   r10, [qdsz0]              ; Get quadsize
        mov   rcx, r10                  ; Copy qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        shl   rcx, 1                    ; Double qsz for count/index
        neg   rcx                       ; Negate count
        lea   r14, [r14+rcx*8+8]        ; Offset to new stack address
        mov   rdi, r14                  ; Copy new stack pointer
        neg   rcx                       ; Restore count
        xor   rbx, rbx                  ; Set register for clearing

        ssopm 2, shcnt, dfilm

        mov   [r14+r10*8-8], r8         ; Restore integer

        nextm
datam

; sq>re - Sign-extend a 64-bit value to a real number in the current qsz.
; Experimentally the shift count has been set to 5 for this procedure.
; This makes it slightly faster than a shift count of 4, but setting it higher
; has little additional effect.

head    "sq>re", nbco
sqre:   dq  sqre0
textm
sqre0:  mov   r8, [r14]                 ; Get stack entry
        mov   r10, [qdsz0]              ; Get quadsize
        neg   r10                       ; Negate qsz for offset
        lea   r14, [r14+r10*8+8]        ; Adjust stack pointer
        mov   rdi, r14                  ; Save pointer to fraction
        lea   r14, [r14+r10*8]          ; Offset stack to -2*qsz
        neg   r10                       ; Restore system qsz

        xor   rbx, rbx                  ; Clear register
        mov   rcx, r10                  ; Set count to qsz

        mov   r9, rcx                   ; Copy qsz for shift count
        shr   r9, 1                     ; Shift count right
        jnc   sqre1                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Clear 1st quad
        sub   rcx, 1                    ; Decrement count/index
        jnz   sqre1
        jmp   sqre2

sqre1:  ssopm 2, 5, dfilm

; Set register for sign extension.

sqre2:  bt    r8, 63                    ; Test sign of entry
        setc  bl                        ; Set to 0 if no carry, 1 if carry
        neg   bl                        ; Negate result
        movsx rbx, bl                   ; Sign-extend result

        mov   rdi, r14                  ; Set pointer to high order real number
        mov   rcx, r10                  ; Set count to qsz

        mov   [rdi+rcx*8-8], r8         ; Restore single-quad integer
        sub   rcx, 1                    ; Decrement count/index
        jz    sqre4                     ; Exit if qsz=1

        mov   r9, rcx                   ; Copy qsz for shift count
        shr   r9, 1                     ; Shift count right
        jnc   sqre3                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign-extend 1st quad
        sub   rcx, 1                    ; Decrement count/index
        jnz   sqre3
        jmp   sqre4

sqre3:  ssopm 2, 5, dfilm

sqre4:  nextm
datam

; re>sq - Convert a real number to a 64-bit integer. If high order fraction of
; negative argument is not zero, increment integer by 1. Overflow will occur if
; the signs of the high order quad and the low order quad are the same.
; Issue error message if number cannot be represented in 64 bits. No rounding
; is done.

head    "re>sq", nbco
retsq:  dq  resq0
textm
resq0:  mov   r10, [qdsz0]              ; Get quadsize

; If the sign of number is not the same as the sign of the low order quad,
; the number is not representable in 64 bits. Throw error.

        bt    qword[r14], 63            ; Test sign bit
        setc  dl
        bt    qword[r14+r10*8-8], 63    ; Test sign of low order quad
        setc  bl
        xor   bl, dl
        jnz   resq5

        neg   dl
        movsx rdx, dl

        mov   rcx, r10                  ; Copy qsz
        mov   rdi, r14                  ; Copy stack pointer
resq1:  cmp   [rdi], rdx
        jnz   resq2
        add   rdi, 8
        sub   rcx, 1
        jnz   resq1

; If loop falls through, integer is either 0 or -1 and result is already
; in rdx.

        jmp   resq3

; If count is not 1, number is not representable in 64 bits. Throw error.

resq2:  cmp   rcx, 1

        jnz   resq5

        mov   rdx, [r14+r10*8-8]        ; Get low order integer quad

resq3:  mov   rax, [r14+r10*8]          ; Get high order fraction quad

        lea   r14, [r14+r10*8]          ; Pop the stack
        lea   r14, [r14+r10*8]

        bt    rax, 63                   ; Test guard digit
        jnc   resq6                     ; Round down if zero

        xor   rbx, rbx                  ; Clear register
        shld  rbx, rax, 2               ; Shift in G & R
        shl   rax, 2                    ; Shift G & R out of low order quad
        cmp   rax, 0                    ; Test S - the sticky bit
        jnz   resq4                     ; Round up if any bits are set

        bt    rbx, 0                    ; Test R
        jc    resq4                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rdx, 0                    ; Test even bit
        jnc   resq6                     ; Round down if even

; Round up.

resq4:  add   rdx, 1
        jmp   resq6

resq5:  throwm 41

resq6:  sub   r14, 8
        mov   [r14], rdx                ; Install 64-bit integer
        nextm
datam

; in>re - Convert multi-precision integer to real number

; : in>re   0 us>in nswap ;

head    "in>re", hlfo
intore: dq  docl0
        dq  zero,uqtin,nswap,semis

; re>2re - Double the quadsize of the real number on top of the stack.

; : re>2re   0 us>in nbrot in>2in ;

head    "re>2re", hlfo
rettre: dq  docl0
        dq  zero,uqtin,nbrot,inttin,semis

; .re - Output the real number on top of the stack.

; : .re  qsz@ 2* ckstk nob0 base @ re>bsn bsn>ascii count strout space ;

head    ".re", hlfo
dotre:  dq  docl0
        dq  qszat,tstar,ckstk
        dq  nobn,base,qat,rebsn
        dq  bsasc,count,strout,space,semis

; r.re - Output the real number on top of the stack, showing the number
; of digits to the right of the radix point passed on the stack above
; the real number to output.

; : r.re  qsz@ 2* ckstk rdigs @ >a rdigs ! nob0 base @ re>bsn bsn>ascii
;         count strout space a> rdigs ! ;

head    "r.re", hlfo
rdtre:  dq  docl0
        dq  qszat,tstar,onep,ckstk
        dq  rdigs,qat,toa,rdigs,stor
        dq  nobn,base,qat,rebsn
        dq  bsasc,count,strout,space
        dq  froma,rdigs,stor,semis

; maxdigs - Returns the maximum number of digits that can be represented
; to the right of the radix point in the current quadsize and number base.
; This calculation is tailored for this specific case so that it does not
; depend on ForthFiles/Functions.xfs being loaded.
; Since only minimum accuracy is required, the quadsize is set to 1.

; : maxdigs   qsz@ a! 64* 1 qsz! sq>re base @ sq>re re>2re qsz*2 flsbre qsz@ 32*
;           swap - a! 2nlsl 4 sq>re 2nswap /re 1 sq>re agmre re*2 pire 2nswap /re
;           a> sq>re ln2re *re -re qsz/2 ndrop nslide ln2re /re /re
;           re>sq .dec a> qsz! ;

head    "maxdigs", hlfo
mxdigs: dq  docl0
        dq  qszat,asto,sfstr,one,qszsto
        dq  sqre,base,qat,sqre,rettre,qstt
        dq  flsbr,qszat,thtst,swp,minus,asto
        dq  dnsl,four,sqre,dnswap,slshre
        dq  one,sqre,agmre,restt,pire
        dq  dnswap,slshre,froma,sqre,lntwo
        dq  strre,mnsre,qsst,ndrop,nslid
        dq  lntwo,slshre,slshre,retsq
        dq  froma,qszsto,semis

; Multi-quad Rational Number Operators

; raliteral

head    "raliteral", -hlfo
ralite: dq  docl0
        dq  pcomp,ralit,dncom,semis
ralit:  dq  ralt0
textm
ralt0:  lea   rsi, [r12+8]              ; Get address of literal
        mov   rdx, [rsi-8]              ; Get quad size of literal
        lea   r12, [r12+rdx*8+8]        ; Offset IP past literal
        mov   r10, [qdsz0]              ; Get system qsz
        mov   rcx, r10                  ; Copy qsz
        shl   rcx, 1                    ; Double it
        neg   rcx                       ; Prepare for negative offset
        lea   r14, [r14+rcx*8]          ; Load new stack address
        neg   rcx                       ; Restore qsz*2
        mov   rdi, r14                  ; Set temporary stack pointer
        mov   r9, r10                   ; Tentatively set shift count
        cmp   rdx, rcx                  ; See if quadsizes are the same
        jz    ralt16                    ; Branch if so

; Find quadsize of numerator and denominator.

        mov   r8, rdx                   ; Copy literal qsz
        shr   r8, 1                     ; Halve it
        mov   rbp, r8                   ; Save copy

; Set quad for testing and possible sign-extension.

        bt    qword[rsi+rbp*8], 63      ; Test sign of literal
        setc  bl                        ; Set register accordingly
        neg   bl                        ; Negate and
        movsx rbx, bl                   ; sign-extend flag

; Find quadsize difference.

        sub   r8, r10                   ; Subtract system quadsize
        jna   ralt8                     ; Branch if literal qsz/2 not greater

; Literal qsz/2 is greater than system quadsize.
; Test if denominator can be represented in the smaller quadsize.

        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
ralt1:  cmp   qword[rsi+rax*8], 0       ; Compare 1st/next quad
        jnz   ralt7                     ; Overflow if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement qsz difference
        jnz   ralt1

; Test if numerator can be represented.

        lea   rdi, [rsi+rbp*8]          ; Load numerator start addr
        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
ralt2:  cmp   [rdi+rax*8], rbx          ; Compare first/next quad
        jnz   ralt7                     ; Throw if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement counter
        jnz   ralt2                     ; Loop for qsz difference

; Move denominator to stack.

        mov   rdi, r14                  ; Set temporary stack pointer
        lea   rsi, [rsi+r8*8]           ; Adjust base address
        mov   r9, r10                   ; Set for shift count
        mov   rcx, r10                  ; Set for quad count
        shr   r9, 1                     ; Shift count right
        jnc   ralt3                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   ralt3
        jmp   ralt4

ralt3:  ssopm 2, shcnt, dmovm

; Set up to move numerator to stack and finish.

ralt4:  lea   rsi, [rsi+rbp*8]          ; Adjust base address
        lea   rdi, [r14+r10*8]          ; Adjust stack pointer
        mov   r9, r10                   ; Set for shift count
        mov   rcx, r10                  ; Set for quad count
        jmp   ralt15                    ; Branch to move numerator

ralt7:  throwm 21                       ; Throw overflow on fetch

; Twice system quadsize is greater than literal quadsize. Sign-extend
; numerator and zero high order denominator.

ralt8:  neg   r8                        ; Make qsz difference positive

; Pre-sign-extend numerator.

        lea   rdi, [r14+r10*8]          ; Load stack address of numerator
        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   ralt9                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   ralt9
        jmp   ralt10

ralt9:  ssopm 2, shcnt, dfilm

; Pre-extend denominator.

ralt10: mov   rdi, r14                  ; Load stack address of denominator
        xor   rbx, rbx                  ; Zero fill register
        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   ralt11                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   ralt11
        jmp   ralt12

ralt11: ssopm 2, shcnt, dfilm

; Move denominator to stack.

ralt12: lea   rdi, [r14+r8*8]           ; Adjust stack address
        mov   r9, rbp                   ; Use denominator qsz for shift
        mov   rcx, rbp                  ; and quad count
        shr   r9, 1                     ; Shift count right
        jnc   ralt13                    ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   ralt13
        jmp   ralt14

ralt13: ssopm 2, shcnt, dmovm

; Set up to move numerator and finish.

ralt14: lea   rdi, [rdi+r10*8]          ; Adjust stack address
        lea   rsi, [rsi+rbp*8]          ; Adjust literal base address
        mov   r9, rbp
        mov   rcx, rbp

ralt15: shr   r9, 1                     ; Shift count right
        jnc   ralt16                    ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   ralt16
        jmp   ralt17

ralt16: ssopm 2, shcnt, dmovm

ralt17: nextm
datam

; raconstant

head    "raconstant", hlfo
racon:  dq  docl0
        dq  qszat,tstar,ckstk
        dq  dfine,lit,raco,objcom,pcomm,racn0
        dq  dncom,oszcom,semis
textm
racn0:  lea   rsi, [r11+16]             ; Load address of constant
        mov   rdx, [rsi-8]              ; Get quad size of constant
        mov   r10, [qdsz0]              ; Get system quadsize
        mov   rcx, r10                  ; Copy qsz
        shl   rcx, 1                    ; Double it
        neg   rcx                       ; Prepare for negative offset
        lea   r14, [r14+rcx*8]          ; Load new stack address
        neg   rcx                       ; Restore qsz*2
        mov   rdi, r14                  ; Set temporary stack pointer
        mov   r9, r10                   ; Tentatively set shift count
        cmp   rdx, rcx                  ; See if quadsizes are the same
        jz    racn16                    ; Branch if so

; Find quadsize of numerator and denominator.

        mov   r8, rdx                   ; Copy constant qsz
        shr   r8, 1                     ; Halve it
        mov   rbp, r8                   ; Save copy

; Set quad for testing and possible sign-extension.

        bt    qword[rsi+rbp*8], 63      ; Test sign of constant
        setc  bl                        ; Set register accordingly
        neg   bl                        ; Negate and
        movsx rbx, bl                   ; sign-extend flag

; Find quadsize difference.

        sub   r8, r10                   ; Subtract system quadsize
        jna   racn8                     ; Branch if constant qsz/2 not greater

; Constant qsz/2 is greater than system quadsize.
; Test if denominator can be represented in the smaller quadsize.

        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
racn1:  cmp   qword[rsi+rax*8], 0       ; Compare 1st/next quad
        jnz   racn7                     ; Overflow if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement qsz difference
        jnz   racn1

; Test if numerator can be represented.

        lea   rdi, [rsi+rbp*8]          ; Load numerator start addr
        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
racn2:  cmp   [rdi+rax*8], rbx          ; Compare first/next quad
        jnz   racn7                     ; Throw if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement counter
        jnz   racn2                     ; Loop for qsz difference

; Move denominator to stack.

        mov   rdi, r14                  ; Set temporary stack pointer
        lea   rsi, [rsi+r8*8]           ; Adjust base address
        mov   r9, r10                   ; Set for shift count
        mov   rcx, r10                  ; Set for quad count
        shr   r9, 1                     ; Shift count right
        jnc   racn3                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   racn3
        jmp   racn4

racn3:  ssopm 2, shcnt, dmovm

; Set up to move numerator to stack and finish.

racn4:  lea   rsi, [rsi+rbp*8]          ; Adjust base address
        lea   rdi, [r14+r10*8]          ; Adjust stack pointer
        mov   r9, r10                   ; Set for shift count
        mov   rcx, r10                  ; Set for quad count
        jmp   racn15                    ; Branch to move numerator

racn7:  throwm 21                       ; Throw overflow on fetch

; Twice system quadsize is greater than constant quadsize. Sign-extend
; numerator and zero high order denominator.

racn8:  neg   r8                        ; Make qsz difference positive

; Pre-sign-extend numerator.

        lea   rdi, [r14+r10*8]          ; Load stack address of numerator
        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   racn9                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   racn9
        jmp   racn10

racn9:  ssopm 2, shcnt, dfilm

; Pre-extend denominator.

racn10: mov   rdi, r14                  ; Load stack address of denominator
        xor   rbx, rbx                  ; Zero fill register
        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   racn11                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   racn11
        jmp   racn12

racn11: ssopm 2, shcnt, dfilm

; Move denominator to stack.

racn12: lea   rdi, [r14+r8*8]           ; Adjust stack address
        mov   r9, rbp                   ; Use denominator qsz for shift
        mov   rcx, rbp                  ; and quad count
        shr   r9, 1                     ; Shift count right
        jnc   racn13                    ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   racn13
        jmp   racn14

racn13: ssopm 2, shcnt, dmovm

; Set up to move numerator and finish.

racn14: lea   rdi, [rdi+r10*8]          ; Adjust stack address
        lea   rsi, [rsi+rbp*8]          ; Adjust constant base address
        mov   r9, rbp
        mov   rcx, rbp

racn15: shr   r9, 1                     ; Shift count right
        jnc   racn16                    ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   racn16
        jmp   racn17

racn16: ssopm 2, shcnt, dmovm

racn17: nextm
datam

; ravariable - Create a multi-quad rational variable.
; Note: Code field routine is the same as that for invariable
; since the qsz will be the same for both and it is up to the
; fetch and store operators to double the qsz.

head    "ravariable", hlfo
ravar:  dq  docl0
        dq  dfine,lit,ravo,objcom,pcomm,nvar0
        dq  zero,uqtra,dncom,oszcom,semis

; raarray - Create an array of rational numbers in double the current qsz.
; ( n --- ). Arrays are 1-based.
; Array structure (header not shown):

; | code field | number of elements | element size | elements ... |

head    "raarray", hlfo
raar:   dq  docl0
        dq  one,ckstk
        dq  dfine,lit,raao,objcom,pcomm,narr0
        dq  dupl,comma,qszat,tstar,dupl,comma,star,here
        dq  over,estar,allot,swp,zero,qfill,oszcom,semis

; ra@ - Fetch rational number to the stack.

head    "ra@", mqmo
raat:   dq  raat0
textm
raat0:  mov   rsi, [r14+8]              ; Get address of variable
        mov   rdx, [r14]                ; Get qsz of container
        mov   r10, [qdsz0]              ; Get system quadsize
        mov   rcx, r10                  ; Copy system qsz
        shl   rcx, 1                    ; Double it
        neg   rcx                       ; Prepare for negative offset
        lea   r14, [r14+rcx*8+16]       ; Load new stack address
        neg   rcx                       ; Restore qsz*2
        mov   rdi, r14                  ; Set temporary stack pointer
        mov   r9, r10                   ; Tentatively set shift count
        cmp   rdx, rcx                  ; See if quadsizes are the same
        jz    raat16                    ; Branch if so

; Find quadsize of numerator and denominator.

        mov   r8, rdx                   ; Copy variable qsz
        shr   r8, 1                     ; Halve it
        mov   rbp, r8                   ; Save copy

; Set quad for testing and possible sign-extension.

        bt    qword[rsi+rbp*8], 63      ; Test sign of variable
        setc  bl                        ; Set register accordingly
        neg   bl                        ; Negate and
        movsx rbx, bl                   ; sign-extend flag

; Find quadsize difference.

        sub   r8, r10                   ; Subtract system quadsize
        jna   raat8                     ; Branch if variable qsz/2 not greater

; Variable qsz/2 is greater than system quadsize.
; Test if denominator can be represented in the smaller quadsize.

        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
raat1:  cmp   qword[rsi+rax*8], 0       ; Compare 1st/next quad
        jnz   raat7                     ; Overflow if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement qsz difference
        jnz   raat1

; Test if numerator can be represented.

        lea   rdi, [rsi+rbp*8]          ; Load numerator start addr
        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
raat2:  cmp   [rdi+rax*8], rbx          ; Compare first/next quad
        jnz   raat7                     ; Throw if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement counter
        jnz   raat2                     ; Loop for qsz difference

; Move denominator to stack.

        mov   rdi, r14                  ; Set temporary stack pointer
        lea   rsi, [rsi+r8*8]           ; Adjust base address
        mov   r9, r10                   ; Set for shift count
        mov   rcx, r10                  ; Set for quad count
        shr   r9, 1                     ; Shift count right
        jnc   raat3                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   raat3
        jmp   raat4

raat3:  ssopm 2, shcnt, dmovm

; Set up to move numerator to stack and finish.

raat4:  lea   rsi, [rsi+rbp*8]          ; Adjust base address
        lea   rdi, [r14+r10*8]          ; Adjust stack pointer
        mov   r9, r10                   ; Set for shift count
        mov   rcx, r10                  ; Set for quad count
        jmp   raat15                    ; Branch to move numerator

raat7:  throwm 21                       ; Throw overflow on fetch

; Twice system quadsize is greater than variable quadsize. Sign-extend
; numerator and zero high order denominator.

raat8:  neg   r8                        ; Make qsz difference positive

; Pre-sign-extend numerator.

        lea   rdi, [r14+r10*8]          ; Load stack address of numerator
        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   raat9                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   raat9
        jmp   raat10

raat9:  ssopm 2, shcnt, dfilm

; Pre-extend denominator.

raat10: mov   rdi, r14                  ; Load stack address of denominator
        xor   rbx, rbx                  ; Zero fill register
        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   raat11                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   raat11
        jmp   raat12

raat11: ssopm 2, shcnt, dfilm

; Move denominator to stack.

raat12: lea   rdi, [r14+r8*8]           ; Adjust stack address
        mov   r9, rbp                   ; Use denominator qsz for shift
        mov   rcx, rbp                  ; and quad count
        shr   r9, 1                     ; Shift count right
        jnc   raat13                    ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   raat13
        jmp   raat14

raat13: ssopm 2, shcnt, dmovm

; Set up to move numerator and finish.

raat14: lea   rdi, [rdi+r10*8]          ; Adjust stack address
        lea   rsi, [rsi+rbp*8]          ; Adjust variable base address
        mov   r9, rbp
        mov   rcx, rbp

raat15: shr   r9, 1                     ; Shift count right
        jnc   raat16                    ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   raat16
        jmp   raat17

raat16: ssopm 2, shcnt, dmovm

raat17: nextm
datam

; ra! - Store rational number.

head    "ra!", mqmo
rastr:  dq  rast0
textm
rast0:  mov   rdi, [r14+8]              ; Get address of variable
        mov   r8, [r14]                 ; Get qsz of container
        mov   r10, [qdsz0]              ; Get system quadsize
        shr   r8, 1                     ; Halve it
        lea   rsi, [r14+16]             ; Load temporary stack pointer
        mov   rdx, r10                  ; Copy system qsz
        shl   rdx, 1                    ; Double it
        cmp   r8, r10                   ; See if quadsizes are the same
        jz    rast16                    ; Branch if so

        mov   rbp, r8                   ; Save numerator/denominator qsz

; Set quad for testing and possible sign-extension.

        bt    qword[rsi+r10*8], 63      ; Test sign of stack entry
        setc  bl                        ; Set register accordingly
        neg   bl                        ; Negate and
        movsx rbx, bl                   ; sign-extend flag

; Find quadsize difference.

        mov   r8, r10                   ; Copy system qsz
        sub   r8, rbp                   ; Subtract variable qsz/2
        jna   rast8                     ; Branch if system qsz not greater

; System quadsize is greater than variable qsz/2.
; Test if denominator can be represented in the smaller quadsize.

        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
rast1:  cmp   qword[rsi+rax*8], 0       ; Compare 1st/next quad
        jnz   rast7                     ; Overflow if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement qsz difference
        jnz   rast1

; Test if numerator can be represented.

        lea   r14, [r14+r10*8+16]       ; Load numerator start addr
        xor   rax, rax                  ; Zero index
        mov   rcx, r8                   ; Copy qsz difference
rast2:  cmp   [r14+rax*8], rbx          ; Compare first/next quad
        jnz   rast7                     ; Throw if not equal
        add   rax, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement counter
        jnz   rast2                     ; Loop for qsz difference

; Move denominator to variable.

        lea   rsi, [rsi+r8*8]           ; Adjust stack address
        mov   r9, rbp                   ; Set for shift count
        mov   rcx, rbp                  ; Set for quad count
        shr   r9, 1                     ; Shift count right
        jnc   rast3                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   rast3
        jmp   rast4

rast3:  ssopm 2, shcnt, dmovm

; Set up to move numerator to variable and finish.

rast4:  lea   r14, [r14+r10*8]          ; Pop stack
        lea   rsi, [rsi+r10*8]          ; Adjust temporary stack pointer
        lea   rdi, [rdi+rbp*8]          ; Adjust variable base address
        mov   r9, rbp                   ; Set for shift count
        mov   rcx, rbp                  ; Set for quad count
        jmp   rast15                    ; Branch to move numerator

rast7:  throwm 20                       ; Throw overflow on store

; Variable quadsize is greater than twice system quadsize. Zero high order
; denominator and sign-extend numerator.

rast8:  neg   r8                        ; Make qsz difference positive

; Pre-extend denominator.

        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   rast9                     ; Branch if no carry

        mov   qword[rdi+rcx*8-8], 0     ; Extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   rast9
        jmp   rast10

rast9: ssopm 2, shcnt, dzrom

; Move denominator to variable.

rast10: lea   rdi, [rdi+r8*8]           ; Adjust variable base address
        mov   r9, r10                   ; Use system qsz for shift
        mov   rcx, r10                  ; and quad count
        shr   r9, 1                     ; Shift count right
        jnc   rast11                    ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   rast11
        jmp   rast12

rast11: ssopm 2, shcnt, dmovm

; Pre-sign-extend numerator.

rast12: lea   rdi, [rdi+r10*8]          ; Load address of numerator
        mov   rcx, r8                   ; Use qsz difference for count
        mov   r9, r8                    ; and shift count
        shr   r9, 1                     ; Shift right
        jnc   rast13                    ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Sign extend 1st quad
        sub   rcx, 1                    ; Decrement difference/index
        jnz   rast13
        jmp   rast14

rast13: ssopm 2, shcnt, dfilm

; Set up to move numerator and finish.

rast14: lea   r14, [r14+rdx*8+16]       ; Pop stack
        lea   rdi, [rdi+r8*8]           ; Adjust variable base address
        lea   rsi, [rsi+r10*8]          ; Adjust stack address
        mov   r9, r10                   ; Set shift count
        mov   rcx, r10                  ; Set quad count

rast15: shr   r9, 1                     ; Shift shift count right
        jnc   rast17                    ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   rast17
        jmp   rast18

rast16: lea   r14, [r14+rdx*8+16]       ; Pop stack
        mov   r9, r10                   ; Set shift count
        mov   rcx, rdx                  ; Set quad count

rast17: ssopm 2, shcnt, dmovm

rast18: nextm
datam

; sgnra - Return 1 if top rational number is positive, -1 if it is negative,
; or 0 if it is zero. The operand is unaffected.

head    "sgnra", ario
sgnra:  dq  sgra0
textm
sgra0:  mov   rbx, [qdsz0]              ; Get quadsize
        lea   rdi, [r14+rbx*8]          ; Offset to numerator
        bt    qword[rdi], 63            ; Test sign of entry
        jnc   sgra1                     ; Branch if not negative

        mov   rax, -1                   ; Set signum to -1
        jmp   sgra4                     ; Branch to finish

sgra1:  lea   rsi, [rdi+rbx*8]          ; Offset to ls quad of numerator
        mov   rdx, -1                   ; Initialize index register
        mov   rcx, rbx                  ; Set counter to qsz
sgra2:  cmp   qword[rsi+rdx*8], 0       ; Test for zero
        jnz   sgra3                     ; Leave loop if non-zero

        sub   rdx, 1                    ; Decrement index
        sub   rcx, 1                    ; Decrement counter
        jnz   sgra2                     ; Loop

        mov   rax, 0                    ; Set signum to 0
        jmp   sgra4                     ; Branch to finish

sgra3:  mov   rax, 1                    ; Set signum to 1
sgra4:  sub   r14, 8                    ; Make room on stack
        mov   [r14], rax                ; Put signum on stack
        nextm
datam

; absra - Absolute value of rational number.

; : absra   sgnra 0< if negra then ;

head    "absra", hlfo
absra:  dq  docl0
        dq  sgnra,zless,izbrn,absra1
        dq  negra
absra1: dq  semis

; negra - Negate rational number

head    "negra"
negra:  dq  ngra0
textm
ngra0:  mov   rcx, [qdsz0]              ; Get qsz
        lea   rsi, [r14+rcx*8]          ; Offset to numerator

; Find trailing non-zero quad

ngra1:  cmp   qword[rsi+rcx*8-8], 0     ; Scan for non-zero quad
        jnz   ngra2
        sub   rcx, 1
        jnz   ngra1

; If loop falls through, number is zero. Do nothing

        jmp   ngra5

ngra2:  mov   rbx, rcx
ngra3:  not   qword[rsi+rcx*8-8]
        sub   rcx, 1
        jnz   ngra3
ngra4:  add   qword[rsi+rbx*8-8], 1
        jnc   ngra5
        sub   rbx, 1
        jnz   ngra4
ngra5:  nextm
datam

; reducera - Reduce multi-precision rational number to lowest terms.
; If the numerator is zero, change the denominator to one.
; It shouldn't be possible for the denominator to be zero.
; If the numerator is 1 or -1, or the denominator is 1, nothing needs
; to be done. Simply exit.
; Note that this program freezes if the denominator is mistakenly made
; negative.

; For the multi-precision version, should test for negative numerator first.
; Then the negated numerator can be tested for 1 at the same time as for 0.
; Since the denominator is being tested for 1, it might as well be tested
; for 0 also, although a zero denominator should not be possible.
; Register usage
;                 r13 - high order variable A
;                 r12 - high order variable B
;                 r11 - high order variable C
;                 r9  - high order variable D
;                 rdi - high order denominator
;                 rsi - high order numerator

head    "reducera", ario
redra:  dq  rdra0
textm
rdra0:  xor   rbp, rbp                  ; Clear flags register
        mov   r10, [qdsz0]              ; Get quadsize
        lea   rsi, [r14+r10*8]          ; Offset to high order numerator
        bt    qword[rsi], 63            ; Test sign of numerator
        jnc   rdra3                     ; Branch if positive
        bts   rbp, 0                    ; Set sign flag if negative
        mov   rcx, r10                  ; Set counter
rdra1:  not   qword[rsi+rcx*8-8]        ; Negate numerator
        sub   rcx, 1
        jnz   rdra1
        mov   rcx, r10
rdra2:  add   qword[rsi+rcx*8-8], 1
        jnc   rdra3
        sub   rcx, 1
        jnz   rdra2

; See if numerator is zero or one.

rdra3:  mov   rcx, r10                  ; Set counter
        xor   rdx, rdx                  ; Zero index register
rdra4:  cmp   qword[rsi+rdx*8], 0       ; Test first/next quad
        jnz   rdra5                     ; Leave loop if not zero
        add   rdx, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement counter
        jnz   rdra4                     ; Loop
        jmp   rdra50                    ; Zero if loop falls through

rdra5:  cmp   rcx, 1                    ; If counter not at last quad,
        jnz   rdra6                     ; continue,
        cmp   qword[rsi+rdx*8], 1       ; else see if equal to one
        jz    rdra46                    ; Test sign and exit if one

; See if denominator is one

rdra6:  mov   rcx, r10
        xor   rdx, rdx
rdra7:  cmp   qword[r14+rdx*8], 0       ; Test first/next quad
        jnz   rdra8
        add   rdx, 1                    ; Advance index
        sub   rcx, 1                    ; Decrement counter
        jnz   rdra7                     ; Loop
        jmp   rdra49                    ; Throw if loop falls through

rdra8:  cmp   rcx, 1                    ; If counter not at last quad,
        jnz   rdra9                     ; continue,
        cmp   qword[r14+rdx*8], 1       ; else see if equal to one
        jz    rdra46                    ; Test sign and exit if one

; Create rstack frame and initialize auxiliary variables

rdra9:  sub   r15, 24                   ; Create rstack frame
        mov   [r15], r13                ; Free up registers
        mov   [r15+8], r12
        mov   [r15+16], r11

        mov   rcx, r10                  ; Copy qsz
        shl   rcx, 3                    ; Convert to byte offset
        mov   r13, r15                  ; Copy stack pointer
        sub   r13, rcx                  ; Offset to high order variable A
        mov   r12, r13                  ; Make copy
        sub   r12, rcx                  ; Offset to high order variable B
        mov   r11, r12                  ; Make copy
        sub   r11, rcx                  ; Offset to high order variable C
        mov   r9, r11                   ; Make copy
        sub   r9, rcx                   ; Offset to high order variable D

        mov   rdi, r15                  ; Copy stack pointer
        mov   rcx, r10                  ; Copy qsz
rdra10: sub   r15, 8                    ; Clear stack space for auxiliary variables
        mov   qword[r15], 0
        sub   r15, 8
        mov   qword[r15], 0
        sub   r15, 8
        mov   qword[r15], 0
        sub   r15, 8
        mov   qword[r15], 0
        sub   rcx, 1
        jnz   rdra10

        sub   r15, 8
        mov   [r15], rdi                ; Save pointer to bottom of frame

        mov   qword[r13+r10*8-8], 1     ; Initialize A to 1
        mov   qword[r9+r10*8-8], 1      ; Initialize D to 1

        mov   rdi, r14                  ; Copy stack for high order denominator

; See if denominator and numerator are even

rdra11: bt    qword[rdi+r10*8-8], 0     ; See if Y is even
        jc    rdra16                    ; Branch if odd
        bt    qword[rsi+r10*8-8], 0     ; See if X is even
        jc    rdra21                    ; Branch if odd

; Divide Y by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    rdra13                    ; Only 1 quad to shift
rdra12: mov   rax, [rdi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rdi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   rdra12
rdra13: shr   qword[rdi+rbx*8], 1       ; Shift single quad

; Divide X by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    rdra15                    ; Only 1 quad to shift
rdra14: mov   rax, [rsi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rsi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   rdra14
rdra15: shr   qword[rsi+rbx*8], 1       ; Shift single quad

        jmp   rdra11                    ; Loop

; See if numerator is still even

rdra16: bt    qword[rsi+r10*8-8], 0     ; See if numerator is still even
        jc    rdra26                    ; Branch if odd

; Divide X by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    rdra18                    ; Only 1 quad to shift
rdra17: mov   rax, [rsi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rsi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   rdra17
rdra18: shr   qword[rsi+rbx*8], 1       ; Shift single quad

; Multiply A by 2

        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r10                  ; Copy qsz
        sub   rbx, 1                    ; One less for last shift
        jz    rdra20
rdra19: mov   rax, [r13+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r13+rdx*8], rax, 1
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   rdra19
rdra20: shl   qword[r13+rdx*8], 1       ; Shift single quad

        jmp   rdra16                    ; Loop

; See if denominator is still even

rdra21: bt    qword[rdi+r10*8-8], 0     ; See if denominator is still even
        jc    rdra26                    ; Branch if not

; Divide Y by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    rdra23                    ; Only 1 quad to shift
rdra22: mov   rax, [rdi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rdi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   rdra22
rdra23: shr   qword[rdi+rbx*8], 1       ; Shift single quad

; Multiply D by 2

        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r10                  ; Copy qsz
        sub   rbx, 1                    ; One less for last shift
        jz    rdra25
rdra24: mov   rax, [r9+rdx*8+8]         ; Shift q[n+1] into q[n]
        shld  [r9+rdx*8], rax, 1
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   rdra24
rdra25: shl   qword[r9+rdx*8], 1        ; Shift single quad

        jmp   rdra21                    ; Loop

; Compare X and Y

rdra26: xor   rdx, rdx                  ; Clear index register
        mov   rbx, r10                  ; Copy qsz
rdra27: mov   rax, [rdi+rdx*8]          ; Get first/next denominator quad
        cmp   rax, [rsi+rdx*8]          ; Compare numerator quad
        jnz   rdra28                    ; Leave loop if different
        add   rdx, 1                    ; Advance index
        sub   rbx, 1                    ; Decrement counter
        jnz   rdra27                    ; Loop for qsz
        jmp   rdra40                    ; Finished if Y = X

rdra28: jnc   rdra29                    ; Branch if Y > X

        xchg  rdi, rsi                  ; Else exchange Y and X
        xchg  r13, r11                  ; Exchange A and C
        xchg  r12, r9                   ; Exchange B and D

; Y = Y - X

rdra29: mov   rcx, r10                  ; Set index/count
        xor   rbx, rbx                  ; Zero borrow register
rdra30: mov   rax, [rsi+rcx*8-8]        ; Get first/next X quad
        sub   [rdi+rcx*8-8], rbx        ; Subtract borrow from Y
        setc  dl                        ; If borrow results,
        movzx rdx, dl                   ; set register
        sub   [rdi+rcx*8-8], rax        ; Subtract quad from Y
        setc  bl                        ; If borrow results,
        movzx rbx, bl                   ; set register
        or    rbx, rdx                  ; Set borrow for next quad
        sub   rcx, 1                    ; Decrement index/count
        jnz   rdra30                    ; Loop

; A = A + C

        mov   rcx, r10                  ; Copy quad counter
        xor   rbx, rbx                  ; Zero carry register
rdra31: mov   rax, [r11+rcx*8-8]        ; Get first/next C quad
        add   [r13+rcx*8-8], rbx        ; Add carry to A
        setc  dl                        ; If carry results,
        movzx rdx, dl                   ; set register
        add   [r13+rcx*8-8], rax        ; Add quad to A
        setc  bl                        ; If carry results,
        movzx rbx, bl                   ; set register
        or    rbx, rdx                  ; Set carry for next quad
        sub   rcx, 1                    ; Decrement counter
        jnz   rdra31                    ; Loop for quad count

; B = B + D

        mov   rcx, r10                  ; Copy quad counter
        xor   rbx, rbx                  ; Zero carry register
rdra32: mov   rax, [r9+rcx*8-8]         ; Get first/next D quad
        add   [r12+rcx*8-8], rbx        ; Add carry to B
        setc  dl                        ; If carry results,
        movzx rdx, dl                   ; set register
        add   [r12+rcx*8-8], rax        ; Add quad to B
        setc  bl                        ; If carry results,
        movzx rbx, bl                   ; set register
        or    rbx, rdx                  ; Set carry for next quad
        sub   rcx, 1                    ; Decrement counter
        jnz   rdra32                    ; Loop for quad count

; See if Y is now even

rdra33: bt    qword[rdi+r10*8-8], 0     ; See if Y is now even
        jc    rdra26                    ; Branch if odd

; Divide Y by 2

        mov   rbx, r10                  ; Initialize index/count
        sub   rbx, 1                    ; Count is one less than qsz
        jz    rdra35                    ; Only 1 quad to shift
rdra34: mov   rax, [rdi+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [rdi+rbx*8], rax, 1
        sub   rbx, 1                    ; Decrement index/count
        jnz   rdra34
rdra35: shr   qword[rdi+rbx*8], 1       ; Shift single quad


; Multiply C by 2

        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r10                  ; Copy qsz
        sub   rbx, 1                    ; One less for last shift
        jz    rdra37
rdra36: mov   rax, [r11+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r11+rdx*8], rax, 1
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   rdra36
rdra37: shl   qword[r11+rdx*8], 1       ; Shift single quad

; Multiply D by 2

        xor   rdx, rdx                  ; Clear index register
        mov   rbx, r10                  ; Copy qsz
        sub   rbx, 1                    ; One less for last shift
        jz    rdra39
rdra38: mov   rax, [r9+rdx*8+8]         ; Shift q[n+1] into q[n]
        shld  [r9+rdx*8], rax, 1
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   rdra38
rdra39: shl   qword[r9+rdx*8], 1        ; Shift single quad

        jmp   rdra33                    ; Loop

rdra40: cmp   rdi, r14                  ; See which register points to denominator
        jz    rdra41                    ; Branch if not changed
        xchg  rsi, rdi                  ; Else swap registers

; NUM = A + C

rdra41: mov   rcx, r10                  ; Copy quad counter
        xor   rbx, rbx                  ; Zero carry register
rdra42: mov   rax, [r11+rcx*8-8]        ; Get first/next C quad
        add   [r13+rcx*8-8], rbx        ; Add carry
        setc  dl                        ; If carry results,
        movzx rdx, dl                   ; set register
        add   [r13+rcx*8-8], rax        ; Add quad to A
        setc  bl                        ; If carry results,
        movzx rbx, bl                   ; set register
        or    rbx, rdx                  ; Set carry for next quad
        sub   rcx, 1                    ; Decrement counter
        jnz   rdra42                    ; Loop for quad count

; Install numerator on stack

        mov   rcx, r10
rdra43: mov   rax, [r13+rcx*8-8]
        mov   [rsi+rcx*8-8], rax
        sub   rcx, 1
        jnz   rdra43

; DEN = B + D

        mov   rcx, r10                  ; Copy quad counter
        xor   rbx, rbx                  ; Zero carry register
rdra44: mov   rax, [r9+rcx*8-8]         ; Get first/next D quad
        add   [r12+rcx*8-8], rbx        ; Add carry to B
        setc  dl                        ; If carry results,
        movzx rdx, dl                   ; set register
        add   [r12+rcx*8-8], rax        ; Add quad to B
        setc  bl                        ; If carry results,
        movzx rbx, bl                   ; set register
        or    rbx, rdx                  ; Set carry for next quad
        sub   rcx, 1                    ; Decrement counter
        jnz   rdra44                    ; Loop for quad count

; Install denominator on stack

        mov   rcx, r10
rdra45: mov   rax, [r12+rcx*8-8]
        mov   [rdi+rcx*8-8], rax
        sub   rcx, 1
        jnz   rdra45

; Pop auxiliary variables from return stack and restore registers

        mov   r15, [r15]
        mov   r11, [r15+16]             ; Restore registers
        mov   r12, [r15+8]
        mov   r13, [r15]
        add   r15, 24                   ; Pop stack

rdra46: btr   rbp, 0                    ; Test/clear sign flag
        jnc   rdra52                    ; Branch if flag was clear

; Negate numerator

        mov   rcx, r10                  ; Set counter
rdra47: not   qword[rsi+rcx*8-8]        ; Negate numerator
        sub   rcx, 1
        jnz   rdra47
        mov   rcx, r10
rdra48: add   qword[rsi+rcx*8-8], 1
        jnc   rdra52
        sub   rcx, 1
        jnz   rdra48
        jmp   rdra52

; If denominator is zero, throw

rdra49:throwm 30                        ; Throw

; If numerator is zero, set denominator to 1

rdra50: mov   rcx, r10                  ; Copy qsz
        mov   qword[r14+rcx*8-8], 1     ; Install 1 in low order quad
        sub   rcx, 1
        jz    rdra52
rdra51: mov   qword[r14+rcx*8-8], 0     ; Zero remaining quads
        sub   rcx, 1
        jnz   rdra51

rdra52: nextm
datam

; +ra - Sum of rational numbers

; : +ra   2 npick nover m*in 2n>a 3 npluck m*in 2nswap
;        m*in qsz*2 +i 2na> reducei qsz/2 ndrop nslip ;

head    "+ra", hlfo
plsra:  dq  docl0,two,npick,nover,msti,dntoa
        dq  three,nplck,msti,dnswap,msti,qstt
        dq  plsin,dnfma,redra,qsst,ndrop,nslip,semis

; -ra - Difference of rational numbers

; : -ra   2 npick nover m*in 2n>a 3 npluck m*in 2nswap
;        m*in qsz*2 -i 2na> reducei qsz/2 ndrop nslip ;

head    "-ra", hlfo
mnsra:  dq  docl0,two,npick,nover,msti,dntoa
        dq  three,nplck,msti,dnswap,msti,qstt
        dq  mnsin,dnfma,redra,qsst,ndrop,nslip,semis

; *ra - Product of rational numbers

; : *ra   nrot m*in 2nswap m*in 2nswap qsz*2 reducei qsz/2 ndrop nslip ;

head    "*ra", hlfo
strra:  dq  docl0,nrot,msti,dnswap,msti,dnswap
        dq  qstt,redra,qsst,ndrop,nslip,semis

; /ra - Quotient of rational numbers

; : /ra   nbrot m*in 2nswap m*in 2nswap qsz*2 reducei qsz/2 ndrop nslip ;

head    "/ra", hlfo
slsra:  dq  docl0,nbrot,msti,dnswap,msti,dnswap
        dq  qstt,redra,qsst,ndrop,nslip,semis

; 1/ra - Reciprocal of rational number

; : 1/ra   sgnra >a absra nswap a> 0< if negra then ;

head    "1/ra", hlfo
rcpra:  dq  docl0
        dq  sgnra,toa,absra,nswap
        dq  froma,zless,izbrn,rcpra1
        dq  negra
rcpra1: dq  semis

; uq>ra - Extend unsigned 64-bit stack entry to rational number in the current qsz

head    "uq>ra", nbco
uqtra:  dq  uqra0
textm
uqra0:  mov   r10, [qdsz0]              ; Get quadsize
        mov   rdx, r10                  ; Copy quadsize
        sub   rdx, 1                    ; Decrement count
        jnz   uqra1                     ; Branch if qsz not 1

        sub   r14, 8                    ; Push 1 for denominator
        mov   qword[r14], 1
        jmp   uqra3                     ; Exit

uqra1:  sub   r14, 8                    ; Fill remaining numerator quads with zero
        mov   qword[r14], 0
        sub   rdx, 1
        jnz   uqra1

        mov   rdx, r10                  ; Renew count
        sub   r14, 8                    ; Push 1 for denominator
        mov   qword[r14], 1
        sub   rdx, 1                    ; Decrement count

uqra2:  sub   r14, 8                    ; Fill remaining denominator quads with zero
        mov   qword[r14], 0
        sub   rdx, 1
        jnz   uqra2

uqra3:  nextm
datam

; sq>ra - Sign-extend a 64-bit value to rational number in the current qsz

head    "sq>ra", nbco
sqtra:  dq  sqra0
textm
sqra0:  mov   r10, [qdsz0]              ; Get quadsize
        mov   rdx, r10                  ; Copy quadsize
        sub   rdx, 1                    ; Decrement count
        jnz   sqra1                     ; Branch if qsz not 1

        sub   r14, 8                    ; Push 1 for denominator
        mov   qword[r14], 1
        jmp   sqra4                     ; Exit

sqra1:  bt    qword[r14], 63            ; Test sign of entry
        setc  bl                        ; Set to 0 if no carry, 1 if carry
        neg   bl                        ; Negate result
        movsx rbx, bl                   ; Sign-extend result

sqra2:  sub   r14, 8                    ; Sign-extend numerator to qsz
        mov   [r14], rbx
        sub   rdx, 1
        jnz   sqra2

        mov   rdx, r10                  ; Renew count
        sub   r14, 8                    ; Push 1 for denominator
        mov   qword[r14], 1
        sub   rdx, 1                    ; Decrement count

sqra3:  sub   r14, 8                    ; Fill remaining quads with zero
        mov   qword[r14], 0
        sub   rdx, 1
        jnz   sqra3

sqra4:  nextm
datam

; in>ra - Convert multi-precision integer to rational number.

; : in>ra  1 sq>in ;

head    "in>ra", hlfo
intra:  dq  docl0
        dq  one,sqtin,semis

; ra>re - Convert rational fraction to a real number.

; : ra>re   0 us>in nbrot in>2in qsz*2 /in qsz/2 ;

head    "ra>re", hlfo
ratre:  dq  docl0
        dq  zero,uqtin,nbrot,inttin,qstt,slshin,qsst,semis

; .ra - Output the rational number on top of the stack.

; : .ra   qsz@ 2* ckstk nob0 base @ ra>bsn bsn>ascii count strout space ;

head    ".ra", hlfo
dotra:  dq  docl0
        dq  qszat,tstar,ckstk
        dq  nobn,base,qat,rabsn
        dq  bsasc,count,strout,space,semis

; Multi-quad Floating-point Number Operators

; flliteral

head    "flliteral", -hlfo
fllite: dq  docl0
        dq  pcomp,fllit,dncom,semis
fllit:  dq  fllt0
textm
fllt0:  lea   rsi, [r12+8]              ; Get address of literal
        mov   rdx, [rsi-8]              ; Get quad size of literal
        lea   r12, [r12+rdx*8+8]        ; Offset IP past literal
        mov   r10, [qdsz0]              ; Get system quadsize
        mov   r9, r10                   ; Tentatively set shift count
        mov   rcx, r10                  ; Copy qsz
        shl   rcx, 1                    ; Double it
        neg   rcx                       ; Negate
        lea   r14, [r14+rcx*8]          ; Load new stack address
        neg   rcx                       ; Restore qsz*2
        mov   rdi, r14                  ; Set temporary stack pointer
        cmp   rdx, rcx                  ; Compare quadsizes
        jc    fllt6                     ; Branch if system qsz*2 is greater
        jnz   fllt1                     ; Branch if variable qsz*2 is greater
        jmp   fllt8                     ; Branch to move variable to stack

; Variable quadsize is greater than system quadsize. See if variable can be
; represented in the smaller quadsize. First calculate what the variable's shift
; count would be in the smaller quadsize from the formula:
; shift = bias - exp + 64*qsz - 65. Then find the maximum shift available from:
; 128*qsz-65. The number cannot be represented if there is not room to shift
; it, or if the shift count is negative.

fllt1:  mov   r8, [rsi]                 ; Get variable exponent
        btr   r8, 63                    ; Clear sign bit
        mov   rax, r10                  ; Get qsz
        shl   rax, 6                    ; Multiply by 64
        mov   rbx, 0x3FFFFFFFFFFFFFFF   ; Put exponent bias in register
        sub   rbx, r8                   ; bias - exp
        add   rbx, rax                  ; bias - exp + 64*qsz
        sub   rbx, 65                   ; bias - exp + 64*qsz - 65
        bt    rbx, 63                   ; See if result is negative
        jc    fllt2                     ; Throw error if so

; Find available shift bits.

        shl   rax, 1                    ; 128*qsz
        sub   rax, 65                   ; 128*qsz - 65
        cmp   rax, rbx
        jnc   fllt3                     ; Continue if not less

; Throw "number cannot be represented in current quadsize".

fllt2:  throwm 54                       ; Throw error

; Move variable to stack.

fllt3:  ssopm 2, shcnt, dmovm

; See if rounding needed.

fllt4:  bt    qword[rsi+rdx*8], 63      ; Test guard bit
        jnc   fllt9                     ; Exit if clear

        mov   rbx, [rsi+rdx*8]          ; Get rounding quad
        xor   rax, rax                  ; Clear register
        shld  rax, rbx, 2               ; Shift in G & R
        shl   rbx, 2                    ; Shift G & R out
        cmp   rbx, 0                    ; Test S - the sticky bit
        jnz   fllt5                     ; Round up if any bits are set
        bt    rax, 0                    ; Test R
        jc    fllt5                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    qword[rdi+rdx*8-8], 0     ; Test even bit
        jnc   fllt9                     ; Round down if even

; Round up. Carry will extend into exponent if necessary.

fllt5:  add   qword[rdi+rdx*8-8], 1     ; Add 1 to 1st/next stack quad
        jnc   fllt9                     ; Exit if no carry
        sub   rdx, 1
        jnz   fllt5                     ; Loop for quad count
        jmp   fllt9                     ; Finish

; System quadsize is larger than variable quadsize, zero low order quads.

fllt6:  lea   rdi, [rdi+rdx*8]          ; Adjust stack pointer to low order
        sub   rcx, rdx                  ; Find quadsize difference
        mov   r9, rcx                   ; Copy for shift count
        shr   r9, 1                     ; Set shift count

        ssopm 2, shcnt, dfilm

fllt7:  mov   rdi, r14                  ; Reset stack pointer
        mov   r9, rdx                   ; Copy for shift count
        shr   r9, 1                     ; Set shift count
        mov   rcx, rdx                  ; Use variable qsz for count

fllt8:  ssopm 2, shcnt, dmovm

fllt9:  nextm
datam

; flconstant

head    "flconstant", hlfo
flcon:  dq  docl0
        dq  qszat,tstar,ckstk
        dq  dfine,lit,flco,objcom,pcomm,flcn0
        dq  dncom,oszcom,semis
textm
flcn0:  lea   rsi, [r11+16]             ; Load address of constant
        mov   rdx, [rsi-8]              ; Get quad size of constant
        mov   r10, [qdsz0]              ; Get system quadsize
        mov   r9, r10                   ; Tentatively set shift count
        mov   rcx, r10                  ; Copy system quad size
        shl   rcx, 1                    ; Double it
        neg   rcx                       ; Negate
        lea   r14, [r14+rcx*8]          ; Load new stack address
        neg   rcx                       ; Restore qsz*2
        mov   rdi, r14                  ; Set temporary stack pointer
        cmp   rdx, rcx                  ; Compare quadsizes
        jc    flcn6                     ; Branch if system qsz*2 is greater
        jnz   flcn1                     ; Branch if variable qsz*2 is greater
        jmp   flcn7                     ; Branch to move variable to stack

; Variable quadsize is greater than system quadsize. See if variable can be
; represented in the smaller quadsize. First calculate what the variable's shift
; count would be in the smaller quadsize from the formula:
; shift = bias - exp + 64*qsz - 65. Then find the maximum shift available from:
; 128*qsz-65. The number cannot be represented if there is not room to shift
; it, or if the shift count is negative.

flcn1:  mov   r8, [rsi]                 ; Get variable exponent
        btr   r8, 63                    ; Clear sign bit
        mov   rax, r10                  ; Get qsz
        shl   rax, 6                    ; Multiply by 64
        mov   rbx, 0x3FFFFFFFFFFFFFFF   ; Put exponent bias in register
        sub   rbx, r8                   ; bias - exp
        add   rbx, rax                  ; bias - exp + 64*qsz
        sub   rbx, 65                   ; bias - exp + 64*qsz - 65
        bt    rbx, 63                   ; See if result is negative
        jc    flcn2                     ; Throw error if so

; Find available shift bits.

        shl   rax, 1                    ; 128*qsz
        sub   rax, 65                   ; 128*qsz - 65
        cmp   rax, rbx
        jnc   flcn3                     ; Continue if not less

; Throw "number cannot be represented in current quadsize".

flcn2:  throwm 54                       ; Throw error

; Move variable to stack.

flcn3:  ssopm 2, shcnt, dmovm

; See if rounding needed.

flcn4:  bt    qword[rsi+rdx*8], 63      ; Test guard bit
        jnc   flcn8                     ; Exit if clear

        mov   rbx, [rsi+rdx*8]          ; Get rounding quad
        xor   rax, rax                  ; Clear register
        shld  rax, rbx, 2               ; Shift in G & R
        shl   rbx, 2                    ; Shift G & R out
        cmp   rbx, 0                    ; Test S - the sticky bit
        jnz   flcn5                     ; Round up if any bits are set
        bt    rax, 0                    ; Test R
        jc    flcn5                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    qword[rdi+rdx*8-8], 0     ; Test even bit
        jnc   flcn8                     ; Round down if even

; Round up. Carry will extend into exponent if necessary.

flcn5:  add   qword[rdi+rdx*8-8], 1     ; Add 1 to 1st/next stack quad
        jnc   flcn8                     ; Exit if no carry
        sub   rdx, 1
        jnz   flcn5                     ; Loop for quad count
        jmp   flcn8                     ; Finish

; System quadsize is larger than variable quadsize, zero low order quads.

flcn6:  lea   rdi, [rdi+rdx*8]          ; Adjust stack pointer to low order
        sub   rcx, rdx                  ; Find quadsize difference
        mov   r9, rcx                   ; Copy for shift count
        shr   r9, 1                     ; Set shift count

        ssopm 2, shcnt, dfilm

        mov   rdi, r14                  ; Reset stack pointer
        mov   r9, rdx                   ; Copy for shift count
        shr   r9, 1                     ; Set shift count
        mov   rcx, rdx                  ; Use variable qsz for count

flcn7:  ssopm 2, shcnt, dmovm

flcn8:  nextm
datam

; flvariable

head    "flvariable", hlfo
flvar:  dq  docl0
        dq  dfine,lit,flvo,objcom,pcomm,nvar0
        dq  zero,uqre,dncom,oszcom,semis

; flarray - Create an array of floating-point numbers in double the current qsz.
; ( n --- ). Arrays are 1-based.
; Array structure (header not shown):

; | code field | number of elements | element size | elements ... |

head    "flarray", hlfo
flar:   dq  docl0
        dq  one,ckstk
        dq  dfine,lit,flao,objcom,pcomm,narr0
        dq  dupl,comma,qszat,tstar,dupl,comma,star,here
        dq  over,estar,allot,swp,zero,qfill,oszcom,semis

; fl@

head    "fl@", mqmo
flat:   dq  flat0
textm
flat0:  mov   rsi, [r14+8]              ; Get address of variable
        mov   rdx, [r14]                ; Get variable qsz
        mov   r10, [qdsz0]              ; Get system quadsize
        mov   r9, r10                   ; Tentatively set shift count
        mov   rcx, r10                  ; Copy system quad size
        shl   rcx, 1                    ; Double it
        neg   rcx                       ; Negate
        lea   r14, [r14+rcx*8+16]       ; Load new stack address
        neg   rcx                       ; Restore qsz*2
        mov   rdi, r14                  ; Set temporary stack pointer
        cmp   rdx, rcx                  ; Compare quadsizes
        jc    flat8                     ; Branch if system qsz*2 is greater
        jnz   flat1                     ; Branch if variable qsz*2 is greater
        jmp   flat9                     ; Branch to move variable to stack

; Variable quadsize is greater than system quadsize. See if variable can be
; represented in the smaller quadsize. First calculate what the variable's shift
; count would be in the smaller quadsize from the formula:
; shift = bias - exp + 64*qsz - 65.
; Then find the maximum shift available from:
; 128*qsz-65.
; The number cannot be represented if there is not room to shift it.
; If the shift count is negative, the maximum left-shift is 63 for any quadsize.

flat1:  mov   r8, [rsi]                 ; Get variable exponent
        btr   r8, 63                    ; Clear sign bit
        mov   rax, r10                  ; Get qsz
        shl   rax, 6                    ; Multiply by 64
        mov   rbx, 0x3FFFFFFFFFFFFFFF   ; Put exponent bias in register
        sub   rbx, r8                   ; bias - exp
        add   rbx, rax                  ; bias - exp + 64*qsz
        sub   rbx, 65                   ; bias - exp + 64*qsz - 65
        bt    rbx, 63                   ; See if result is negative
        jnc   flat2                     ; Branch if not

; If result is negative, it can't be less than -63.

        add   rbx, 63                   ; See if shift within bounds
        js    flat3                     ; Error if not
        jmp   flat4                     ; Else resume

; Find available shift bits.

flat2:  shl   rax, 1                    ; 128*qsz
        sub   rax, 65                   ; 128*qsz - 65
        cmp   rax, rbx
        jnc   flat4                     ; Continue if not less

; Throw "number cannot be represented in current quadsize".

flat3:  throwm 54                       ; Throw error

; Move variable to stack.

flat4:  mov   r8, rcx                   ; Save system qsz*2

        ssopm 2, shcnt, dmovm

; See if rounding needed.

flat5:  bt    qword[rsi+r8*8], 63       ; Test guard bit
        jnc   flat10                    ; Exit if clear

        mov   rbx, [rsi+r8*8]           ; Get rounding quad
        xor   rax, rax                  ; Clear register
        shld  rax, rbx, 2               ; Shift in G & R
        shl   rbx, 2                    ; Shift G & R out
        cmp   rbx, 0                    ; Test S - the sticky bit
        jnz   flat6                     ; Round up if any bits are set
        bt    rax, 0                    ; Test R
        jc    flat6                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    qword[rdi+r8*8-8], 0      ; Test even bit
        jnc   flat10                    ; Round down if even

; Round up. If carry extends into exponent, set the high order bit of the mantissa.

flat6:  sub   r8, 1                     ; Subtract 1 for exponent quad
flat7:  add   qword[rdi+r8*8-8], 1      ; Add 1 to 1st/next stack quad
        jnc   flat10                    ; Exit if no carry
        sub   r8, 1                     ; Decrement count
        jnz   flat7                     ; Loop for quad count

; If loop falls through, add 1 to exponent and set high order mantissa bit.

        add   qword[rdi], 1
        bts   qword[rdi+8], 63
        jmp   flat10                    ; Finish

; System quadsize is larger than variable quadsize, zero low order quads.

flat8:  lea   rdi, [rdi+rdx*8]          ; Adjust stack pointer to low order
        sub   rcx, rdx                  ; Find quadsize difference
        mov   r9, rcx                   ; Copy for shift count
        shr   r9, 1                     ; Set shift count

        ssopm 2, shcnt, dfilm

        mov   rdi, r14                  ; Reset stack pointer
        mov   r9, rdx                   ; Copy for shift count
        shr   r9, 1                     ; Set shift count
        mov   rcx, rdx                  ; Use variable qsz for count

flat9:  ssopm 2, shcnt, dmovm

flat10: nextm
datam

; fl!

head    "fl!", mqmo
flsto:  dq  flst0
textm
flst0:  mov   rdi, [r14+8]              ; Get address of variable
        mov   rdx, [r14]                ; Get quad size of variable
        mov   r10, [qdsz0]              ; Get system quadsize
        lea   rsi, [r14+16]             ; Load address of stack entry
        mov   rcx, r10                  ; Get system qsz
        shl   rcx, 1                    ; Double it
        lea   r14, [r14+rcx*8+16]       ; Pop the stack
        mov   r9, rdx                   ; Tentatively set shift count
        shr   r9, 1
        cmp   rdx, rcx                  ; Compare quadsizes
        jc    flst1                     ; Branch if system qsz*2 greater
        jnz   flst8                     ; Branch if variable qsz*2 greater
        jmp   flst10                    ; Branch to move stack entry to variable

; System quadsize is greater than variable quadsize. See if stack entry can be
; represented in the smaller quadsize. First calculate what the entry's shift
; count would be in the smaller quadsize from the formula:
; shift = bias - exp + 64*qsz - 65. Then find the maximum shift available from:
; 128*qsz-65.
; The number cannot be represented if there is not room to shift it.
; If the shift count is negative, the maximum left-shift is 63 for any quadsize.

flst1:  mov   r8, [rsi]                 ; Get exponent of stack entry
        btr   r8, 63                    ; Clear sign bit
        mov   rax, r9                   ; Get qsz
        shl   rax, 6                    ; Multiply by 64
        mov   rbx, 0x3FFFFFFFFFFFFFFF   ; Put exponent bias in register
        sub   rbx, r8                   ; bias - exp
        add   rbx, rax                  ; bias - exp + 64*qsz
        sub   rbx, 65                   ; bias - exp + 64*qsz - 65
        bt    rbx, 63                   ; See if result is negative
        jnc   flst2                     ; Branch if not

; If result is negative, it can't be less than -63.

        add   rbx, 63                   ; See if shift within bounds
        js    flst3                     ; Error if not
        jmp   flst4                     ; Else resume

; Find available shift bits.

flst2:  shl   rax, 1                    ; 128*qsz
        sub   rax, 65                   ; 128*qsz - 65
        cmp   rax, rbx
        jnc   flst4                     ; Continue if not less

; Throw "container is too small for stack entry".

flst3:  throwm 22                       ; Throw error

; Move stack entry to variable.

flst4:  mov   rcx, rdx                  ; Use variable qsz for count

        ssopm 2, shcnt, dmovm

; See if rounding needed.

flst5:  bt    qword[rsi+rdx*8], 63      ; Test guard bit
        jnc   flst11                    ; Exit if clear

        mov   rbx, [rsi+rdx*8]          ; Get rounding quad
        xor   rax, rax                  ; Clear register
        shld  rax, rbx, 2               ; Shift in G & R
        shl   rbx, 2                    ; Shift G & R out
        cmp   rbx, 0                    ; Test S - the sticky bit
        jnz   flst6                     ; Round up if any bits are set
        bt    rax, 0                    ; Test R
        jc    flst6                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    qword[rdi+rdx*8-8], 0     ; Test even bit
        jnc   flst11                    ; Round down if even

; Round up. If carry extends into exponent, set the high order bit of the mantissa.

flst6:  sub   rdx, 1                    ; Subtract 1 for exponent quad
flst7:  add   qword[rdi+rdx*8-8], 1     ; Add 1 to 1st/next variable quad
        jnc   flst11                    ; Exit if no carry
        sub   rdx, 1                    ; Decrement count
        jnz   flst7                     ; Loop for quad count

; If loop falls through, add 1 to exponent and set high order mantissa bit.

        add   qword[rdi], 1
        bts   qword[rdi+8], 63
        jmp   flst11                    ; Finish

; Variable quadsize is larger than twice system quadsize, zero low order quads.

flst8:  mov   rbp, rdi                  ; Save current base address
        mov   r8, rcx                   ; Save system qsz*2
        lea   rdi, [rdi+rcx*8]          ; Adjust base addr to low order
        sub   rdx, rcx                  ; Find quadsize difference
        mov   r9, rdx                   ; Copy for shift count
        shr   r9, 1                     ; Set shift count
        mov   rcx, rdx                  ; Set quad count

        ssopm 2, shcnt, dfilm

flst9:  mov   rdi, rbp                  ; Reset variable base address
        mov   rcx, r8                   ; Use system qsz*2 for quad count
        mov   r9, r8                    ; Copy for shift count
        shr   r9, 1                     ; Set shift count

flst10: ssopm 2, shcnt, dmovm

flst11: nextm
datam

; sgnfl - Return 1 if top floating-point number is positive, -1 if it is
; negative, or 0 if it is zero. It is assumed that if the leading quad
; of the significand is zero, the number is zero, and that there are no
; denormals. The operand is unaffected.

head    "sgnfl", ario
sgnfl:  dq  sgfl0
textm
sgfl0:  cmp   qword[r14+8], 0           ; See if high order significand is zero
        jnz   sgfl1                     ; Branch if not
        mov   rax, 0                    ; Set signum to 0
        jmp   sgfl3                     ; Branch to finish

sgfl1:  bt    qword[r14], 63            ; Test sign of entry
        jnc   sgfl2                     ; Branch if not negative

        mov   rax, -1                   ; Set signum to -1
        jmp   sgfl3                     ; Branch to finish

sgfl2:  mov   rax, 1                    ; Set signum to 1
sgfl3:  sub   r14, 8                    ; Push signum on stack
        mov   [r14], rax
        nextm
datam

; negfl - Negate floating-point number

head    "negfl"
negfl:  dq  ngfl0
textm
ngfl0:  btc   qword[r14], 63
        nextm
datam

; Floating-point Number Operators

; +fl - Sum of two floating-point numbers.

; : +fl   fl>re 2nswap fl>re +re re>fl ;

head    "+fl", hlfo
plsfl:  dq  docl0,fltre,dnswap,fltre,plsre,retfl,semis

; -fl - Difference of two floating-point numbers.

; : -fl   2nswap fl>re 2nswap fl>re -re re>fl ;

head    "-fl", hlfo
mnsfl:  dq  docl0,dnswap,fltre,dnswap,fltre,mnsre,retfl,semis

; *fl - Product of two floating-point numbers.

; : *fl   fl>re 2nswap fl>re *re re>fl ;

head    "*fl", hlfo
strfl:  dq  docl0,fltre,dnswap,fltre,strre,retfl,semis

; /fl - Quotient of two floating-point numbers.

; : /fl   2nswap fl>re 2nswap fl>re /re re>fl ;

head    "/fl", hlfo
slshfl: dq  docl0,dnswap,fltre,dnswap,fltre,slshre,retfl,semis

; 1/fl - Reciprocal of floating-point number.

; : 1/fl   fl>re 1/re re>fl ;

head    "1/fl", hlfo
rcpfl:  dq  docl0,fltre,invre,retfl,semis

; re>fl - Convert real number to Forthx64 format floating-point number using the
;      left-normalized real as the significand and adding a 64-bit exponent field
;      such that bit #63 is the sign bit and bits #0-62 are the exponent with a bias
;      of 4611686018427387903 or 0x3FFFFFFFFFFFFFFF.

head    "re>fl", nbco
retfl:  dq  refl0
textm
refl0:  xor   rbp, rbp                  ; Zero flags register
        mov   r10, [qdsz0]              ; Get quadsize
        shl   r10, 1                    ; Temporarily double qsz

        bt    qword[r14], 63            ; Test sign of real number
        jnc   refl3                     ; Branch if positive
        bts   rbp, 0                    ; Set sign flag if negative
        mov   rcx, r10                  ; Set counter
refl1:  not   qword[r14+rcx*8-8]        ; Negate stack entry
        sub   rcx, 1
        jnz   refl1
        mov   rcx, r10
refl2:  add   qword[r14+rcx*8-8], 1
        jnc   refl3
        sub   rcx, 1
        jnz   refl2

refl3:  xor   r8, r8                    ; Clear for leading zero-quad count
        mov   rcx, r10                  ; Set counter
refl4:  cmp   qword[r14+r8*8], 0        ; Find leading non-zero quad
        jnz   refl5                     ; Leave loop if non-zero
        add   r8, 1                     ; Increment count/index
        sub   rcx, 1                    ; Decrement quad count
        jnz   refl4                     ; Loop for 2*qsz

; If loop falls through, number is zero. Use high order quad for exponent.

        jmp   refl20                    ; Branch to exit

; Find trailing non-zero quad.

refl5:  xor   r9, r9                    ; Clear for trailing zero-quad count
        mov   rcx, r10                  ; Set counter
refl6:  cmp   qword[r14+rcx*8-8], 0     ; Find trailing non-zero quad
        jnz   refl7                     ; Leave loop if non-zero
        add   r9, 1                     ; Increment count
        sub   rcx, 1                    ; Decrement index
        jmp   refl6

; Find leading set bit and normalize number. Subtract number of trailing zero
; quads and number of leading zero quads from 2*qsz for number of quads
; to shift. Note that since we know the source of the bsr instruction is
; non-zero, we do not need to clear the destination register.

refl7:  mov   r11, r10                  ; Copy 2*qsz
        sub   r11, r8                   ; Subtract leading zero quads
        sub   r11, r9                   ; Subtract trailing zero quads

        mov   rcx, 63                   ; Set up for shift calculation
        bsr   rbx, [r14+r8*8]           ; Scan for leading set bit
        sub   rcx, rbx                  ; Find number of bits to shift
        jz    refl11                    ; Branch if no bits to shift

; Use leading zero count for index. Shift bits left.

        mov   rdx, r8                   ; Copy index
        mov   rbx, r11                  ; Copy total quad count
        sub   rbx, 1                    ; One less for last shift
        jz    refl10                    ; Only 1 quad to shift
refl9:  mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   refl9
refl10: shl   qword[r14+rdx*8], cl      ; Shift single quad

; Set up first part of exponent calculation {32*[(2*qsz)-2]-1}.

refl11: mov   rdx, r11                  ; Save total quad count
        mov   r11, r10                  ; Copy 2*qsz
        sub   r11, 2                    ; Subtract 2
        shl   r11, 5                    ; Multiply by 32
        sub   r11, 1                    ; Subtract 1

; Decrement the leading zero quad count to compensate for the exponent cell.
; If there was only one leading zero quad no further shifting is needed.
; If there were no leading zero quads, shift significand right one quad, clear
; leading zero quad count, and add back one quad worth of bits for shift
; calculation. Otherwise shift significand left.

        sub   r8, 1                     ; See if there were leading zero quads
        jz    refl19                    ; Branch if one lzq
        jnc   refl16                    ; Branch if more than one lzq

; If there is no leading non-zero quad, the number will have to be shifted
; one quad to the right to accommodate the exponent. First test if there were
; trailing zero quads. If so, no rounding will be needed.

        xor   r8, r8                    ; Clear negative lq count
        add   r11, 64                   ; Add back 64 bits
        cmp   r9, 0                     ; See if there were trailing zero quads
        jz    refl13                    ; Branch if not

; Shift significand right one quad. No rounding needed.

refl12: mov   rax, [r14+rdx*8-8]        ; Move quads right
        mov   [r14+rdx*8], rax
        sub   rdx, 1                    ; Decrement count/index
        jnz   refl12

        jmp   refl19                    ; Go process exponent

; Shift significand right one quad. Save low order quad for rounding.

refl13: sub   rdx, 1                    ; Shifting 2*qsz-1 quads
        mov   rbx, [r14+r10*8-8]        ; Save low order quad
refl14: mov   rax, [r14+rdx*8-8]        ; Move quads right
        mov   [r14+rdx*8], rax
        sub   rdx, 1                    ; Decrement count/index
        jnz   refl14

; For rounding purposes, test high order bit of the low order quad, and if it
; is set, add 1 to shifted significand, and propagate the carry as far as it
; will go. If the carry goes all the way past the highest order quad, set
; the high order bit to one, and increment the exponent. This will only happen
; with the highest order real number representable in the current quadsize,
; and the result will throw overflow on output

        bt    rbx, 63                   ; See if rounding needed
        jnc   refl19                    ; If not, go process exponent

        mov   rdx, r10                  ; Get qsz*2
        sub   rdx, 1                    ; One less for exponent
refl15: add   qword[r14+rdx*8], 1       ; Add 1 to low order
        jnc   refl19                    ; If no carry, go process exponent
        sub   rdx, 1                    ; Else decrement index and repeat
        jnz   refl15

; If loop falls through carry went past high order, set high order bit
; and increment exponent.

        bts   qword[r14+8], 63          ; Set high order bit of significand
        add   r11, 1                    ; Increment exponent
        jmp   refl19                    ; Go process exponent

; If there was more than one leading zero quad, shift quads left by one less
; than that number of quads.

refl16: mov   rbx, r10                  ; Copy number size
        sub   rbx, 1                    ; Subtract 1 quad for exponent
        sub   rbx, r8                   ; Subtract quad shift count
        xor   rdx, rdx                  ; Clear index register
        lea   rsi, [r14+r8*8+8]         ; Load addr of 1st non-zero quad
        lea   rdi, [r14+8]              ; Load addr of high order significand
refl17: mov   rax, [rsi+rdx*8]          ; Move significand left
        mov   [rdi+rdx*8], rax
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement counter
        jnz   refl17                    ; Loop for non-zero quad count

        mov   rbx, r8                   ; Set counter to zero-quad count
refl18: mov   qword[rdi+rdx*8], 0       ; Zero shifted quads
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement counter
        jnz   refl18

; Calculate exponent. The unbiased exponent is the bit count of one less than
; the system qsz minus 1 minus the total shift count. To this is added the bias
; according to the formula,
; exp = [64*(qsz-1)-1] - shift + bias
; But because the quadsize has been doubled, this becomes,
; exp = {32*[(2*qsz)-2]-1} - shift + bias
; The first part of the calculation has been done above.
; Calculate shift and subtract it.

        shl   r8, 6                     ; Quads shifted * 64

refl19: add   r8, rcx                   ; Add bits shifted
        sub   r11, r8                   ; Subtract total bits shifted

; Add exponent bias.

        mov   rcx, 0x3FFFFFFFFFFFFFFF   ; Put bias in register
        add   r11, rcx                  ; Add bias
        mov   [r14], r11                ; Put exponent on stack

        btr   rbp, 0                    ; Test/clear sign flag
        jnc   refl20                    ; Branch if flag was clear
        bts   qword[r14], 63            ; Else set floating-point sign bit

refl20: nextm
datam

; fl>re - Convert Forthx64 format floating-point number to positional number
; in the current quad size. Note: must clear sign flag before testing for zero
; exponent, but zero can be signed, so clear sign flag before exiting.

head    "fl>re", nbco
fltre:  dq  flre0
textm
flre0:  xor   rbp, rbp                  ; Zero flags register
        mov   rdx, [r14]                ; Get exponent
        mov   qword[r14], 0             ; Clear exponent cell
        btr   rdx, 63                   ; Test/clear sign bit
        jnc   flre1
        bts   rbp, 0                    ; Set sign flag

flre1:  cmp   rdx, 0                    ; Set if exponent is zero
        jnz   flre2                     ; Branch if not
        jmp   flre12                    ; Finish

; Total shift count is the exponent minus the bias plus the bit count of 1 less
; than the system qsz plus 1. According to the formula,
; shift = bias - exp + 64*qsz - 65

flre2:  mov   r10, [qdsz0]              ; Get quadsize
        mov   r9, r10                   ; Copy qsz
        shl   r9, 1                     ; Double it for real number
        sub   r9, 1                     ; Subtract 1 for exponent
        mov   rcx, 0x3FFFFFFFFFFFFFFF   ; Put exponent bias in register
        sub   rcx, rdx                  ; Subtract exponent
        sub   rcx, 65                   ; Subtract 65
        mov   rbx, r10                  ; Copy quad size
        shl   rbx, 6                    ; Multiply by 64
        add   rcx, rbx                  ; Add for total shift count
        bt    rcx, 63                   ; See if total shift count is negative
        jc    flre7                     ; Branch if so

        mov   r8, rcx                   ; Copy total shift count
        and   rcx, 63                   ; Extract bit shift count

        shr   r8, 6                     ; Convert total shift count to quads
        jz    flre5                     ; Branch if no quads to shift

        mov   rdx, r9                   ; Copy 2*qsz-1
        sub   rdx, r8                   ; Calculate number of quads to shift

        lea   rdi, [r14+r8*8]           ; Load destination base address
flre3:  mov   rax, [r14+rdx*8]
        mov   [rdi+rdx*8], rax          ; Shift quads right
        sub   rdx, 1
        jnz   flre3

flre4:  mov   qword[r14+r8*8], 0        ; Zero quads vacated by shift
        sub   r8, 1
        jnz   flre4

flre5:  test  rcx, rcx                  ; See if there are bits to shift
        jz    flre9                     ; Branch if not

        mov   rbx, r9                   ; Set count to 2*qsz-1
flre6:  mov   rax, [r14+rbx*8-8]        ; Shift q[n-1] into q[n]
        shrd  [r14+rbx*8], rax, cl
        sub   rbx, 1                    ; Decrement index/count
        jnz   flre6
        shr   qword[r14+rbx*8], cl      ; Shift single quad
        jmp   flre9

; If total shift count is negative, this means that the number occupies 2*qsz
; cells instead of 2*qsz-1 cells. There are no quads to shift and the resultant
; shift count should be negated and the number shifted to the left.
; Note that the count will be one less than 2*qsz for the final shift.

flre7:  neg   rcx                       ; Make shift count positive
        mov   rbx, r9                   ; Use 2*qsz-1 for counter
        xor   rdx, rdx                  ; Clear index register
flre8:  mov   rax, [r14+rdx*8+8]        ; Shift q[n+1] into q[n]
        shld  [r14+rdx*8], rax, cl
        add   rdx, 1                    ; Increment index
        sub   rbx, 1                    ; Decrement count
        jnz   flre8
        shl   qword[r14+rdx*8], cl      ; Shift single quad

; Test sign flag and negate if set

flre9:  btr   rbp, 0                    ; Test/clear sign flag
        jnc   flre12                    ; Finish if clear

        add   r9, 1                     ; Convert count to 2*qsz
        mov   rcx, r9                   ; Copy
flre10: not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   flre10
flre11: add   qword[r14+r9*8-8], 1
        jnc   flre12
        sub   r9, 1
        jnz   flre11

flre12: nextm
datam

; .fl - Output floating-point number on top of the stack.

; : .fl   qsz@ 2* ckstk nob0 base @ fl>bsn bsn>ascii count strout space ;

head    ".fl", hlfo
dotfl:  dq  docl0
        dq  qszat,tstar,ckstk
        dq  nobn,base,qat,flbsn
        dq  bsasc,count,strout,space,semis

; IEEE Floating-point Conversion Operators

; sq>sp - Convert a single-precision integer directly to IEEE single precision
; format. Throw error if number cannot be exactly represented.

head    "sq>sp", nbco
sqsp:   dq  sqsp0
textm
sqsp0:  mov   rbx, [r14]                ; Get operand
        cmp   rbx, 0                    ; See if negative or zero
        jnz   sqsp1                     ; Branch if not zero

        jmp   sqsp6                     ; Branch to leave zero on stack

sqsp1:  sets  bpl                       ; Set flag if negative
        jns   sqsp2                     ; Branch if positive

        neg   rbx                       ; Else negate

sqsp2:  bsr   rdx, rbx                  ; Scan for leading set bit
        cmp   rdx, 22                   ; See if exponent less than 23
        jc    sqsp3                     ; Branch if so

        bsf   r8, rbx                   ; Scan for trailing set bit
        mov   rax, rdx                  ; Copy lead bit location
        sub   rax, r8                   ; Subtract trailing bit location
        cmp   rax, 24                   ; See if representable
        jc    sqsp3                     ; Branch if so

        throwm 134

sqsp3:  mov   rcx, 31                   ; Calculate shift count
        sub   rcx, rdx
        js    sqsp4                     ; Branch if negative

        add   rcx, 1                    ; Add 1 for implied bit
        shl   ebx, cl                   ; Shift for mantissa
        jmp   sqsp5

sqsp4:  neg   rcx                       ; Negate shift count
        sub   rcx, 1                    ; Subtract 1 for implied bit
        jz    sqsp5                     ; No shift if result is zero

        shr   rbx, cl                   ; Shift right for mantissa

sqsp5:  add   rdx, 0x7F                 ; Add single precision bias
        shrd  ebx, edx, 9               ; Shift exponent into significand
        test  bpl, bpl                  ; See if negative
        jz    sqsp6                     ; Branch if not

        bts   rbx, 31                   ; Set sign bit

sqsp6:  mov   [r14], rbx                ; Put result on stack
        nextm
datam

; sq>dp - Convert a single-precision integer directly to IEEE double precision
; format. Throw error if number cannot be exactly represented.

head    "sq>dp", nbco
sqdp:   dq  sqdp0
textm
sqdp0:  mov   rbx, [r14]                ; Get operand
        cmp   rbx, 0                    ; See if negative or zero
        jnz   sqdp1                     ; Branch if not zero

        jmp   sqdp6                     ; Branch to put zero on stack

sqdp1:  sets  bpl                       ; Set flag if negative
        jns   sqdp2                     ; Branch if positive

        neg   rbx                       ; Else negate

sqdp2:  bsr   rdx, rbx                  ; Scan for leading set bit
        cmp   rdx, 51                   ; See if exponent less than 52
        jc    sqdp3                     ; Branch if so

        bsf   r8, rbx                   ; Scan for trailing set bit
        mov   rax, rdx                  ; Copy lead bit location
        sub   rax, r8                   ; Subtract trailing bit location
        cmp   rax, 53                   ; See if representable
        jc    sqdp3                     ; Branch if so

        throwm 134

sqdp3:  mov   rcx, 63                   ; Calculate shift count
        sub   rcx, rdx
        js    sqdp4

        add   rcx, 1                    ; Add 1 for implied bit
        shl   rbx, cl                   ; Shift for mantissa
        jmp   sqdp5

sqdp4:  neg   rcx                       ; Negate shift count
        sub   rcx, 1                    ; Subtract 1 for implied bit
        jz    sqdp5                     ; No shift if result is zero

        shr   rbx, cl                   ; Shift right for mantissa

sqdp5:  add   rdx, 0x3FF                ; Add double precision bias
        shrd  rbx, rdx, 12              ; Shift exponent into significand
        test  bpl, bpl                  ; See if negative
        jz    sqdp6                     ; Branch if not

        bts   rbx, 63                   ; Set sign bit

sqdp6:  mov   [r14], rbx                ; Put result on stack
        nextm
datam

; sq>xp - Convert a 64-bit integer to an IEEE extended format
; floating-point number.

head    "sq>xp", nbco
sqxp:   dq  sqxp0
textm
sqxp0:  mov   rbx, [r14]                ; Get integer
        cmp   rbx, 0                    ; See if negative or zero
        jnz   sqxp1                     ; Branch if not zero

        xor   rdx, rdx                  ; Put quad-precision zero on stack
        jmp   sqxp3                     ; Branch to exit

sqxp1:  sets  bpl                       ; Set flag if negative
        jns   sqxp2                     ; Branch if positive

        neg   rbx                       ; Else negate

sqxp2:  bsr   rdx, rbx                  ; Scan for leading set bit
        mov   rcx, rdx                  ; Copy bit number
        sub   rcx, 63                   ; Convert to shift count
        neg   rcx
        shl   rbx, cl                   ; Normalize mantissa
        add   rdx, 0x3FFF               ; Add exponent bias to bit count
        test  bpl, bpl                  ; See if negative
        jz    sqxp3                     ; Branch if not

        bts   rdx, 15                   ; Set sign bit

sqxp3:  mov   [r14], rdx                ; Put exponent on stack
        sub   r14, 8                    ; Push mantissa to stack
        mov   [r14], rbx
        nextm
datam

; sq>qp - Convert a single-precision integer directly to IEEE quad precision
; format.

head    "sq>qp", nbco
sqqp:   dq  sqqp0
textm
sqqp0:  xor   rax, rax                  ; Clear for low order result
        mov   rbx, [r14]                ; Get integer
        cmp   rbx, 0                    ; See if negative or zero
        jnz   sqqp1                     ; Branch if not zero

        mov   [r14], rax                ; Put quad-precision zero on stack
        jmp   sqqp6                     ; Branch to exit

sqqp1:  sets  bpl                       ; Set flag if negative
        jns   sqqp2                     ; Branch if positive

        neg   rbx                       ; Else negate

sqqp2:  bsr   rdx, rbx                  ; Scan for leading set bit
        cmp   rdx, 47                   ; See if exponent less than 48
        jnc   sqqp3                     ; Branch if not

        mov   rcx, 48                   ; Calculate shift value
        sub   rcx, rdx
        shl   rbx, cl                   ; Shift for mantissa

        jmp   sqqp4                     ; Branch to deal with exponent

sqqp3:  mov   rcx, rdx                  ; Calculate shift value
        sub   rcx, 48
        shrd  rax, rbx, cl              ; Shift for mantissa
        shr   rbx, cl

sqqp4:  mov   [r14], rbx                ; Put high order result on stack
        add   rdx, 0x3FFF               ; Add exponent bias
        test  bpl, bpl                  ; See if negative
        jz    sqqp5                     ; Branch if not

        bts   rdx, 15                   ; Set sign bit

sqqp5:  mov   [r14+6], dx               ; Install exponent
sqqp6:  sub   r14, 8
        mov   [r14], rax                ; Put low order result on stack
        nextm
datam

; re>sp - Convert real number directly to IEEE single precision format.
; Throw 54 if exponent is out of range, -126 > exp > 127.

head    "re>sp", nbco
retsp:  dq  resp0
textm
resp0:  lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to quads
        mov   r9, [qdsz0]               ; Get qsz
        shl   r9, 1                     ; Double for real data
        cmp   rdi, r9                   ; Compare items needed
        jnc   resp1

        throwm 69

resp1:  xor   rbp, rbp                  ; Zero flags register
        bt    qword[r14], 63            ; Test sign of real number
        jnc   resp4                     ; Branch if positive

; Negate if negative

        bts   rbp, 0                    ; Set sign flag if negative
        mov   rcx, r9                   ; Set counter
resp2:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   resp2
        mov   rcx, r9                   ; Reset counter
resp3:  add   qword[r14+rcx*8-8], 1
        jnc   resp4
        sub   rcx, 1
        jnz   resp3

; Locate lead quad

resp4:  mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+r9*8-8]         ; Leave one cell on stack
        xor   rdx, rdx                  ; Clear index register
        mov   rcx, r9                   ; Copy double qsz
resp5:  cmp   qword[rsi+rdx*8], 0       ; Test for zero
        jnz   resp6                     ; If non-zero, leave loop
        add   rdx, 1                    ; Increment index register
        sub   rcx, 1                    ; Decrement count
        jnz   resp5

; If loop falls through, number is zero. Push floating-point zero.

        mov   rbx, 0                    ; Return zero
        jmp   resp15                    ; Branch to end

; Shift significand

resp6:  mov   rax, [rsi+rdx*8]          ; Get first non-zero quad
        bsr   rcx, rax                  ; Scan for leading set bit
        sub   rcx, 63
        neg   rcx
        jnc   resp8                     ; Branch if no bits to shift

        lea   r8, [r9-1]                ; Copy 2*qsz-1
        sub   r8, rdx                   ; Subtract lead quad location
        jnz   resp7                     ; Branch if not zero

        shl   rax, cl                   ; Shift significand
        jmp   resp8                     ; Branch to handle exponent

resp7:  mov   rbx, [rsi+rdx*8+8]        ; Get next quad
        shld  rax, rbx, cl              ; Shift into high order

resp8:  shl   rax, 1                    ; Shift out implied bit

; Calculate the exponent as the lead quad count in bits plus the number of bits
; shifted plus 1 subtracted from the quadsize in bits.
; In order to trap overflow on conversion, a flag is set if the lead quad
; count is zero and the shift count is one.

        shl   rdx, 6                    ; Convert lead-quad count to bit count
        add   rdx, rcx                  ; Add bits shifted
        cmp   rdx, 1                    ; See if only 1
        jnz   resp9

        bts   rbp, 1                    ; Set flag to trap overflow

resp9:  mov   rbx, r9                   ; Copy qsz*2
        shl   rbx, 5                    ; Convert qsz to bit count
        sub   rbx, 1                    ; Subtract 1
        sub   rbx, rdx                  ; Subtract total bits shifted

; See if rounding needed.

        mov   rdx, rax                  ; Copy significand
        mov   r8, 0x1FFFFFFFFFF         ; Move mask to register
        and   rdx, r8                   ; Test for bits to the right
        jz    resp11                    ; Branch if no rounding needed

; Since the significand will be shifted 23 bits after the implied bit is
; shifted out, the 40th bit is the guard bit.

        bt    rax, 40                   ; Test guard bit, G
        jnc   resp11                    ; Round down if not set

; Apply the GRS rounding algorithm.

        mov   rdx, rax                  ; Copy significand
        mov   r8, 0x7FFFFFFFFF          ; Move mask to register
        and   rdx, r8                   ; Find sticky bit
        jnz   resp10                    ; Round up if any bits are set

        bt    rax, 39                   ; Test R
        jc    resp10                    ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rax, 41                   ; Test even bit
        jnc   resp11                    ; Round down if clear

resp10: mov   r8, 2199023255552         ; Move addend to register
        add   rax, r8                   ; Add 1 at 41st bit position
        jnc   resp11                    ; Branch if no carry

        btr   rbp, 1                    ; Test overflow flag
        jc    resp13                    ; Throw error if set

        add   rbx, 1                    ; Add 1 to exponent

resp11: mov   rdx, rbx                  ; Copy exponent
        bt    rdx, 63                   ; See if exponent is negative
        jnc   resp12                    ; Branch if not

        neg   rdx                       ; Else negate copy
        cmp   rdx, 0x7F                 ; See if exponent is within range
        jc    resp14                    ; Branch if so

        jmp   resp13

resp12: cmp   rdx, 0x80                 ; See if exponent is within range
        jc    resp14                    ; Branch if so

resp13: throwm 52                       ; Throw error

resp14: add   rbx, 0x7F                 ; Add exponent bias
        shld  rbx, rax, 23              ; Shift exponent into significand
        btr   rbp, 0                    ; Test/clear sign flag
        jnc   resp15                    ; Branch if clear

        bts   rbx, 31                   ; Set sign bit

resp15: mov   [r14], rbx                ; Push single precision fp number
        nextm
datam

; sp>re - Convert IEEE single precision number directly to real number

head    "sp>re", nbco
sptre:  dq  spre0
textm
spre0:  mov   rdx, [r14]                ; Get single precision number
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get qsz
        mov   r9, r10                   ; Copy qsz
        shl   r9, 1                     ; Double for positional data
        mov   rcx, r9                   ; Set counter
spre1:  sub   r14, 8                    ; Decrement stack pointer
        mov   qword[r14], 0             ; Clear stack space for real number
        sub   rcx, 1
        jnz   spre1

        cmp   rdx, 0                    ; See if number is zero
        jz    spre9                     ; Exit if so

        btr   rdx, 31                   ; Test sign bit

        setc  bpl                       ; Set register accordingly

        xor   rax, rax                  ; Zero significand register
        mov   rcx, 23                   ; Set shift count
        shrd  rax, rdx, cl              ; Shift significand into register
        shr   rdx, cl                   ; Isolate exponent
        cmp   rdx, 0                    ; See if exponent is zero
        jz    spre6                     ; Finish if zero

        mov   rbx, r10                  ; Copy quadsize
        shl   rbx, 6                    ; Convert to bit count
        mov   r8, rbx                   ; Save copy
        sub   rdx, 0x7F                 ; Subtract exponent bias
        jns   spre2                     ; Branch if positive

        mov   rcx, rdx                  ; Copy exponent
        neg   rcx                       ; Negate copy

; If it is desirable to check for the least significant bit, here is the place.

        add   rcx, 24                   ; Add mantissa length
        cmp   rbx, rcx                  ; See if mantissa will fit
        jnc   spre4                     ; Branch if so

        jmp   spre3                     ; Else branch to throw error

spre2:  sub   rbx, 1                    ; Subtract 1 for sign bit
        cmp   rbx, rdx                  ; See if mantissa will fit
        jnc   spre4                     ; Branch if so

; Throw error if number cannot be accommodated.

spre3:  throwm 54

spre4:  shr   rax, 1                    ; Make room for implied bit
        bts   rax, 63                   ; Set implied bit
        sub   r8, rdx                   ; Subtract exponent from cell bitsize 
        sub   r8, 1                     ; Subtract 1
        xor   rbx, rbx                  ; Zero low order register
        mov   rcx, r8                   ; Copy total shift count
        shr   r8, 6                     ; Convert total shift count to quads
        and   rcx, 63                   ; Extract bit shift count
        jz    spre5                     ; Branch if no bits to shift

        shrd  rbx, rax, cl              ; Shift high order into low order
        shr   rax, cl                   ; Shift high order
        cmp   rbx, 0                    ; Test if low order is zero
        jz    spre5

        mov   [r14+r8*8+8], rbx         ; Install low order result

spre5:  mov   [r14+r8*8], rax           ; Install high order result
        test  bpl, bpl                  ; Test sign flag
        jz    spre9                     ; Finish if clear

        cmp   rbx, 0
        jz    spre6

        add   r8, 1                     ; Add for significand quad

spre6:  add   r8, 1                     ; Add for significand quad
        mov   rcx, r8                   ; Set counter
spre7:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   spre7
spre8:  add   qword[r14+r8*8-8], 1
        jnc   spre9
        sub   r8, 1
        jnz   spre8

spre9:  nextm
datam

; spexp - Get exponent of IEEE single precision number.

head    "spexp", nbco
spexp:  dq  spxp0
textm
spxp0:  mov   rax, [r14]                ; Get single precision number
        btr   rax, 31                   ; Clear sign bit
        xor   rbx, rbx                  ; Clear shift register
        shld  ebx, eax, 9               ; Shift exponent into significand
        sub   rbx, 0x7F                 ; Subtract exponent bias
        mov   [r14], rbx                ; Put result on stack
        nextm
datam

; re>dp - Convert real number directly to IEEE double precision format.
; Throw 54 if exponent is out of range, -1022 > exp > 1023.

head    "re>dp", nbco
retdp:  dq  redp0
textm
redp0:  lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to quads
        mov   r9, [qdsz0]               ; Get qsz
        shl   r9, 1                     ; Double for real data
        cmp   rdi, r9                   ; Compare items needed
        jnc   redp1

        throwm 69

redp1:  xor   rbp, rbp                  ; Zero flags register
        bt    qword[r14], 63            ; Test sign of real number
        jnc   redp4                     ; Branch if positive

; Negate if negative

        bts   rbp, 0                    ; Set sign flag if negative
        mov   rcx, r9                   ; Set counter
redp2:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   redp2
        mov   rcx, r9                   ; Reset counter
redp3:  add   qword[r14+rcx*8-8], 1
        jnc   redp4
        sub   rcx, 1
        jnz   redp3

; Locate lead quad

redp4:  mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+r9*8-8]         ; Leave one cell on stack
        xor   rdx, rdx                  ; Zero index register
        mov   rcx, r9                   ; Copy double qsz
redp5:  cmp   qword[rsi+rdx*8], 0       ; Test for zero
        jnz   redp6                     ; If non-zero, leave loop
        add   rdx, 1                    ; Increment index register
        sub   rcx, 1                    ; Decrement count
        jnz   redp5

; If loop falls through, number is zero. Push floating-point zero.

        mov   rax, 0                    ; Return zero
        jmp   redp15                    ; Branch to end

; Shift significand

redp6:  mov   rax, [rsi+rdx*8]          ; Get first non-zero quad
        bsr   rcx, rax                  ; Scan for leading set bit
        sub   rcx, 63
        neg   rcx
        jnc   redp8                     ; Branch if no bits to shift

        lea   r8, [r9-1]                ; Copy 2*qsz-1
        sub   r8, rdx                   ; Subtract lead quad location
        jnz   redp7                     ; Branch if not zero

        shl   rax, cl                   ; Shift significand
        jmp   redp8                     ; Branch to handle exponent

redp7:  mov   rbx, [rsi+rdx*8+8]        ; Get next quad
        shld  rax, rbx, cl              ; Shift into high order significand

redp8:  shl   rax, 1                    ; Shift out implied bit

; Calculate the exponent as the lead quad count in bits plus the number of bits
; shifted plus 1 subtracted from the quadsize in bits.
; In order to trap overflow on conversion, a flag is set if the lead quad
; count is zero and the shift count is one.

        shl   rdx, 6                    ; Convert lead-quad count to bit count
        add   rdx, rcx                  ; Add bits shifted
        cmp   rdx, 1                    ; See if only 1
        jnz   redp9

        bts   rbp, 1                    ; Set flag to trap overflow

; One is added to the total shift count to convert to exponent.

redp9:  add   rdx, 1
        mov   rbx, r9                   ; Copy qsz*2
        shl   rbx, 5                    ; Convert qsz to bit count
        sub   rbx, rdx                  ; Subtract total bits shifted + 1

; See if rounding needed.

        mov   rdx, rax                  ; Copy significand
        and   rdx, 0x7FF                ; Test for bits to the right
        jz    redp11                    ; Branch if no rounding needed

; Since the significand will be 52 bits after the implied bit is
; shifted out, the 11th bit is the guard bit.

        bt    rax, 11                   ; Test guard bit, G
        jnc   redp11                    ; Round down if not set

; Apply the GRS rounding algorithm.

        mov   rdx, rax                  ; Copy significand
        and   rdx, 0x3FF                ; Find sticky bit
        jnz   redp10                    ; Round up if any bits are set

        bt    rax, 10                   ; Test R
        jc    redp10                    ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rax, 12                   ; Test even bit
        jnc   redp11                    ; Round down if clear

redp10: add   rax, 4096                 ; Add 1 at 12th bit position
        jnc   redp11

        btr   rbp, 1                    ; Test/clear overflow flag
        jc    redp13                    ; Throw error if set

        add   rbx, 1                    ; Increment exponent

redp11: mov   rdx, rbx                  ; Copy exponent
        bt    rdx, 63                   ; See if exponent is negative
        jnc   redp12                    ; Branch if not

        neg   rdx                       ; Else negate copy
        cmp   rdx, 0x3FF                ; See if exponent is within range
        jc    redp14                    ; Branch if so

        jmp   redp13                    ; Else branch to throw error

redp12: cmp   rdx, 0x400                ; See if exponent is within range
        jc    redp14                    ; Branch if so

redp13: throwm 52                       ; Throw error

redp14: add   rbx, 0x3FF                ; Add double precision bias
        shrd  rax, rbx, 12              ; Shift exponent into significand
        btr   rbp, 0                    ; Test/clear sign flag
        jnc   redp15                    ; Branch if clear

        bts   rax, 63                   ; Set sign bit

redp15: mov   [r14], rax                ; Put result on stack
        nextm
datam

; dp>re - Convert IEEE double precision number directly to real number.
; Number will be called unrepresentable if not all bits can fit in a double
; quadsize cell. No rounding will be done.

head    "dp>re", nbco
dptre:  dq  dpre0
textm
dpre0:  mov   rax, [r14]                ; Get double precision number
        add   r14, 8                    ; Pop stack
        mov   r10, [qdsz0]              ; Get quadsize
        mov   r9, r10                   ; Copy qsz
        shl   r9, 1                     ; Double for positional data
        mov   rcx, r9                   ; Set counter
dpre1:  sub   r14, 8                    ; Decrement stack pointer
        mov   qword[r14], 0             ; Clear stack space for real number
        sub   rcx, 1
        jnz   dpre1

        btr   rax, 63                   ; Test/clear sign bit

        setc  bpl                       ; Set register accordingly

; Note here that the shld instruction sets the zero flag if the result
; of the shift is zero. So it's not necessary to explicit test rdx.

        xor   rdx, rdx                  ; Clear exponent register
        shld  rdx, rax, 12              ; Shift in exponent
        jz    dpre9                     ; Finish if exponent is zero

        shl   r9, 5                     ; Convert quadsize to bitsize
        mov   r8, r9                    ; Save copy
        sub   rdx, 0x3FF                ; Subtract exponent bias
        jns   dpre2                     ; Branch if positive

        mov   rcx, rdx                  ; Copy exponent
        neg   rcx                       ; Negate copy

; If it is desirable to check for the least significant bit, here is the place.

        add   rcx, 53                   ; Add mantissa length
        cmp   r9, rcx                   ; See if mantissa will fit
        jnc   dpre4                     ; Branch if so

        jmp   dpre3                     ; Else branch to throw error

dpre2:  sub   r9, 1                     ; Subtract 1 for sign bit
        cmp   r9, rdx                   ; See if mantissa will fit
        jnc   dpre4                     ; Branch if so

; Throw error if number cannot be accommodated.

dpre3: throwm 54

dpre4:  shl   rax, 11                   ; Shift significand
        bts   rax, 63                   ; Set implied bit
        sub   r8, rdx                   ; Subtract exponent from cell bitsize 
        sub   r8, 1                     ; Subtract 1
        xor   rbx, rbx                  ; Zero low order register
        mov   rcx, r8                   ; Copy total shift count
        shr   r8, 6                     ; Convert total shift count to quads
        and   rcx, 63                   ; Extract bit shift count
        jz    dpre5                     ; Branch if no bits to shift

        shrd  rbx, rax, cl              ; Shift high order into low order
        shr   rax, cl                   ; Shift high order
        cmp   rbx, 0                    ; Test if low order is zero
        jz    dpre5

        mov   [r14+r8*8+8], rbx         ; Install low order result

dpre5:  mov   [r14+r8*8], rax           ; Install high order result
        test  bpl, bpl                  ; Test sign flag
        jz    dpre9                     ; Finish if clear

        cmp   rbx, 0                    ; See if low order is zero
        jz    dpre6                     ; Skip adding quad if zero

        add   r8, 1                     ; Add for low order quad

dpre6:  add   r8, 1                     ; Add for high order quad
        mov   rcx, r8                   ; Set counter
dpre7:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   dpre7
dpre8:  add   qword[r14+r8*8-8], 1
        jnc   dpre9
        sub   r8, 1
        jnz   dpre8

dpre9:  nextm
datam

; dpexp - Get exponent of IEEE double precision number.

head    "dpexp", nbco
dpexp:  dq  dpxp0
textm
dpxp0:  mov   rax, [r14]                ; Get double precision number
        btr   rax, 63                   ; Clear sign bit
        xor   rbx, rbx                  ; Clear shift register
        shld  rbx, rax, 12              ; Shift out exponent
        sub   rbx, 0x3FF                ; Subtract exponent bias
        mov   [r14], rbx                ; Put result on stack
        nextm
datam

; re>xp - Convert real number directly to IEEE extended precision format.
; Throw 54 if exponent is out of range, -16382 > exp > 16383.

head    "re>xp", nbco
retxp:  dq  rexp0
textm
rexp0:  lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to quads
        mov   r9, [qdsz0]               ; Get qsz
        shl   r9, 1                     ; Double for real data
        cmp   rdi, r9                   ; Compare items needed
        jnc   rexp1

        throwm 69
        
rexp1:  xor   rbp, rbp                  ; Zero flags register
        xor   rax, rax                  ; Zero significand registers
        xor   rbx, rbx
        bt    qword[r14], 63            ; Test sign of real number
        jnc   rexp4                     ; Branch if positive

; Negate if negative

        bts   rbp, 0                    ; Set sign flag if negative
        mov   rcx, r9                   ; Set counter
rexp2:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   rexp2
        mov   rcx, r9                   ; Reset counter
rexp3:  add   qword[r14+rcx*8-8], 1
        jnc   rexp4
        sub   rcx, 1
        jnz   rexp3

; Locate lead quad

rexp4:  mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+r9*8-16]        ; Leave two cells on stack
        xor   rdx, rdx                  ; Zero index register
        mov   rcx, r9                   ; Copy double qsz
rexp5:  cmp   qword[rsi+rdx*8], 0       ; Test for zero
        jnz   rexp6                     ; If non-zero, leave loop
        add   rdx, 1                    ; Increment index register
        sub   rcx, 1                    ; Decrement count
        jnz   rexp5

; If loop falls through, number is zero. Put zero in stack quads.

        xor   r9, r9                    ; Zero exponent register
        jmp   rexp15                    ; Branch to end

; Find shift count.
; Note that rcx is not cleared for bsr because we already know that rax
; is not zero. Otherwise the contents of rcx would not be changed.

rexp6:  mov   rax, [rsi+rdx*8]          ; Get first non-zero quad
        bsr   rcx, rax                  ; Scan for leading set bit
        sub   rcx, 63                   ; Calculate shift count
        neg   rcx
        jnc   rexp8                     ; Branch if no bits to shift

; Shift significand.

        lea   r8, [r9-1]                ; Copy 2*qsz-1
        cmp   r8, rdx                   ; Compare lead quad location
        jnz   rexp7                     ; Branch if not zero

        shl   rax, cl                   ; Shift high order significand
        jmp   rexp8                     ; Branch to handle exponent

rexp7:  mov   rbx, [rsi+rdx*8+8]        ; Get next quad
        shld  rax, rbx, cl              ; Shift into high order significand
        shl   rbx, cl                   ; Shift low order significand

; Calculate the exponent as the lead quad count in bits plus the number of bits
; shifted plus 1 subtracted from the quadsize in bits.
; In order to trap overflow on conversion, a flag is set if the lead quad
; count is zero and the shift count is one.

rexp8:  shl   rdx, 6                    ; Convert lead-quad count to bit count
        add   rdx, rcx                  ; Add bits shifted
        cmp   rdx, 1                    ; See if only 1 bit
        jnz   rexp9

        bts   rbp, 1                    ; Set overflow flag

rexp9:  add   rdx, 1                    ; Convert lead bit count to exponent 
        shl   r9, 5                     ; Convert qsz to bit count
        sub   r9, rdx                   ; Subtract total bits shifted

; See if rounding needed.

        cmp   rbx, 0                    ; Round down if zero
        jz    rexp11

; Apply the GRS round-to-even algorithm. First test the guard bit, G, and do
; nothing if it is zero.

        bt    rbx, 63                   ; Test G
        jnc   rexp11                    ; Round down if not set

        xor   r8, r8                    ; Clear register
        shld  r8, rbx, 2                ; Shift in G & R
        shl   rbx, 2                    ; Shift G & R out
        cmp   rbx, 0                    ; Test S - the sticky bit
        jnz   rexp10                    ; Round up if any bits are set

        bt    r8, 0                     ; Test R
        jc    rexp10                    ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rax, 0                    ; Test even bit
        jnc   rexp11                    ; Round down if even

; Round up. If adding 1 to the significand results in a carry,
; increment exponent

rexp10: add   rax, 1                    ; Add 1 to significand
        jnc   rexp11                    ; Branch if no carry

        btr   rbp, 1                    ; Test/clear overflow flag
        jc    rexp13                    ; Throw error if set

        add   r9, 1                     ; Increment exponent

rexp11: mov   rbx, r9                   ; Copy exponent
        bt    rbx, 63                   ; See if exponent is positive
        jnc   rexp12                    ; Branch if so

        neg   rbx                       ; Else negate copy of exponent
        cmp   rbx, 0x3FFF               ; See if exponent is within range
        jc    rexp14                    ; Branch if so

        jmp   rexp13                    ; Else throw error

rexp12: cmp   rbx, 0x4000               ; See if exponent is within range
        jc    rexp14                    ; Branch if so

rexp13: throwm 52                       ; Throw error

rexp14: add   r9, 0x3FFF                ; Add exponent bias
        btr   rbp, 0                    ; Test/clear sign flag
        jnc   rexp15

        bts   r9, 15                    ; Set sign bit

rexp15: mov   [r14], rax                ; Place significand
        mov   [r14+8], r9               ; Place exponent
        nextm
datam

; xp>re - Convert IEEE extended precision number directly to real number

head    "xp>re", nbco
xptre:  dq  xpre0
textm
xpre0:  mov   rax, [r14]                ; Get significand
        mov   rdx, [r14+8]              ; Get exponent
        add   r14, 16                   ; Pop stack
        mov   r10, [qdsz0]              ; Get qsz
        mov   r9, r10                   ; Copy qsz
        shl   r9, 1                     ; Double for positional data
        mov   rcx, r9                   ; Set counter
xpre1:  sub   r14, 8                    ; Decrement stack pointer
        mov   qword[r14], 0             ; Clear stack space for real number
        sub   rcx, 1
        jnz   xpre1

        cmp   rdx, 0                    ; See if exponent is zero
        jz    xpre9                     ; Finish if zero

        btr   rdx, 15                   ; Test/clear sign bit

        setc  bpl                       ; Set register accordingly

        mov   rbx, r10                  ; Copy quadsize
        shl   rbx, 6                    ; Convert to bit size
        mov   r8, rbx                   ; Save copy
        sub   rdx, 0x3FFF               ; Subtract exponent bias
        jns   xpre2                     ; Branch if positive

        mov   rcx, rdx                  ; Copy exponent
        neg   rcx                       ; Negate copy

; If it is desirable to check for the least significant bit, here is the place.

        add   rcx, 63                   ; Add mantissa length
        cmp   rbx, rcx                  ; See if mantissa will fit
        jnc   xpre4                     ; Branch if so

        jmp   xpre3                     ; Else branch to throw error

xpre2:  sub   rbx, 1                    ; Subtract 1 for sign bit
        cmp   rbx, rdx                  ; See if mantissa will fit
        jnc   xpre4                     ; Branch if so

; Throw error if number cannot be accommodated.

xpre3:  throwm 54

xpre4:  sub   r8, rdx                   ; Subtract exponent from cell bitsize
        sub   r8, 1                     ; Subtract 1
        mov   rcx, r8                   ; Copy total bitsize
        xor   rbx, rbx                  ; Zero low order shift register
        mov   rcx, r8                   ; Copy total shift count
        shr   r8, 6                     ; Convert to quads
        and   rcx, 63                   ; Extract bit shift count
        jz    xpre5                     ; Branch if no bits to shift

        shrd  rbx, rax, cl              ; Shift high order into low order
        shr   rax, cl                   ; Shift high order
        cmp   rbx, 0                    ; Test if low order is zero
        jz    xpre5                     ; Skip installing result

        mov   [r14+r8*8+8], rbx         ; Install low order result

xpre5:  mov   [r14+r8*8], rax           ; Install high order result
        test  bpl, bpl                  ; Test sign flag
        jz    xpre9                     ; Finish if clear

        cmp   rbx, 0                    ; See if low order is zero
        jz    xpre6                     ; Skip adding 1

        add   r8, 1                     ; Else add 1 for low order quad

xpre6:  add   r8, 1                     ; Add 1 for high order quad
        mov   rcx, r8                   ; Set counter
xpre7:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   xpre7
xpre8:  add   qword[r14+r8*8-8], 1
        jnc   xpre9
        sub   r8, 1
        jnz   xpre8

xpre9:  nextm
datam

; xpexp - Get exponent of IEEE extended precision number.

head    "xpexp", nbco
xpexp:  dq  xpxp0
textm
xpxp0:  mov   rax, [r14+8]              ; Get exponent
        btr   rax, 15                   ; Clear sign bit
        sub   rax, 0x3FFF               ; Subtract exponent bias
        add   r14, 8
        mov   [r14], rax                ; Put result on stack
        nextm
datam

; re>qp - Convert real number directly to IEEE quad precision format.
; Throw 56 if exponent is out of range, -16382 > exp > 16383.

head    "re>qp", nbco
retqp:  dq  reqp0
textm
reqp0:  lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to quads
        mov   r9, [qdsz0]               ; Get qsz
        shl   r9, 1                     ; Double for real data
        cmp   rdi, r9                   ; Compare items needed
        jnc   reqp1

        throwm 69

reqp1:  xor   rbp, rbp                  ; Zero flags register
        xor   rax, rax                  ; Zero data registers
        xor   rbx, rbx
        bt    qword[r14], 63            ; Test sign of real number
        jnc   reqp4                     ; Branch if positive

; Negate if negative

        bts   rbp, 0                    ; Set sign flag if negative
        mov   rcx, r9                   ; Set counter
reqp2:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   reqp2
        mov   rcx, r9                   ; Reset counter
reqp3:  add   qword[r14+rcx*8-8], 1
        jnc   reqp4
        sub   rcx, 1
        jnz   reqp3

; Pop the stack, leaving two quads.

reqp4:  mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+r9*8-16]        ; Leave two cells on stack

; Locate lead quad

        xor   rdx, rdx                  ; Zero index register
        mov   rcx, r9                   ; Copy double qsz
reqp5:  cmp   qword[rsi+rdx*8], 0       ; Test for zero
        jnz   reqp6                     ; If non-zero, leave loop
        add   rdx, 1                    ; Increment index register
        sub   rcx, 1                    ; Decrement count
        jnz   reqp5

; If loop falls through, number is zero. Push zero for exponent
; and significand.

        jmp   reqp16                    ; Branch to end

; Scan lead quad for lead bit.
; Note that rcx is not cleared for bsr because we already know that rbx
; is not zero. Otherwise the contents of rcx would not be changed.

reqp6:  mov   rax, [rsi+rdx*8]          ; Get first non-zero quad
        bsr   rcx, rax                  ; Scan for leading set bit
        sub   rcx, 63                   ; Calculate shift count
        neg   rcx

; Adding 1 to the shift count here to shift out the implied bit
; is a mistake, since the shift value can be 63 and adding 1 makes
; it 64. 64 mod 64 is 0. No shift!

;        add   rcx, 1                    ; Add 1 for implied bit

        lea   r8, [r9-1]                ; Copy 2*qsz-1
        sub   r8, rdx                   ; Subtract lead quad location
        jnz   reqp7                     ; Branch if not zero

; Shift significand.

        shl   rax, cl                   ; Shift significand
        jmp   reqp9                     ; Branch to handle implied bit

reqp7:  mov   rbx, [rsi+rdx*8+8]        ; Get next quad
        shld  rax, rbx, cl              ; Shift into high order significand
        cmp   r8, 2                     ; Test for additional quad 
        jnz   reqp8                     ; Branch if more quads

        shl   rbx, cl                   ; Shift low order significand
        jmp   reqp9                     ; Branch to handle implied bit

reqp8:  mov   r8, [rsi+rdx*8+16]        ; Get next quad
        shld  rbx, r8, cl               ; Shift into low order significand

; Shift out implied bit.

reqp9:  shld  rax, rbx, 1
        shl   rbx, 1

; Calculate the exponent as the lead quad count in bits plus the number of bits
; shifted plus 1 subtracted from the quadsize in bits.

        shl   rdx, 6                    ; Convert lead-quad count to bit count
        add   rdx, rcx                  ; Add bits shifted
        cmp   rdx, 1                    ; See if 1
        jnz   reqp10

; If total shift count is 1, set flag to trap overflow.

        bts   rbp, 1

; One is added to the total shift count to convert to exponent.

reqp10: add   rdx, 1                    
        shl   r9, 5                     ; Convert qsz to bit count
        sub   r9, rdx                   ; Subtract total bits shifted

; No rounding is needed if low order word of low order quad is zero.

        mov   r8, rbx
        and   r8, 0xFFFF
        jz    reqp12

; Apply the GRS round-to-even algorithm. First test the guard bit, G, and do
; nothing if it is zero.

        bt    rbx, 15                   ; Test G
        jnc   reqp12                    ; Round down if not set

; Apply the GRS rounding algorithm.

        mov   r8, rbx                   ; Copy significand
        and   r8, 0x3FFF                ; Find sticky bit
        jnz   reqp11                    ; Round up if any bits are set

        bt    rbx, 10                   ; Test R
        jc    reqp11                    ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rbx, 16                   ; Test even bit
        jnc   reqp12                    ; Round down if clear

reqp11: add   rbx, 32768                ; Add 1 at 16th bit position
        jnc   reqp12                    ; Branch if no carry

        add   rax, 1                    ; Add carry to high order
        jnc   reqp12                    ; Branch if no carry

; If there is a carry out of the mantissa, and the overflow flag is set,
; throw error. Else increment exponent.

        btr   rbp, 1                    ; Test/clear overflow flag
        jc    reqp14                    ; Throw error if set

        add   r9, 1                     ; Increment exponent

reqp12: mov   r8, r9                    ; Copy exponent
        bt    r8, 63                    ; See if exponent is positive
        jnc   reqp13                    ; Branch if so

        neg   r8                        ; Else negate copy of exponent
        cmp   r8, 0x3FFF                ; See if exponent is within range
        jc    reqp15                    ; Branch if so

        jmp   reqp14                    ; Else branch to throw error

reqp13: cmp   r8, 0x4000                ; See if exponent is within range
        jc    reqp15                    ; Branch if so

reqp14: throwm 52                       ; Throw error

reqp15: add   r9, 0x3FFF                ; Add exponent bias

; Shift exponent into number.

        shrd  rbx, rax, 16
        shrd  rax, r9, 16
        btr   rbp, 0                    ; Test/clear sign flag
        jnc   reqp16

        bts   rax, 63                   ; Set sign bit

reqp16: mov   [r14], rbx                ; Install result on stack
        mov   [r14+8], rax
        nextm
datam

; qp>re - Convert IEEE quadruple precision number directly to real number.
; Note that when the quadsize is 1 the result must be rounded to fit.

head    "qp>re", nbco
qptre:  dq  qpre0
textm
qpre0:  mov   rdx, [r14+8]              ; Get high order
        mov   rbx, [r14]                ; Get low order
        add   r14, 16                   ; Pop stack
        mov   r10, [qdsz0]              ; Get quadsize
        mov   r9, r10                   ; Copy qsz
        shl   r9, 1                     ; Double for positional data
        mov   rcx, r9                   ; Set counter
qpre1:  sub   r14, 8                    ; Decrement stack pointer
        mov   qword[r14], 0             ; Clear stack space for real number
        sub   rcx, 1
        jnz   qpre1

        btr   rdx, 63                   ; Test/clear sign bit

        setc  bpl                       ; Set register accordingly

        xor   r8, r8                    ; Zero exponent register
        shld  r8, rdx, 16               ; Shift exponent into register
        jz    qpre8                     ; Finish if exponent is zero

        shl   r9, 5                     ; Convert quadsize to bitsize
        mov   r10, r9                   ; Save copy
        sub   r8, 0x3FFF                ; Subtract exponent bias
        jns   qpre2                     ; Branch if positive

        mov   rcx, r8                   ; Copy exponent
        neg   rcx                       ; Negate copy

; If it is desirable to check for the least significant bit, here is the place.

        add   rcx, 113                  ; Add mantissa length
        cmp   r9, rcx                   ; See if mantissa will fit
        jnc   qpre4                     ; Branch if so

        jmp   qpre3                     ; Else branch to throw error

qpre2:  sub   r9, 1                     ; Subtract 1 for sign bit
        cmp   r9, r8                    ; See if mantissa will fit
        jnc   qpre4                     ; Branch if so

; Throw error if number cannot be accommodated.

qpre3: throwm 54

qpre4:  shld  rdx, rbx, 15              ; Shift low into high order
        shl   rbx, 15                   ; Shift low order
        bts   rdx, 63                   ; Set implied bit
        mov   rcx, r10                  ; Copy quad size
        sub   rcx, r8                   ; Subtract exponent
        sub   rcx, 1                    ; Subtract 1
        mov   r8, rcx                   ; Copy total shift count
        xor   rax, rax                  ; Zero low order shift register
        and   rcx, 63                   ; Extract bit shift count
        jz    qpre5                     ; Branch if no bits to shift

        shrd  rax, rbx, cl              ; Shift mid order into low order
        shrd  rbx, rdx, cl              ; Shift high order into mid order
        shr   rdx, cl                   ; Shift high order
 
qpre5:  shr   r8, 6                     ; Convert total shift count to quads
        mov   [r14+r8*8], rdx           ; Install high order result
        mov   [r14+r8*8+8], rbx         ; Install mid order result
        mov   [r14+r8*8+16], rax        ; Install low order result

        test  bpl, bpl                  ; Test sign flag
        jz    qpre8                     ; Finish if clear

        add   r8, 3                     ; Add 3 for significand quads
        mov   rcx, r8                   ; Set counter
qpre6:  not   qword[r14+rcx*8-8]        ; Negate number
        sub   rcx, 1
        jnz   qpre6
qpre7:  add   qword[r14+r8*8-8], 1
        jnc   qpre8
        sub   r8, 1
        jnz   qpre7

qpre8:  nextm
datam

; qpexp - Get exponent of IEEE quad precision number.

head    "qpexp", nbco
qpexp:  dq  qpxp0
textm
qpxp0:  add   r14, 8                    ; Pop low order
        xor   rax, rax                  ; Clear exponent register
        mov   ax,  [r14+6]              ; Get exponent
        btr   rax, 15                   ; Clear sign bit
        sub   rax, 0x3FFF               ; Subtract exponent bias
        mov   [r14], rax                ; Put result on stack
        nextm
datam

; fl>sp - Convert Forthx64 format floating-point number to IEEE single
; precision format. Throw 54 if exponent is out of range, -126 > exp > 127.

head    "fl>sp", nbco
fltsp:  dq  flsp0
textm
flsp0:  lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to quads
        mov   r9, [qdsz0]               ; Get qsz
        shl   r9, 1                     ; Double for real data
        cmp   rdi, r9                   ; Compare items needed
        jnc   flsp1

        throwm 69

flsp1:  mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+r9*8-8]         ; Pop stack, leaving 1 quad
        mov   rbx, [rsi]                ; Get exponent
        cmp   rbx, 0                    ; See if exponent is zero
        jz    flsp7                     ; Finish if so

        mov   rax, [rsi+8]              ; Get high order significand
        btr   rbx, 63                   ; Test/clear sign bit

        setc  bpl                       ; Set register according to sign

        mov   rdx, 0x3FFFFFFFFFFFFFFF   ; Subtract exponent bias
        sub   rbx, rdx

; Since the significand will be shifted 23 bits after the implied bit is
; shifted out, the 40th bit is the guard bit, and if it is set,
; 1 is added at the 41st bit position.

        shl   rax, 1                    ; Shift out implied bit

; Apply GRS round-to-even algorithm.

        bt    rax, 40                   ; Test guard bit, G
        jnc   flsp3                     ; Round down if clear

        mov   rdx, rax                  ; Copy significand
        mov   r8, 0x1FFFFFFFFF          ; Move mask to register
        and   rdx, r8                   ; Find sticky bit
        jnz   flsp2                     ; Round up if any bits are set

        bt    rax, 39                   ; Test R
        jc    flsp2                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rax, 41                   ; Test even bit
        jnc   flsp3                     ; Round down if clear

flsp2:  mov   r8, 2199023255552         ; Move addend to register
        add   rax, r8                   ; Add 1 at 41st bit position
        jnc   flsp3                     ; Branch if no carry

; If there is a carry out of the mantissa, increment exponent.

        add   rbx, 1                    ; Add 1 to exponent

flsp3:  mov   rdx, rbx                  ; Copy exponent
        bt    rdx, 63                   ; Test sign of exponent
        jnc   flsp4                     ; Branch if positive

        neg   rdx                       ; Else negate copy
        cmp   rdx, 0x7F                 ; See if exponent is within range
        jc    flsp6                     ; Branch if so

        jmp   flsp5                     ; Else throw error

flsp4:  cmp   rdx, 0x80                 ; See if exponent is within range
        jc    flsp6                     ; Branch if so

flsp5:  throwm 52                       ; Throw error

flsp6:  add   rbx, 0x7F                 ; Add double precision bias
        mov   rcx, 23                   ; Set shift count
        shld  rbx, rax, cl              ; Shift significand into exponent
        test  bpl, bpl                  ; Test sign flag
        jz    flsp7                     ; Branch if clear

        bts   rbx, 31                   ; Set sign bit

flsp7:  mov   [r14], rbx                ; Put double precision float on stack
        nextm
datam

; sp>fl - Convert IEEE single precision number to Forthx64 format floating
;          point number.

head    "sp>fl", nbco
sptfl:  dq  spfl0
textm
spfl0:  mov   rbx, [r14]                ; Get single precision number
        add   r14, 8                    ; Pop the stack
        mov   rcx, [qdsz0]              ; Copy qsz
        shl   rcx, 1                    ; Double for Forthx64 float
spfl1:  sub   r14, 8                    ; Decrement stack pointer
        mov   qword[r14], 0             ; Clear stack space for float
        sub   rcx, 1
        jnz   spfl1

        btr   rbx, 31                   ; Test/clear sign bit

        setc  bpl                       ; Set register accordingly

        xor   rax, rax                  ; Zero significand register
        mov   rcx, 23                   ; Set shift count
        shrd  rax, rbx, cl              ; Shift significand into register
        shr   rbx, cl                   ; Isolate exponent
        cmp   rbx, 0                    ; See if exponent is zero
        jz    spfl3                     ; Finish if zero

        shr   rax, 1                    ; Make room for implied bit
        bts   rax, 63                   ; Set implied bit
        sub   rbx, 0x7F                 ; Subtract exponent bias
        mov   rdx, 0x3FFFFFFFFFFFFFFF
        add   rbx, rdx                  ; Add Forthx64 format bias
        test  bpl, bpl                  ; Test sign flag
        jz    spfl2                     ; Branch if clear

        bts   rbx, 63                   ; Set sign bit

spfl2:  mov   [r14], rbx                ; Install exponent
        mov   [r14+8], rax              ; Install significand
spfl3:  nextm
datam

; fl>dp - Convert Forthx64 format floating-point number to IEEE double
; precision format. Throw 54 if exponent is out of range, -1022 > exp > 1023.

head    "fl>dp", nbco
fltdp:  dq  fldp0
textm
fldp0:  lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to quads
        mov   r9, [qdsz0]               ; Get qsz
        shl   r9, 1                     ; Double for real data
        cmp   rdi, r9                   ; Compare items needed
        jnc   fldp1

        throwm 69

fldp1:  mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+r9*8-8]         ; Pop stack, leaving 1 quad
        mov   rbx, [rsi]                ; Get exponent
        cmp   rbx, 0                    ; See if exponent is zero
        jnz   fldp2                     ; Branch if not

        xor   rax, rax                  ; Zero significand register
        jmp   fldp8                     ; Finish

fldp2:  mov   rax, [rsi+8]              ; Get high order significand
        btr   rbx, 63                   ; Test/clear sign bit

        setc  bpl                       ; Set register according to sign

        mov   rdx, 0x3FFFFFFFFFFFFFFF   ; Subtract exponent bias
        sub   rbx, rdx

; Since the significand will be shifted 52 bits after the implied bit is
; shifted out, the 11th bit is the guard bit, and if it is set,
; 1 is added at the 12th bit position.

        shl   rax, 1                    ; Shift out implied bit

; Apply GRS round-to-even algorithm.

        bt    rax, 11                   ; Test guard bit, G
        jnc   fldp4                     ; Round down if clear

        mov   rdx, rax                  ; Copy significand
        and   rdx, 0x1FF                ; Find sticky bit
        jnz   fldp3                     ; Round up if any bits are set

        bt    rax, 10                   ; Test R
        jc    fldp3                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rax, 12                   ; Test even bit
        jnc   fldp4                     ; Round down if clear

fldp3:  add   rax, 4096                 ; Add 1 at 12th bit position
        jnc   fldp4                     ; Branch if no carry

; If there is a carry out of the mantissa, increment exponent.

        add   rbx, 1                    ; Add 1 to exponent

fldp4:  mov   rdx, rbx                  ; Copy exponent
        bt    rdx, 63                   ; Test sign of exponent
        jnc   fldp5                     ; Branch if positive

        neg   rdx                       ; Else negate copy
        cmp   rdx, 0x3FF                ; See if exponent is within range
        jc    fldp7                     ; Branch if so

        jmp   fldp6                     ; Else throw error

fldp5:  cmp   rdx, 0x400                ; See if exponent is within range
        jc    fldp7                     ; Branch if so

fldp6:  throwm 52                       ; Throw error

fldp7:  add   rbx, 0x3FF                ; Add double precision bias
        mov   rcx, 12                   ; Set shift count
        shrd  rax, rbx, cl              ; Shift exponent into significand
        test  bpl, bpl                  ; Test sign flag
        jz    fldp8                     ; Branch if clear

        bts   rax, 63                   ; Set sign bit

fldp8:  mov   [r14], rax                ; Put double precision float on stack
        nextm
datam

; dp>fl - Convert IEEE double precision number to Forthx64 format floating
;          point number.

head    "dp>fl", nbco
dptfl:  dq  dpfl0
textm
dpfl0:  mov   rax, [r14]                ; Get double precision number
        add   r14, 8                    ; Pop the stack
        mov   rcx, [qdsz0]              ; Get qsz
        shl   rcx, 1                    ; Double for Forthx64 float
dpfl1:  sub   r14, 8                    ; Decrement stack pointer
        mov   qword[r14], 0             ; Clear stack space for float
        sub   rcx, 1
        jnz   dpfl1

        btr   rax, 63                   ; Test/clear sign bit

        setc  bpl                       ; Set register according to sign

        xor   rbx, rbx                  ; Zero exponent register
        mov   rcx, 12                   ; Set shift count
        shld  rbx, rax, cl              ; Shift exponent into register
        cmp   rbx, 0                    ; See if exponent is zero
        jz    dpfl3                     ; Finish if zero

        shl   rax, cl                   ; Isolate significand
        shr   rax, 1                    ; Make room for implied bit
        bts   rax, 63                   ; Set implied bit
        sub   rbx, 0x3FF                ; Subtract exponent bias
        mov   rdx, 0x3FFFFFFFFFFFFFFF
        add   rbx, rdx                  ; Add Forthx64 format bias
        test  bpl, bpl                  ; Test sign flag
        jz    dpfl2                     ; Branch if clear
        bts   rbx, 63                   ; Set sign bit

dpfl2:  mov   [r14], rbx                ; Install exponent
        mov   [r14+8], rax              ; Install significand
dpfl3:  nextm
datam

; fl>xp - Convert Forthx64 format floating-point number to IEEE extended
; format. Throw 54 if exponent is out of range, -16382 > exp > 16383.

head    "fl>xp", nbco
fltxp:  dq  flxp0
textm
flxp0:  lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to quads
        mov   r9, [qdsz0]               ; Get qsz
        shl   r9, 1                     ; Double for real data
        cmp   rdi, r9                   ; Compare items needed
        jnc   flxp1

        throwm 69

flxp1:  mov   rdx, r9                   ; Copy qsz
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rdx*8-16]       ; Pop stack, leaving 2 quads
        mov   rbx, [rsi]                ; Get exponent
        cmp   rbx, 0                    ; See if exponent is zero
        jnz   flxp2                     ; Branch if not

        xor   rax, rax                  ; Zero significand register
        jmp   flxp8                     ; Finish

flxp2:  mov   rax, [rsi+8]              ; Get high order significand
        btr   rbx, 63                   ; Test/clear sign bit

        setc  bpl                       ; Set register according to sign

        mov   rdx, 0x3FFFFFFFFFFFFFFF   ; Subtract exponent bias
        sub   rbx, rdx

; If qsz is 1, there is no rounding to be done.

        cmp   r9, 2
        jz    flxp4

; Apply GRS round-to-even algorithm.

        bt    qword[rsi+16], 63         ; Test guard bit, G
        jnc   flxp4                     ; Round down if clear

        mov   rdx, [rsi+16]             ; Get next significand quad
        xor   r8, r8                    ; Clear register
        shld  r8, rdx, 2                ; Shift in G & R
        shl   rdx, 2                    ; Shift G & R out
        cmp   rdx, 0                    ; Test S - the sticky bit
        jnz   flxp3                     ; Round up if any bits are set

        bt    r8, 0                     ; Test R
        jc    flxp3                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rax, 0                    ; Test even bit
        jnc   flxp4                     ; Round down if clear

; Round up. If adding 1 to the significand results in a carry, decrement
; shift count.

flxp3:  add   rax, 1                    ; Round
        jnc   flxp4                     ; Process exponent if no carry

; If rounding results in overflow of the significand, it must consists
; of all F's and the result will be a significand of 1 with an exponent one
; higher.

        bts   rax, 63                   ; Significand is 1
        add   rbx, 1                    ; Increment exponent

flxp4:  mov   rdx, rbx                  ; Copy exponent
        bt    rdx, 63                   ; Test sign of exponent
        jnc   flxp5                     ; Branch if positive

        neg   rdx                       ; Else negate copy of exponent
        cmp   rdx, 0x3FFF               ; See if exponent is within range
        jc    flxp7                     ; Branch if so

        jmp   flxp6                     ; Else throw error

flxp5:  cmp   rdx, 0x4000               ; See if exponent is within range
        jc    flxp7                     ; Branch if so

flxp6:  throwm 52                       ; Throw error

flxp7:  add   rbx, 0x3FFF               ; Add double extended bias
        test  bpl, bpl                  ; Test sign flag
        jz    flxp8                     ; Branch if clear

        bts   rbx, 15                   ; Set sign bit

flxp8:  mov   [r14], rax                ; Put significand on stack
        mov   [r14+8], rbx              ; Put exponent on stack
        nextm
datam

; xp>fl - Convert IEEE extended format floating-point number to Forthx64
;          format in the current quad size. Overflow can't occur.

head    "xp>fl", nbco
xptfl:  dq  xpfl0
textm
xpfl0:  mov   rdx, [r14+8]              ; Get exponent quad
        mov   rbx, [r14]                ; Get significand
        add   r14, 16                   ; Pop stack
        mov   rcx, [qdsz0]              ; Get qsz
        shl   rcx, 1                    ; Double qsz
xpfl1:  sub   r14, 8                    ; Clear stack space for result
        mov   qword[r14], 0
        sub   rcx, 1
        jnz   xpfl1

        cmp   rdx, 0                    ; See if exponent is zero
        jz    xpfl3                     ; Exit if zero

        btr   rdx, 15                   ; Test/clear sign bit

        setc  bpl                       ; Set register accordingly

        sub   rdx, 0x3FFF               ; Subtract double extended bias
        mov   rax, 0x3FFFFFFFFFFFFFFF
        add   rdx, rax                  ; Add Forthx64 format bias
        btr   rbp, 0                    ; Test/clear sign flag
        jnc   xpfl2
        bts   rdx, 63                   ; Set sign bit

xpfl2:  mov   [r14], rdx                ; Put new exponent on stack
        mov   [r14+8], rbx              ; Put significand on stack
xpfl3:  nextm
datam

; fl>qp - Convert Forthx64 format floating-point number to IEEE quad
; precision format. Throw 54 if exponent is out of range, -16382 > exp > 16383.
; No rounding is needed if the quadsize is 1 or the low order significand is 0.

head    "fl>qp", nbco
fltqp:  dq  flqp0
textm
flqp0:  lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to quads
        mov   r10, [qdsz0]              ; Get qsz
        shl   r10, 1                    ; Double for real data
        cmp   rdi, r10                  ; Compare items needed
        jnc   flqp1

        throwm 69

flqp1:  mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+r10*8-16]       ; Pop stack, leaving 2 quads
        mov   rdx, [rsi]                ; Get exponent
        cmp   rdx, 0                    ; See if exponent is zero
        jz    flqp9                     ; Finish if so

        xor   rbx, rbx                  ; Zero low order register
        mov   rax, [rsi+8]              ; Get high order significand
        cmp   r10, 2                    ; See if quadsize is 1
        jz    flqp2                     ; Branch if so

        mov   rbx, [rsi+16]             ; Get low order significand

flqp2:  btr   rdx, 63                   ; Test/clear sign bit

        setc  bpl                       ; Set register according to sign

        mov   r9, 0x3FFFFFFFFFFFFFFF    ; Subtract exponent bias
        sub   rdx, r9

; Shift significand right 15 bit positions. This also has the effect of
; shifting out the implied bit, since the exponent will overwrite the high
; order 16 bit positions.

        xor   r8, r8
        shrd  r8, rbx, 15
        shrd  rbx, rax, 15
        shr   rax, 15

; If the quadsize is 1, no rounding is needed.

        cmp   r10, 2                    ; See if quadsize is 1
        jz    flqp4

; Apply the GRS round-to-even algorithm. First test the guard bit, G, and do
; nothing if it is zero.

        bt    r8, 63                    ; Test G
        jnc   flqp4                     ; Round down if not set

        xor   r9, r9                    ; Clear register
        shld  r9, r8, 2                 ; Shift in G & R
        shl   r8, 2                     ; Shift G & R out
        cmp   r8, 0                     ; Test S - the sticky bit
        jnz   flqp3                     ; Round up if any bits are set

        bt    r9, 0                     ; Test R
        jc    flqp3                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rbx, 0                    ; Test even bit
        jnc   flqp4                     ; Round down if clear

flqp3:  add   rbx, 1                    ; Add 1 to low order significand
        jnc   flqp4                     ; Branch if no carry

        add   rax, 1                    ; Add carry to high order
        bt    rax, 49                   ; See if carry resulted
        jnc   flqp4                     ; Branch if no carry

        add   rdx, 1                    ; Increment exponent

flqp4:  mov   rcx, rdx                  ; Copy exponent
        bt    rdx, 63                   ; Test sign of exponent
        jnc   flqp5                     ; Branch if positive

        neg   rcx                       ; Negate copy of exponent
        cmp   rcx, 0x3FFF               ; See if exponent is within range
        jc    flqp7                     ; Branch if so

        jmp   flqp6                     ; Else throw error

flqp5:  cmp   rdx, 0x4000               ; See if exponent is within range
        jc    flqp7                     ; Branch if so

flqp6:  throwm 52                       ; Throw error

flqp7:  add   rdx, 0x3FFF               ; Add exponent bias

        test  bpl, bpl                  ; See if negative
        jz    flqp8                     ; Branch if flag was clear

        bts   rdx, 15                   ; Set sign bit

flqp8:  mov   [r14], rbx                ; Put low order on stack
        mov   [r14+8], rax              ; Put high order on stack
        mov   [r14+14], dx              ; Install exponent
flqp9:  nextm
datam

; qp>fl - Convert IEEE quad precision format floating-point number
; to Forthx64 format in the current quad size. If the quadsize is 1,
; the significand must be rounded.

head    "qp>fl", nbco
qptfl:  dq  qpfl0
textm
qpfl0:  mov   rax, [r14+8]              ; Get high order quad
        mov   rbx, [r14]                ; Get low order quad
        add   r14, 16                   ; Pop stack
        mov   r9, [qdsz0]               ; Get qsz
        shl   r9, 1                     ; Double qsz
        mov   rcx, r9                   ; Copy for counter
qpfl1:  sub   r14, 8                    ; Clear stack space for result
        mov   qword[r14], 0
        sub   rcx, 1
        jnz   qpfl1

        btr   rax, 63                   ; Test/clear sign bit

        setc  bpl                       ; Set register accordingly

        xor   rdx, rdx                  ; Clear exponent register
        shld  rdx, rax, 16              ; Shift in exponent
        jz    qpfl5                     ; Exit if exponent is zero

        sub   rdx, 0x3FFF               ; Subtract quad precision bias
        mov   r8, 0x3FFFFFFFFFFFFFFF    ; Add Forthx64 format bias
        add   rdx, r8

; Shift significand and set implied bit.

        shld  rax, rbx, 15              ; Shift low order into high order
        shl   rbx, 15                   ; Shift low order
        bts   rax, 63                   ; Set implied bit

        cmp   r9, 2                     ; See if quadsize is 1
        jnz   qpfl3                     ; Branch if not

; Apply the GRS round-to-even algorithm. First test the guard bit, G, and do
; nothing if it is zero.

        bt    rbx, 63                   ; Test G
        jnc   qpfl4                     ; Round down if not set

        xor   r8, r8                    ; Clear register
        shld  r8, rbx, 2                ; Shift in G & R
        shl   rbx, 2                    ; Shift G & R out of low order
        cmp   rbx, 0                    ; Test S - the sticky bit
        jnz   qpfl2                     ; Round up if any bits are set

        bt    r8, 0                     ; Test R
        jc    qpfl2                     ; Round up if set

; Else it's a tie. Test bit before G.

        bt    rax, 0                    ; Test even bit
        jnc   qpfl4                     ; Round down if even

; Round up. If adding 1 to the significand results in a carry,
; increment exponent

qpfl2:  add   rax, 1                    ; Add 1 to significand
        jnc   qpfl4                     ; Branch if no carry

        add   rdx, 1                    ; Increment exponent

        jmp   qpfl4

qpfl3:  mov   [r14+16], rbx             ; Put low order significand on stack
qpfl4:  mov   [r14+8], rax              ; Put high order significand on stack
        mov   [r14], rdx                ; Put exponent on stack
        test  bpl, bpl                  ; Test sign flag
        jz    qpfl5                     ; Branch if clear

        bts   qword[r14], 63            ; Set sign bit

qpfl5:  nextm
datam

; xsave - Save the xmm registers to fprgs0.

head    "xsave"
xsve:   dq  xsve0
textm
xsve0:  mov     rax, -1
        mov     rdx, rax
        xsave   [fprgs0]
        vzeroall
        mov     rax, -1
        mov     rdx, rax
        xrstor  [fprgs0]
        nextm
datam

; save-xmms - Save the xmm registers to sxmm0.

head    "save-xmms"
svxmm:  dq  svxm0
textm
svxm0: 

        savexmm sxmm0

        nextm
datam

; save-ymms - Save the ymm registers to symm0.

head    "save-ymms"
svymm:  dq  svym0
textm
svym0: 

        saveymm symm0

        nextm
datam

; Multi-quad Number Format Settings

; s-numbers - Set parameters for (relatively) small numbers.

head    "s-numbers", hlfo
snums:  dq  docl0
        dq  lit,64,qszsto,lit,1024,rdigs,stor
        dq  okmsg,semis

; m-numbers - Set parameters for medium numbers.

head    "m-numbers", hlfo
mnums:  dq  docl0
;        dq  lit,256,qszsto,lit,4096,rdigs,stor
        dq  lit,512,qszsto,lit,8192,rdigs,stor
        dq  okmsg,semis

; lg-numbers - Set parameters for large numbers.

head    "lg-numbers", hlfo
lgnums: dq  docl0
        dq  lit,2048,qszsto,lit,32768,rdigs,stor
        dq  okmsg,semis

; hg-numbers - Set parameters for huge numbers.

head    "hg-numbers", hlfo
hgnums: dq  docl0
        dq  lit,4096,qszsto,lit,65536,rdigs,stor
        dq  okmsg,semis

; default-numbers - Set default number parameters.

; : default-numbers 10 base ! 4 qsz! 64 rdigs ! 2 ['] msgout 8+ 8+ ! ;

head    "default-numbers", hlfo
dfnums: dq  docl0
        dq  four,qszsto,lit,19,rdigs,stor
        dq  two,lit,msgout,pnch,semis

; Object Operators

head    "ob,", cmpo
obcom:  dq  obcm0
textm
obcm0:  mov   rcx, [r14]                ; Get object size
        shr   rcx, 3                    ; Convert to qsz
        mov   r9, rcx                   ; Copy for shifting
        mov   rdi, [dspo0]              ; Get dsp
        lea   rdi, [rdi+rcx*8]          ; Load constant/literal base addr
        lea   r14, [r14+rcx*8]          ; Pop stack
        mov   rsi, r14                  ; Copy stack base address
        mov   [dspo0], rdi              ; Update dsp
        neg   rcx                       ; Create negative offset

        shr   r9, 1
        jnc   obcm1

        mov   rbx, [rsi+rcx*8]          ; Get first/next quad
        mov   [rdi+rcx*8], rbx          ; Move from stack
        add   rcx, 1                    ; Increment counter
        jnz   obcm1                     ; Loop for quad size
        jmp   obcm2

obcm1:  ssopm 2, -shcnt, dpokm
obcm2:  nextm
datam

; ob@ - Fetch an object to the stack. Though the object includes a byte-count
; as its first quadword, it is expected to be a multiple of eight bytes,
; and is treated as such by object operators.

head    "ob@", mqso
objat:  dq  obat0
textm
obat0:  mov   rsi, [r14]                ; Get object address
        mov   rcx, [rsi]                ; Get size of object (bytes)
        shr   rcx, 3                    ; Convert to quads
        mov   r9, rcx                   ; Copy qsz for shift
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8+8]        ; Make room on stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   obat1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   obat1
        jmp   obat2

obat1:  ssopm 2, shcnt, dmovm

obat2:  nextm
datam

; ob!

head    "ob!"
objst:  dq  obst0
textm
obst0:  mov   rdi, [r14]                ; Pop address of variable
        add   r14, 8
        mov   rcx, [rdi]                ; Get size of object variable
        cmp   [r14], rcx                ; Compare variable size with object size
        jz    obst1                     ; Branch if they are equal

        throwm 23                       ; Throw container size mismatch

obst1:  shr   rcx, 3                    ; Convert byte size to qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop the stack

        shr   r9, 1                     ; Shift count right
        jnc   obst2                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   obst2
        jmp   obst3

obst2:  ssopm 2, shcnt, dmovm

obst3:  nextm
datam

; ob>a - Pop top object on the data stack and push it
; to the auxiliary stack.

head    "ob>a", mqso
obtoa:  dq  obta0
textm
obta0:  mov   rcx, [r14]                ; Get object byte size
        shr   rcx, 3                    ; Convert to qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        mov   rsi, r14                  ; Copy stack pointer
        lea   r14, [r14+rcx*8]          ; Pop stack entry
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        mov   rdi, r13                  ; Copy auxiliary stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   obta1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   obta1
        jmp   obta2

obta1:  ssopm 2, shcnt, dmovm

obta2:  nextm
datam

; oba> - Pop the object from the auxiliary stack and push it
; to the data stack.

head    "oba>", mqso
obfma:  dq  obfa0
textm
obfa0:  mov   rcx, [r13]                ; Get byte size of entry
        shr   rcx, 3                    ; Convert to qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        mov   rsi, r13                  ; Copy auxiliary stack pointer
        lea   r13, [r13+rcx*8]          ; Pop entry
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   obfa1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   obfa1
        jmp   obfa2

obfa1:  ssopm 2, shcnt, dmovm

obfa2:  nextm
datam

; oba! - Copy the top object on the data stack to the auxiliary stack.

head    "oba!", mqso
obast:  dq  obas0
textm
obas0:  mov   rcx, [r14]                ; Get object byte size
        shr   rcx, 3                    ; Convert to qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        mov   rsi, r14                  ; Copy stack pointer
        neg   rcx                       ; Create negative offset
        lea   r13, [r13+rcx*8]          ; Make room on auxiliary stack
        mov   rdi, r13                  ; Copy auxiliary stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   obas1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   obas1
        jmp   obas2

obas1:  ssopm 2, shcnt, dmovm

obas2:  nextm
datam

; oba@ - Copy the object from the auxiliary stack to the data stack.

head    "oba@", mqso
obaat:  dq  obaa0
textm
obaa0:  mov   rcx, [r13]                ; Get byte size of entry
        shr   rcx, 3                    ; Convert to qsz
        mov   r9, rcx                   ; Copy qsz for shifting
        mov   rsi, r13                  ; Copy auxiliary stack pointer
        neg   rcx                       ; Create negative offset
        lea   r14, [r14+rcx*8]          ; Make room on data stack
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   obaa1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   obaa1
        jmp   obaa2

obaa1:  ssopm 2, shcnt, dmovm

obaa2:  nextm
datam

; obadrop

head    "obadrop", stko
obadr:  dq  obad0
textm
obad0:  add   r13, [r13]
        nextm
datam

; obdrop

head    "obdrop", stko
obdrp:  dq  obdr0
textm
obdr0:  add   r14, [r14]
        nextm
datam

; obdup

head    "obdup", mqso
obdup:  dq  obdp0
textm
obdp0:  mov   rcx, [r14]                ; Get object size
        shr   rcx, 3                    ; Convert to quad count
        mov   r9, rcx                   ; Copy qsz for shifting
        neg   rcx                       ; Negate count
        mov   rsi, r14                  ; Copy current stack pointer
        lea   r14, [r14+rcx*8]          ; Offset to new stack pointer
        mov   rdi, r14                  ; Copy stack pointer
        neg   rcx                       ; Restore count

        shr   r9, 1                     ; Shift count right
        jnc   obdp1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   obdp1
        jmp   obdp2

obdp1:  ssopm 2, shcnt, dmovm

obdp2:  nextm
datam

; Memory Move and Fill Operators

; qfill - ( addr n q --- ) - Fill n quads of memory with q starting at address.

head    "qfill"
qfill:  dq  qfil0
textm
qfil0:  mov   rbx, [r14]                ; Get fill quad
        mov   rcx, [r14+8]              ; Get count
        mov   r9, rcx                   ; Copy for shifting
        mov   rdi, [r14+16]             ; Get start address
        add   r14, 24                   ; Pop stack

        shr   r9, 1                     ; Shift count right
        jnc   qfil1                     ; Branch if no carry

        mov   [rdi+rcx*8-8], rbx        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   qfil1
        jmp   qfil2

qfil1:  ssopm 2, shcnt, dfilm

qfil2:  nextm
datam

; move - ( c-addr1 c-addr2 u --- ) Move bytes in memory depending
;       on whether the source or destination is the lower address.

head    "move"
xmove:  dq  move0
textm
move0:  mov   rcx, [r14]                ; Get number of bytes to move
        mov   rdi, [r14+8]              ; Get destination address
        mov   rsi, [r14+16]             ; Get source address
        add   r14, 24                   ; Pop stack
        mov   r9, rcx                   ; Copy count for shifting
        cmp   rsi, rdi                  ; Compare source and destination
        jz    movee                     ; Do nothing if they are the same
        jc    movh0                     ; Branch if destination higher

; Move starting at lower addresses

        lea   rdi, [rdi+rcx]            ; Offset to destination base addr
        lea   rsi, [rsi+rcx]            ; Offset to source base addr
        neg   rcx                       ; Create negative count

        shr   r9, 1                     ; Shift count right
        jnc   movl1                     ; Branch if no carry

        mov   bl, [rsi+rcx]             ; Move byte
        mov   [rdi+rcx], bl
        add   rcx, 1                    ; Increment count by 1
        jnz   movl1
        jmp   movee

movl1:  shr   r9, 1                     ; Shift count right
        jnc   movl2                     ; Branch if no carry

        mov   bx, word[rsi+rcx]         ; Move word
        mov   word[rdi+rcx], bx
        add   rcx, 2                    ; Increment count by 2
        jnz   movl2
        jmp   movee

movl2:  shr   r9, 1                     ; Shift count right
        jnc   movl3                     ; Branch if no carry

        mov   ebx, dword[rsi+rcx]       ; Move dword
        mov   dword[rdi+rcx], ebx
        add   rcx, 4                    ; Increment count by 4
        jnz   movl3
        jmp   movee

movl3:  mov   rcx, r9                   ; Copy shift for count
        neg   rcx                       ; Negate count
        shr   r9, 1
        jnc   movl4

        mov   rbx, [rsi+rcx*8]          ; Move quads
        mov   [rdi+rcx*8], rbx
        add   rcx, 1                    ; Increment count by 1
        jnz   movl4
        jmp   movee

movl4:  ssopm 2, -shcnt, dpokm
        jmp   movee

; Move starting at higher addresses

movh0:  shr   r9, 1                     ; Shift count right
        jnc   movh1                     ; Branch if no carry

        mov   bl, [rsi+rcx-1]           ; Move byte
        mov   [rdi+rcx-1], bl
        sub   rcx, 1                    ; Decrement count by 1
        jnz   movh1
        jmp   movee

movh1:  shr   r9, 1                     ; Shift count right
        jnc   movh2                     ; Branch if no carry

        mov   bx, [rsi+rcx-2]           ; Move word
        mov   [rdi+rcx-2], bx
        sub   rcx, 2                    ; Decrement count by 2
        jnz   movh2
        jmp   movee

movh2:  shr   r9, 1                     ; Shift count right
        jnc   movh3                     ; Branch if no carry

        mov   ebx, dword[rsi+rcx-4]     ; Move dword
        mov   dword[rdi+rcx-4], ebx
        sub   rcx, 4                    ; Decrement count by 4
        jnz   movh3
        jmp   movee

movh3:  shr   r9, 1                     ; Shift count right
        jnc   movh4                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   movh4
        jmp   movee

movh4:  ssopm 2, shcnt, dmovm

movee:  nextm
datam

; qmove - ( c-addr1 c-addr2 u --- ) Move quads in memory depending
;        on whether the source or destination is the lower address.

head    "qmove"
qmove:  dq  qmov0

; Since the x64 doesn't care about alignment, no checks are done.
; But note that there is a performance penalty for unaligned addresses.
textm
qmov0:  mov   rcx, [r14]                ; Get number of quads to move
        mov   rdi, [r14+8]              ; Get destination address
        mov   rsi, [r14+16]             ; Get source address
        add   r14, 24                   ; Pop stack
        mov   r9, rcx                   ; Copy count for shifting
        cmp   rsi, rdi                  ; Compare source and destination addrs
        jz    qmve                      ; Do nothing if they are the same
        jc    qmvh0                     ; Branch if destination higher

; Move quads starting at lower address.

        lea   rdi, [rdi+rcx*8]          ; Offset to destination base addr
        lea   rsi, [rsi+rcx*8]          ; Offset to source base addr
        neg   rcx                       ; Create negative count

        shr   r9, 1                     ; Shift count right
        jnc   qmvl1                     ; Branch if no carry

        mov   rbx, [rsi+rcx*8]          ; Get first quad
        mov   [rdi+rcx*8], rbx          ; Move first quad
        add   rcx, 1                    ; One quad
        jnz   qmvl1
        jmp   qmve

qmvl1:  ssopm 2, -shcnt, dpokm
        jmp   qmve

; Move quads starting at higher address.

qmvh0:  shr   r9, 1                     ; Shift count right
        jnc   qmvh1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   qmvh1
        jmp   qmve

qmvh1:  ssopm 2, shcnt, dmovm

qmve:   nextm
datam

; obmove - ( addr1 addr2 --- ) Copy object from addr1 to addr2. Object size is expected
; to be an even number of quads.

head    "obmove"
obmov:  dq  obmv0
textm
obmv0:  mov   rdi, [r14]                ; Get destination address
        mov   rsi, [r14+8]              ; Get source address
        add   r14, 16                   ; Pop stack
        mov   rcx, [rsi]                ; Get object size
        shr   rcx, 3                    ; Convert to quads

        mov   r9, rcx                   ; Copy count for shifting
        cmp   rsi, rdi                  ; Compare source and destination addrs
        jz    obmve                     ; Do nothing if they are the same
        jc    omvh0                     ; Branch if destination higher

; Move quads starting at lower address.

        lea   rdi, [rdi+rcx*8]          ; Offset to destination base addr
        lea   rsi, [rsi+rcx*8]          ; Offset to source base addr
        neg   rcx                       ; Create negative count

        shr   r9, 1                     ; Shift count right
        jnc   omvl1                     ; Branch if no carry

        mov   rbx, [rsi+rcx*8]          ; Get first quad
        mov   [rdi+rcx*8], rbx          ; Move first quad
        add   rcx, 1                    ; One quad
        jnz   omvl1
        jmp   obmve

omvl1:  ssopm 2, -shcnt, dpokm
        jmp   obmve

; Move quads starting at higher address.

omvh0:  shr   r9, 1                     ; Shift count right
        jnc   omvh1                     ; Branch if no carry

        mov   rax, [rsi+rcx*8-8]        ; Get first quad
        mov   [rdi+rcx*8-8], rax        ; Move to destination
        sub   rcx, 1                    ; One quad
        jnz   omvh1
        jmp   obmve

omvh1:  ssopm 2, shcnt, dmovm

obmve:  nextm
datam

; ?forthxflags - Push forthx flag quad to stack

head    "?forthxflags", oupo
qfflgs: dq  qffl0
textm
qffl0:  mov   rax, [flgs0]
        sub   r14, 8
        mov   [r14], rax
        nextm
datam

; bye - exit the program

head    "bye", hlfo
bye:    dq  docl0
        dq  tata,semis

; ipt-home - Set input terminator character to the Home key.

head    "ipt-home"
ipthm:  dq  ipho0
textm
ipho0:  bts   qword[flgs0], 12          ; Set ipt flag
        nextm
datam

; ipt-enter - Set input terminator character to the Enter key (default).

head    "ipt-enter"
iptnt:  dq  ipnt0
textm
ipnt0:  btr   qword[flgs0], 12          ; Clear ipt flag
        nextm
datam

; Processor-Specific Functions

; ?cpuid - Return the cpuid result from rax, rbx, rcx, and rdx when passed
; the function number.

head    "?cpuid"
qcpuid: dq  qcpu0
textm
qcpu0:  mov   rax, [r14]
        cpuid
        mov   [r14], rax
        sub   r14, 24
        mov   [r14+16], rbx
        mov   [r14+8], rcx
        mov   [r14], rdx
        nextm
datam

; ?cpuflags - Put rFLAGS quadword on the stack.

head    "?cpuflags"
qcpufs: dq  qcpf0
textm
qcpf0:  sub   r14, 8
        pushfq
        pop   qword[r14]
        nextm
datam

; getrsp - Get value of processor stack pointer.

head    "getrsp"
getrsp: dq  grsp0
textm
grsp0:  sub   r14, 8                    ; Get processor stack pointer
        mov   [r14], rsp
        nextm
datam

; Timing Functions

; ?tsc - Read Time Stamp Counter.
; Uses the serializing variant of the rdtsc instruction.

head    "?tsc"
qtsc:   dq  qtsc0
textm
qtsc0:  sub r14, 8                      ; Clear stack space for timing
        rdtscp
        mov   dword[r14], eax
        mov   dword[r14+4], edx
        nextm
datam

; show-regs ( addr --- ) - Output table of register and flag data at addr.
; The register data is expected to be ordered as rax-r15, rip, rFLAGS.
; This version displays the registers in two columns.

head    "show-regs", hlfo
shrgs:  dq  docl0
        dq  one,ckstk
        dq  base,qat,toa,hex
        dq  dupl,qat,cr
        pdtqm "rax=0x"
        dq  lit,16,udotlz,space,space
        dq  eighp,dupl,qat
        pdtqm "rbx=0x"
        dq  lit,16,udotlz
        dq  eighp,dupl,qat,cr
        pdtqm "rcx=0x"
        dq  lit,16,udotlz,space,space
        dq  eighp,dupl,qat
        pdtqm "rdx=0x"
        dq  lit,16,udotlz
        dq  eighp,dupl,qat,cr
        pdtqm "rsi=0x"
        dq  lit,16,udotlz,space,space
        dq  eighp,dupl,qat
        pdtqm "rdi=0x"
        dq  lit,16,udotlz
        dq  eighp,dupl,qat,cr
        pdtqm "rbp=0x"
        dq  lit,16,udotlz,space,space
        dq  eighp,dupl,qat
        pdtqm "rsp=0x"
        dq  lit,16,udotlz
        dq  eighp,dupl,qat,cr
        pdtqm "r8 =0x"
        dq  lit,16,udotlz,space,space
        dq  eighp,dupl,qat
        pdtqm "r9 =0x"
        dq  lit,16,udotlz
        dq  eighp,dupl,qat,cr
        pdtqm "r10=0x"
        dq  lit,16,udotlz,space,space
        dq  eighp,dupl,qat
        pdtqm "r11=0x"
        dq  lit,16,udotlz
        dq  eighp,dupl,qat,cr
        pdtqm "r12=0x"
        dq  lit,16,udotlz,space,space
        dq  eighp,dupl,qat
        pdtqm "r13=0x"
        dq  lit,16,udotlz
        dq  eighp,dupl,qat,cr
        pdtqm "r14=0x"
        dq  lit,16,udotlz,space,space
        dq  eighp,dupl,qat
        pdtqm "r15=0x"
        dq  lit,16,udotlz
        dq  eighp,dupl,qat,cr
        pdtqm "rip=0x"
        dq  lit,16,udotlz
        dq  eighp,qat,dtfg
        dq  froma,base,stor,semis

; show-xmms ( addr --- ) - Output table of xmm registers saved at addr
; in a single column. The output is always in hexadecimal regardless
; of the current base setting. The address will usually be sxmm0.

; : show-xmms   1 ckstk base @ >a dec 16 0 do cr ." xmm" i dup ..
;             10 < if ."  = " else ." = " then dup 2@ 2hex. 16 +
;             loop drop a> base ! ;

head    "show-xmms", hlfo
shxms:  dq  docl0
        dq  one,ckstk
        dq  base,qat,toa,deci
        dq  lit,16,zero,ddo,shxms4
shxms1: dq  cr
        pdtqm "xmm"
        dq  indx,dupl,dotper
        dq  lit,10,less,zbran,shxms2
        pdtqm "  = "
        dq  bran,shxms3
shxms2: pdtqm " = "
shxms3: dq  dupl,dqat,thxdt,lit,16,plus
        dq  _loop,shxms1
shxms4: dq  drop,froma,base,stor,semis

; show-ymms ( addr --- ) - Output table of ymm registers saved at addr
; in a single column. The output is always in hexadecimal regardless
; of the current base setting. The address will usually be symm0.

; : show-ymms   1 ckstk base @ >a dec 16 0 do cr ." ymm" i dup ..
;             10 < if ."  = " else ." = " then dup 4@ 4hex. 32 +
;             loop drop a> base ! ;

head    "show-ymms", hlfo
shyms:  dq  docl0
        dq  one,ckstk
        dq  base,qat,toa,deci
        dq  lit,16,zero,ddo,shyms4
shyms1: dq  cr
        pdtqm "ymm"
        dq  indx,dupl,dotper
        dq  lit,10,less,zbran,shyms2
        pdtqm "  = "
        dq  bran,shyms3
shyms2: pdtqm " = "
shyms3: dq  dupl,qqat,fhxdt,lit,32,plus
        dq  _loop,shyms1
shyms4: dq  drop,froma,base,stor,semis

; Access x87 FPU Status and Control Registers

; fsw> - Put the x87 status word on the stack.

head    "fsw>", fpmo
fswf:   dq  fswf0
textm
fswf0:  xor   rax, rax
        fstsw ax
        sub   r14, 8
        mov   [r14], rax
        nextm
datam

; fcw> - Put the x87 control word on the stack. Requires a place in memory
; to put control word. That's included at fcw0. Two special memory locations
; (fcw0 and fcw0+4) are provided. One for saving and restoring the control
; word when a calculation needs to change it, and another for changing it
; and installing the changed version.

head    "fcw>", fpmo
fcwf:   dq  fcwf0
textm
fcwf0:  fstcw [fcw0]
        sub   r14, 8
        mov   rax, [fcw0]
        mov   [r14], rax
        nextm
datam
fcw0:   dq  0

; >fcw - Pop the entry on top of the stack into the x87 control register.
; Requires a place in memory to put control word. That's included at fcw0.
; Clear exceptions beforehand, after waiting for any pending exceptions.

head    ">fcw", fpmo
fcwt:   dq  fcwt0
textm
fcwt0:  mov   rax, [r14]
        add   r14, 8
        mov   [fcw0], rax
        wait
        fclex
        fldcw [fcw0]
        nextm
datam

; Access MXCSR Register

; mxcsr> ( --- n ) Put the value in mxcsr on the stack.

head    "mxcsr>", dpmo
mxcsf:  dq  mxrf0
textm
mxrf0:  stmxcsr dword[smxs0]
        sub     r14, 8
        mov     rax, [smxs0]
        mov     [r14], rax
        nextm
datam
smxs0:  dq  0

; >mxcsr ( n ---  ) Pop the top stack value into the mxcsr.

head    ">mxcsr", dpmo
mxcst:  dq  mxrt0
textm
mxrt0:  mov     rax, [r14]
        add     r14, 8
        mov     [smxs0], rax
        ldmxcsr dword[smxs0]
        nextm
datam

; Enable Floating-point Exceptions

; fenex - Enable FPU exceptions determined by the mask in fmsk0.
; Exceptions are enabled by setting the relevant bits in the mask.
; Since an exception is enabled by clearing the relevant bit in
; the FPU Control Register, fmsk0 is xored into the FCW mask.
; Only the lower six bits of the mask are relevant. When the mask
; is zero, no exceptions are enabled.

head    "fenex", fpmo
fenex:  dq  fnex0
textm
fnex0:  mov   al, byte[fmsk0]
        fstcw [fcw0]
        xor   byte[fcw0], al
        wait
        fclex
        fldcw [fcw0]
        nextm
datam

; senex - Enable SSE exceptions determined by the mask in smsk0.
; Exceptions are enabled by setting the relevant bits in the mask.
; Since an exception is enabled by clearing the relevant bit in
; the MXCSR register, smsk0 is shifted and xored into the FCW mask.
; Only the lower six bits of the mask are relevant. When the mask
; is zero, no exceptions are enabled.

head    "senex", fpmo
senex:  dq  snex0
textm
snex0:  xor   rax, rax
        mov   al, byte[smsk0]
        shl   eax, 7
        stmxcsr dword[smxs0]
        xor     [smxs0], eax
        ldmxcsr dword[smxs0]
        nextm
datam

; fpe-nabl - Enable both x87 and MX floating-point exceptions.

head    "fpe-nabl", fpmo
fpeen:  dq  docl0
        dq  fenex,senex,semis

; trap - Interrupt the program.

head    "trap", hsto
trap:   dq  trap0
textm

; Note that int3 compiles a special 1-byte form, CC, while
; int 3 compiles CD03.

trap0:  int3
        nextm
datam

; Construction Zone

; Two words are provided to test code - doit for experimental machine code
; and tryit for high level experimental code.

; doit - A place for testing machine level experimental code.

head    "doit"
doit:   dq  doit0
textm

doit0:

; Code goes here.



; Note: Before changing this code see the "ptrace Quick Start Example"
; and "The show-regs Operator" in the Documentation folder.

        mov   rax, 1
        mov   rbx, 2
        mov   rcx, 3
        mov   rdx, 4
        mov   rsi, 5
        mov   rdi, 6
        mov   rbp, 7
        mov   r8,  8
        mov   r9,  9
        mov   r10, 10
        mov   r11, 11

        saveregsm regs0
        saveregsm regs1
;        int3
        nextm
datam

; tryit - high level experimental code

head    "tryit", hlfo
tryit:  dq  docl0

; Code goes here

        dq  semis

; OS Dependent Code

; ***************** Operating System Interface *****************

; ********** External Declarations

; C Functions

; Event Handling

    extern  sigaction, sigemptyset, __sigsetjmp, siglongjmp

; termios Functions

    extern  tcgetattr, tcsetattr, tcflush

; Memory Functions

    extern  malloc, free

; Time Functions

    extern  sleep

; Error Handling Functions

    extern  strerror

; Miscellaneous Functions

    extern  system

; C Symbolic Constants

    extern  sdin, sdout, sderr

    extern  o_rdonly, o_wronly, o_rdwr
    extern  o_creat, o_trunc, o_append
    extern  seek_set, seek_cur, seek_end

    extern  sigint, sigsegv, sigstop
    extern  sigtstp, sigwinch, sigfpe

    extern  sa_resethand, sa_restart, sa_nodefer
    extern  sa_siginfo, sa_onstack

    extern  tiocgwinsz, fionread, tcsaflush, tciflush

    extern  brkint, icrnl, ixon, opost, cs8
    extern  icanon, echo, iexten, isig

; Sigaction Flags

addrerr_flags equ sa_siginfo
winch_flags   equ sa_restart
fpe_flags     equ sa_siginfo
int_flags     equ sa_restart

; I/O Macros

; C Function Call Macro. Takes the function as parameter.
; Newer versions of the Linux kernel require that 16-byte
; alignment of the system stack be preserved by subtracting
; 8 from the stack pointer before the call and adding it back
; afterward.

%macro  CFCm  1

        sub   rsp, 8

        call  %1

        add   rsp, 8

%endmacro

; C Funtion Call Macro with Error Handling

%macro  CFCErrm 1

        sub   rsp, 8

        call  %1

        add   rsp, 8
        bt    rax, 63                   ; Check for error
        jnc   %%noerr                   ; Branch if OK

        throwm 58                       ; C-function error

%%noerr:

%endmacro

; Equates for Linux System Call Numbers

sys_read          equ 0
sys_write         equ 1
sys_open          equ 2
sys_close         equ 3
sys_stat          equ 4
sys_lseek         equ 8
sys_ioctl         equ 16
sys_select        equ 23
sys_getpid        equ 39
sys_exit          equ 60
sys_kill          equ 62
sys_ftruncate     equ 77
sys_rename        equ 82
sys_unlink        equ 87
sys_gettimeofday  equ 96
sys_ptrace        equ 101
sys_waitid        equ 247
sys_getrandom     equ 318

; Operating System Call macro. Takes the function name as parameter.

%macro  OSCm  1

        mov   rax, sys_ %+ %1

        syscall

%endmacro

; Operating System Call macro with error handling.

%macro  OSCErrm 1

        mov   rax, sys_ %+ %1

        syscall

        bt    rax, 63                   ; Check for error
        jnc   %%noerr                   ; Branch if OK
        neg   rax
        mov   [errn0], rax

        throwm 59                       ; Throw OS error

%%noerr:

%endmacro

; Headerless OS Code

; Since this headerless code is placed in the dictionary in order to have all OS
; related code in the same place in the listing, it is given its own header to
; distinguish it from other dictionary objects. The word, OSCode, returns the address
; of the 1st code object's link field.

head    "OSCode", hcdo, hidden
oscode: dq  oscd0
textm
oscd0:  lea   rdx, [r11+8]              ; Get address of 1st code object
        sub   r14, 8                    ; Push it to stack
        mov   [r14], rdx
        nextm
datam

; Signal Handlers

; sigwinch - Signal handler for SIGWINCH (window size change)
; If in `strin`, set system flag #31 and reset window height and width.
; If there is a line, calculate the number of rows in the new
; window dimensions and the length of the last row, and install
; them in `strin`'s stack frame. Save old line parameters.
; If not in `strin`, simply return.
; Note that the contents of r9 and r10 could get trashed. To refer
; to the line length and cursor pointer, use the values saved in the
; `strin` stack frame by strinOSCm.

namem   "sigwinch"
sgwnch: dq  sgwn0
txtnm
sgwn0:  bt   qword[flgs0], 18           ; Test strin flag

; If not in `strin`, return.

        jnc   sgwn4

; If in strin, set SIGWINCH flag.

        bts   qword[flgs0], 31          ; Set system flag #31
        btr   qword[r15], 8             ; Clear winsize flag

        sub   r14, 8                    ; Put structure on stack
        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tiocgwinsz]
        mov   rdx, r14

        OSCm  ioctl

        movzx rax, word[r14]
        movzx rbx, word[r14+2]

        add   r14, 8                    ; Restore the stack

; Save old line parameters.

        lea   rsi, [hght0]
        lea   rdi, [hght1]
        mov   rcx, [rsi]                ; Window height
        mov   [rdi], rcx
        mov   rcx, [rsi+8]              ; Window width
        mov   [rdi+8], rcx
        mov   rcx, [rsi+16]             ; Window area
        mov   [rdi+16], rcx
        mov   rcx, [rsi+24]             ; Cursor y
        mov   [rdi+24], rcx
        mov   rcx, [rsi+32]             ; Cursor x
        mov   [rdi+32], rcx
        mov   rcx, [rsi+40]             ; Line y
        mov   [rdi+40], rcx
        mov   rcx, [rsi+48]             ; Line x
        mov   [rdi+48], rcx
        mov   rcx, [rsi+56]             ; Anchor y
        mov   [rdi+56], rcx

; Set new parameters.

        mov   [hght0], rax              ; Set new terminal height
        mov   [wdth0], rbx              ; Set new terminal width
        mul   rbx                       ; Calculate area
        mov   [area0], rax              ; Set new area

; Set winsize flag if size has increased.

        cmp   rax, [area1]
        jc    sgwn1

        bts   qword[r15], 8             ; Set winsize flag

sgwn1:  cmp   qword[r12-8], 0           ; See if line length is zero
        jz    sgwn4                     ; Return if so

; Calculate number of line rows and length of last row.

        mov   rax, [r12-8]              ; Get line length

; Note: rdx is already 0 from the multiplication.

;        xor   rdx, rdx

        div   rbx                       ; Divide by window width

; If the remainder is not zero, increment the quotient. If the
; remainder is zero, and the cursor is at the end of the line,
; leave the last row length at zero and increment the quotient.
; If the cursor is not at the end of the line, set the last row
; length to the window width and do not increment the quotient.

        cmp   rdx, 0                    ; See if remainder is 0
        jnz   sgwn2                     ; Branch to increment quotient

        mov   rcx, [r15+72]             ; Get cursor pointer
        cmp   [r15+80], rcx             ; See if cursor at end
        jc    sgwn2                     ; Branch to increment quotient

        mov   rdx, rbx                  ; Set last row to window width
        jmp   sgwn3                     ; Do not increment quotient

sgwn2:  add   rax, 1                    ; Increment quotient

; Install new line specification.
; The line specification tells how many rows the line requires in the current
; window width, including the last row, which may be shorter than the previous
; rows. A special case occurs when a line ends with a full row and the cursor
; is at the end. Since there is no place to contain it, the cursor is put at
; the beginning of the row below, all by itselt.

sgwn3:  mov   [r15+88], rax             ; Install line rows
        mov   [r15+96], rdx             ; Install remainder

sgwn4:  ret

datam

; Signal handler for SIGSEGV (address error)
; The sigaction process places the base address of the siginfo_t structure
; in rsi. The address where the error occurred is at offset 16 from the base
; address. This is placed in the addrerr system variable.

namem   "sigsegv"
sgsgv:  dq    sgsg0
txtnm
sgsg0:  mov   rbx, [rsi+16]
        mov   [ader0], rbx
        lea   rdi, [sigbuf0]
        mov   rsi, 1

        CFCm  siglongjmp

datam

; Signal handler for SIGFPE (floating-point exception)
; Note that the value of 1 in rsi restores the process
; signal mask from sigbuf1.

namem   "sigfpe"
sgfpe:  dq    sgfp0
txtnm
sgfp0:  xor   rbx, rbx
        mov   ebx, dword[rsi+8]
        mov   [fpex0], rbx

; Reset FPU stack pointer

        btr   word[flgs0+4], 0
        btr   word[flgs0+4], 1
        btr   word[flgs0+4], 2
        btr   word[flgs0+4], 3

        lea   rdi, [sigbuf1]
        mov   rsi, 1

        CFCm  siglongjmp

datam

; Signal handler for SIGINT (Ctrl+C interrupt)
; Disallow interrupt while waiting for keyboard input (whenever the strin flag
; is set). Otherwise restore the Callee Saved registers and exit the program.

namem   "sigint"
sgint:  dq    sgnt0
txtnm
sgnt0:  bt    qword[flgs0], 18          ; Test strin flag
        jc    sgnt1                     ; Branch if flag is set

; Restore Callee Saved registers.

        lea   rdi, [cale0]
        mov   r15, [rdi]
        mov   r14, [rdi+8]
        mov   r13, [rdi+16]
        mov   r12, [rdi+24]
        mov   rbp, [rdi+32]
        mov   rbx, [rdi+40]

        mov   rdi, 0

        OSCm  exit

sgnt1: 

        ret

datam

; Signal handler for SIGTSTP (Ctrl+Z interrupt)
; Disallow interrupt while waiting for keyboard input (whenever the strin flag
; is set). Otherwise stop the program.

namem   "sigtstp"
sgstp:  dq    sgst0
txtnm
sgst0:  bt    qword[flgs0], 18          ; Test strin flag
        jc    sgst1                     ; Branch if flag is set


; Send the stop signal to this process.

        OSCm  getpid

        mov   rdi, rax
        mov   rsi, [sigstop]

        OSCm  kill

sgst1:

        ret
datam

namem   '(.")'
pdotq:  dq  pdtq0
txtnm
pdtq0:  mov   rbx, [r12]                ; Get string length
        add   r12, 8                    ; Offset past length
        mov   r11, r12                  ; Copy addr of string
        mov   rcx, rbx                  ; Copy length
        and   rcx, 7                    ; Calculate offset past string
        jz    pdtq1                     ; No additional bytes
        neg   rcx
        add   rcx, 8
        add   r12, rcx
pdtq1:  add   r12, rbx                  ; Advance IP past string

        mov   r9, [curx0]               ; Get cursor position
        add   r9, rbx                   ; Add string length
        cmp   [wdth0], r9               ; Compare with terminal width
        jnc   pdtq3                     ; Branch if not larger

        mov   rax, r9                   ; Copy curcol + string length
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by terminal width
        mov   r9, rdx                   ; Copy new cursor position
        mov   rbp, rax                  ; Save number of lines

        mov   rax, [cury0]              ; Get current row
        add   rax, rbp                  ; Add number of new lines
        cmp   [hght0], rax              ; Compare with screen height
        jnc   pdtq2                     ; Branch if not larger

        mov   rax, [hght0]              ; Use height for y-coordinate

pdtq2:  mov   [cury0], rax              ; Install new y-coordinate

pdtq3:  mov   [curx0], r9               ; install new x-coordinate

; Write string.

        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r11                  ; Address of string
        mov   rdx, rbx                  ; Length of string

        OSCm  write

        nextm
datam

; qtotq - headerless code used for precompiled strings when
; it is undesirable for them to wrap at the end of the line.

namem   '?."'
qdotq:  dq  qdtq0
txtnm
qdtq0:  mov   rbp, [r12]                ; Get string length
        cmp   [wdth0], rax              ; Compare with teminal width
        jc    qdtq3                     ; Error if greater

        add   r12, 8                    ; Offset past length
        mov   r11, r12                  ; Copy addr of string
        mov   rcx, rbp                  ; Copy length
        and   rcx, 7                    ; Calculate offset past string
        jz    qdtq1                     ; No additional bytes
        neg   rcx
        add   rcx, 8
        add   r12, rcx
qdtq1:  add   r12, rbp                  ; Advance IP past string

        mov   rbx, [curx0]              ; Get cursor position
        add   rbx, rbp                  ; Add string length
        cmp   [wdth0], rbx              ; Compare with terminal width
        jg    qdtq4                     ; Branch if not greater

; Output newline.

        mov   rbx, rbp                  ; Copy for new cursor position
        sub   r15, 8                    ; Make room on return stack
        mov   qword[r15], 10            ; Install newline character
        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r15                  ; Address of string
        mov   rdx, 1                    ; One character

        OSCm  write

        add   r15, 8                    ; Pop return stack

        mov   rcx, [cury0]              ; Get cursor row
        add   rcx, 1                    ; Add 1 for newline
        cmp   [hght0], rcx              ; Compare with screen height
        jnc   qdtq2                     ; Branch if not larger

        mov   rcx, [hght0]              ; Use height for current row

qdtq2:  mov   [cury0], rcx              ; Update row

        jmp   qdtq4

qdtq3:  mov   qword[curx0], 1           ; Reset cursor position

        throwm 70                       ; Throw error

qdtq4:  mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r11                  ; Address of string
        mov   rdx, rbp                  ; Length of string

        OSCm  write

        mov   [curx0], rbx              ; Install new cursor position

        nextm
datam

; shell - Execute the command whose address is on the stack

namem   "shell"
shell:  dq  shll0
txtnm
shll0:  mov   rdi, [r14]                ; Get address of command string
        add   r14, 8                    ; Pop the stack

        CFCErrm system

        nextm
datam

; tata - Restore Callee Saved registers and exit the program.

namem   "tata"
tata:   dq  tata0
txtnm
tata0:  lea   rdi, [cale0]
        mov   r15, [rdi]
        mov   r14, [rdi+8]
        mov   r13, [rdi+16]
        mov   r12, [rdi+24]
        mov   rbp, [rdi+32]
        mov   rbx, [rdi+40]

        mov   rdi, 0

        OSCm  exit

datam

; init - initialize system.

namem   "init"
init:   dq  init0
txtnm
init0:

; Install bic# for nob, nib, hld, and return stack.

        mov   rax, bicna                ; Get bic# in two parts
        mov   rbx, bicnb
        lea   rdi, [nob0-16]            ; Install for nib
        mov   [rdi], rax
        mov   [rdi+8], rbx
        lea   rdi, [hld0-16]            ; Install for nob
        mov   [rdi], rax
        mov   [rdi+8], rbx
        lea   rdi, [rstack0-rstksz*8-16]  ; Install for hld and return stack
        mov   [rdi], rax
        mov   [rdi+8], rbx

; To prevent loading the startup file, remove the comment from the following
; line of code.

;        bts   qword[flgs0], 0

; Initialize signal handlers.

; Initialize SIGWINCH handler.

        lea   rbx, [stsgw0]             ; Get address of structure
        lea   rbp, [sgwn0]              ; Get address of handler
        mov   [rbx], rbp                ; Install handler address
        lea   rdi, [rbx+8]

        CFCm  sigemptyset

; Note that rapid window size change will crash the system with a segmentation
; fault if the SA_RESTART and SA_RESETHAND flags are not set.

        mov   rdi, [sigwinch]
        mov   rsi, rbx
        xor   rdx, rdx
        mov   rax, [winch_flags]
        mov   [rbx+136], rax

        CFCm  sigaction

; Initialize SIGSEGV handler.

        lea   rbx, [stsgv0]             ; Get address of structure
        lea   rbp, [sgsg0]              ; Get address of handler
        mov   [rbx], rbp
        lea   rdi, [rbx+8]

        CFCm  sigemptyset

        mov   rdi, [sigsegv]
        mov   rsi, rbx
        xor   rdx, rdx
        mov   rax, [addrerr_flags]
        mov   [rbx+136], rax

        CFCm  sigaction

; Arrange for siglongjmp in the handler to throw 63
; on address error.
; Note that the value in rsi determines whether the process
; signal mask is saved in the sigbuf0 structure and restored
; by siglongjmp. If zero, the mask is not saved and restored,
; so it may as well be 1.

        lea   rdi, [sigbuf0]
        mov   rsi, 1

        CFCm  __sigsetjmp

        cmp   rax, 0
        jz    sigsg1

        throwm 63

sigsg1:

; Initialize SIGFPE handler.

        lea   rbx, [stfpe0]             ; Get address of structure
        lea   rbp, [sgfp0]              ; Get address of handler
        mov   [rbx], rbp
        lea   rdi, [rbx+8]

        CFCm  sigemptyset

        mov   rdi, [sigfpe]
        mov   rsi, rbx
        xor   rdx, rdx
        mov   rax, [fpe_flags]
        mov   [rbx+136], rax

        CFCm  sigaction

; Arrange for siglongjmp in the handler to save
; the floating-point exception mask.

        lea   rdi, [sigbuf1]
        mov   rsi, 1

        CFCm  __sigsetjmp

        cmp   rax, 0
        jz    sigfp1

        throwm 133

sigfp1:

; Initialize SIGINT handler.

        lea   rbx, [stint0]             ; Get address of structure
        lea   rbp, [sgnt0]              ; Get address of handler
        mov   [rbx], rbp
        lea   rdi, [rbx+8]

        CFCm  sigemptyset

        mov   rdi, [sigint]
        mov   rsi, rbx
        xor   rdx, rdx
        mov   rax, [int_flags]
        mov   qword[rbx+136], rax

        CFCm  sigaction

; Initialize SIGTSTP handler.

        lea   rbx, [ststp0]             ; Get address of structure
        lea   rbp, [sgst0]              ; Get address of handler
        mov   [rbx], rbp
        lea   rdi, [rbx+8]

        CFCm  sigemptyset

        mov   rdi, [sigtstp]
        mov   rsi, rbx
        xor   rdx, rdx
        mov   qword[rbx+136], 0

        CFCm  sigaction

; Initialize terminal width, height, and area.

        sub   r14, 8
        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tiocgwinsz]
        mov   rdx, r14

        OSCm  ioctl

        movzx rax, word[r14]            ; Get new terminal height
        movzx rbx, word[r14+2]          ; Get new terminal width

        add   r14, 8

        mov   [hght0], rax              ; Set new terminal height
        mov   [wdth0], rbx              ; Set new terminal width
        mul   rbx                       ; Calculate area
        mov   [area0], rax              ; Set new area

; Output intro string.

        mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [intro0+8]           ; Address of string
        mov   rdx, [rsi-8]              ; Length of string

        OSCm  write

; Output license and disclaimer

    ;   mov   rdi, [sdout]              ; Standard handle
    ;   lea   rsi, [license0+8]         ; Address of string
    ;   mov   rdx, [rsi-8]              ; Length of string
    ;   OSCm  write

        nextm
datam

; Last named headerless code.

cdlnk0:

; ifinit - Set the system initialization flag and return TRUE if it was set,
; else return FALSE.

namem   "ifinit"
ifinit: dq  ifnt0
txtnm
ifnt0:  bts    qword[flgs0], 0          ; Test/set initialization flag
        setc  dl
        neg   dl
        movsx rdx, dl
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; End of headerless system code

; syserr - ( --- ) Output error string associated with the error
; number in errn0.

head    "syserr", oupo, hidden
syser:  dq  syse0
textm
syse0:  mov   rdi, [errn0]              ; Get system error#

        CFCm  strerror                  ; Get error address

        mov   rsi, rax                  ; Copy string address

; Scan for null while counting characters in string

        xor   rdx, rdx                  ; Initialize counter
syse1:  cmp   byte[rsi+rdx], 0          ; Check for null
        jz    syse2
        add   rdx, 1
        jmp   syse1

syse2:  mov   rdi, [sdout]              ; Standard handle

        OSCm  write

        nextm
datam

; fperr - ( --- ) Output floating-point exception type associated
; with the number in fpex0.

head    "fperr", oupo, hidden
fperr:  dq  fper0
        dq  fper1,fper2,fper3,fper4,fper5,fper6,fper7,fper8
textm

; Jump table routine for fperr.

fper0:  mov   rdx, [fpex0]              ; Get index
        mov   r11, [r11+rdx*8+8]        ; Get corresponding vector
        jmp   [r11]
datam

fper1:  dq  docl0
        pdtqm "no error reported"
        dq  semis

fper2:  dq  docl0
        pdtqm "integer divide by zero"
        dq  semis

fper3:  dq  docl0
        pdtqm "integer overflow"
        dq  semis

fper4:  dq  docl0
        pdtqm "divide by zero"
        dq  semis

fper5:  dq  docl0
        pdtqm "overflow"
        dq  semis

fper6:  dq  docl0
        pdtqm "underflow"
        dq  semis

fper7:  dq  docl0
        pdtqm "inexact result"
        dq  semis

fper8:  dq  docl0
        pdtqm "invalid operation"
        dq  semis

; Display the Forthx64 license.

head    "license", gdeo
licns:  dq  lcns0
textm
lcns0:  mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [license0+8]         ; Address of string
        mov   rdx, [rsi-8]              ; Length of string

        OSCm  write

        nextm
datam

; *** Terminal Input

; strin - ( --- ) Line input function for Gnome Terminal with Rewrap on resize enabled.

; Rstack frame usage:

;   [r15+112] - cursor x during freeze
;   [r15+104] - cursor y during freeze
;   [r15+96]  - current length of last line row
;   [r15+88]  - current number of line rows
;   [r15+80]  - temporary for r10
;   [r15+72]  - temporary for r9
;   [r15+64]  - r13
;   [r15+56]  - r12
;   [r15+48]  - Number of characters to write when scrolling
;   [r15+40]  - buffer scroll position
;   [r15+32]  - Initial buffer scroll address
;   [r15+24]  - FIONREAD return value, saved cursor location / scratch
;   [r15+16]  - upper 8 bytes of special I/O buffer
;   [r15+8]   - lower 8 bytes of special I/O buffer
;   [r15]     - flags

; Register usage

;   r13 - pre-buffer base address
;   r12 - buffer base address
;   r11 - scratch
;   r10 - line length
;   r9  - cursor location (pointer into buffer)
;   r8  - scratch
;   rbp - return address from subroutines
;   rdi - scratch / addressing
;   rsi - scratch / addressing
;   rdx - scratch index / division
;   rcx - scratch / counter
;   rbx - scratch
;   rax - scratch / division / multiplication

; Flags:

; 0 - 1st pass
;  Determines whether to clear the buffer at the start of editing.
; The first thing strin does when invoked is to advance to the next
; tib in the chain. Although it may contain text, this buffer is
; presented as a fresh empty buffer, and as soon as text is pasted,
; or a printable character is typed in, it is cleared, and the contents
; replaced with the new text. That is, if the 1st pass flag is clear.
; The flag is set when editing begins. The Down Arrow key, however,
; will display the current line and set the 1st pass flag.

; 1 - buffer full
;  If newly entered text won't fit in the buffer, this bit is set.
; As long as it is set, the keyboard will not respond to printable
; ASCII input. It will be cleared when the current line is edited
; to fit, or when the buffer is abandoned. If the buffer is not full,
; but would be if received text were pasted into it, the paste is
; simply refused. The flag will be set, the input routine will loop
; and discover that the buffer is not full, then clear the flag.
; Square one.

; 2 - cursor relocation
;  Used to signal that the cursor must be relocated after writing text.
; If the last row of entered text is the same width as the window,
; the cursor must be placed in column 1 of the following row, since
; there is otherwise no place to display it.

; 3 - linefeed
;  Used to signal that a linefeed must be output after writing text.
; If the last row of entered text is the same width as the window and
; happens to be the bottom row, the cursor cannot be placed outside
; the window, so a linefeed is must be output before relocating it.

; 4 - rewrite
;  Set by bksp0 when the cursor is not at the end of the line as a signal
; to rewite the line from the cursor after moving the cursor back, shifting
; the characters past the cursor to the left, and replacing the last character
; with a null.

; 5 - freeze
; Reducing the size of the window while editing a line that does not fit
; the new window or is partially obscured will result in the keyboard
; functions rendered inactive so that no further editing or buffer switching
; is possible, and this flag is set. It is cleared the when window is
; restored to maximized state.

; 6 - big-line
; Set when line is too big for the window. Indicates that the Ctrl+Up/Down
; Arrow combination is active, allowing scrolling within the line.
; When the line is scrolled, the current scroll number is put in r15+40.

; 7 - top
; Set when the top of the line is reached while scrolling.

; 8 - winsize
; Set by `sigwinch` to indicate that window size has increased.
; Cleared if window size has decreased.

; 9 - scroll
; Set when scrolling is in progress.

; 10 - transition
; Set when a line that was too big for the window can now be accommodated
; due to a window size increase.

; 11 - page-scroll
; This short-lived flag is set to notify bfup0 or bfdn0 that page-scrolling is
; indicated by Ctrl+PageUp or Ctrl+PageDown keypress. It is cleared when tested. 

; Special macros for strin

; Macro to preserve and restore registers r9 and r10 for C-calls in strin.
; Takes the C-call as a parameter.

%macro  strinCFCm 1

        mov   [r15+72], r9
        mov   [r15+80], r10
        sub   rsp, 8

        call  %1

        add   rsp, 8
        mov   r9, [r15+72]
        mov   r10, [r15+80]

%endmacro

; Operating System Call macro to preserve and restore registers r9 and r10
; in strin. Takes the function name as a parameter.

%macro  strinOSCm 1

        mov   [r15+72], r9
        mov   [r15+80], r10
        mov   rax, sys_ %+ %1

        syscall

        mov   r9, [r15+72]
        mov   r10, [r15+80]

%endmacro

; Special Macro for Calling select in strin. The Linux syscall must pass
; a null in r10.

%macro  strinselectm 0

        mov   [r15+72], r9
        mov   [r15+80], r10
        xor   r10, r10
        mov   rax, sys_select

        syscall

        mov   r9, [r15+72]
        mov   r10, [r15+80]

%endmacro

head    "strin", inpo
strin:  dq  strn0
textm
strn0:  sub   r15, 120                  ; Create rstack frame

; Initialize return stack frame to zero.

        mov   qword[r15], 0             ; Flags
        mov   qword[r15+8], 0           ; Low 8 bytes of I/O
        mov   qword[r15+16], 0          ; High 8 bytes of I/O
        mov   qword[r15+24], 0          ; FIONREAD return value
        mov   qword[r15+32], 0          ; Initial buffer scroll address
        mov   qword[r15+40], 0          ; Buffer scroll position
        mov   qword[r15+48], 0          ; Number of characters for scroll
        mov   qword[r15+56], 0          ; r12
        mov   qword[r15+64], 0          ; r13
        mov   qword[r15+72], 0          ; Temporary for r9
        mov   qword[r15+80], 0          ; Temporary for r10
        mov   qword[r15+88], 0          ; Temporary for L/W quotient
        mov   qword[r15+96], 0          ; Temporary for L/W remainder
        mov   qword[r15+104], 0         ; Cursor y during freeze
        mov   qword[r15+112], 0         ; Cursor x during freeze

        mov   [r15+56], r12             ; Free up r12
        mov   [r15+64], r13             ; Free up r13

        bts   qword[flgs0], 18          ; Set strin flag

        lea   r13, [kip0]               ; Load pre-buffer address
        mov   r12, [srce0]              ; Get src
        mov   r12, [r12-48]             ; Get link to following buffer
        mov   [srce0], r12              ; Store in src
        mov   [ctmb0], r12              ; Store in ctib

; Initialize character count and cursor pointer.

        xor   r10, r10
        mov   r9, 1

; Set terminal to raw mode.

        lea   rbx, [trmio0]             ; Address of original structure
        lea   rbp, [trmin0]             ; Address of new structure

; Save attribute state at termio0.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, rbx

        strinCFCm  tcgetattr

; Copy attribute state to new structure at trmin0.

        mov   rdi, rbp
        mov   rsi, rbx
        mov   rcx, 8                    ; Save 8 quads
strn1:  mov   rax, [rsi+rcx*8-8]
        mov   [rdi+rcx*8-8], rax
        sub   rcx, 1
        jnz   strn1

; Clear c_iflag bits BRKINT, ICRNL, and IXON. The c_iflag bitmask is at offset
; 0 in the termios structure.

        mov   eax, [brkint]             ; Clear BRKINT bit
        not   eax
        and   [rbp], eax

        mov   eax, [icrnl]              ; Clear ICRNL bit
        not   eax
        and   [rbp], eax

        mov   eax, [ixon]               ; Clear IXON bit
        not   eax
        and   [rbp], eax

; Clear c_oflag bit OPOST. The c_oflag bitmask is at offset 4 in the termios
; structure.

        mov   eax, [opost]              ; Clear OPOST bit
        not   eax
        and   [rbp+4], eax

; Set c_cflag for CS8 (default). The c_cflag bitmask is at offset 8
; in the termios structure.

        mov   eax, [cs8]                ; Set CS8 bitmask
        or    [rbp+8], eax

; Clear c_lflag bits ICANON, ECHO, and IEXTEN. Set ISIG (default).
; The ISIG bit controls whether Ctrl+C, Ctrl+Z, and Ctrl+\ are active.
; The c_lflag bitmask is at offset 12 in the termios structure.

        mov   eax, [icanon]             ; Clear ICANON bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [echo]               ; Clear ECHO bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [iexten]             ; Clear IEXTEN bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [isig]               ; Set ISIG bit
        or    [rbp+12], eax

; Variables VMIN and VTIME in the c_cc array should be set to 1 and 0
; respectively, but these are the default settings with ICANON disabled.

; Set new attribute state after flushing by setting the second parameter
; to TCSAFLUSH (2).

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        mov   rdx, rbp

        strinCFCm  tcsetattr

; Initialize cursor coordinates, anchor y, and line coordinates.
; Cursor x remains as it is on entry. If it's not what it should be,
; there would certainly be obvious trouble.

        lea   rbp, [strn2]              ; Set return address
        jmp   gtcc0                     ; Get cursor coordinates

; strn2  lea   rdi, [regs0]             ; For debugging
;        mov   rax, [curx0]
;        mov   [rdi], rax
;        mov   rbx, [cury0]
;        mov   [rdi+8], rbx
;        mov   rax, [linx0]
;        mov   [rdi+16], rax
;        mov   rbx, [liny0]
;        mov   [rdi+24], rbx
;        mov   rbx, [ancy0]
;        mov   [rdi+32], rbx

strn2:  mov   rax, [cury0]              ; Get cursor y
        mov   [ancy0], rax              ; Initialize anchor y
        mov   [liny0], rax              ; Initialize line y
        mov   qword[linx0], 0           ; Initialize line x
        mov   qword[curx0], 1           ; Initialize cursor x

; Main editing loop.

; Preread - Use select() followed by read() to put keyboard input
; in the pre-buffer until the number of bytes read is less than
; 4095, or the buffer is full.

; Wait for input with select().

; Clear 16 quads of bitmask at selct0+16.

prer0:  mov   rax, 0
        mov   rcx, 16
        lea   rdi, [selct0]
prer1:  mov   [rdi+rcx*8+8], rax
        sub   rcx, 1
        jnz   prer1

        mov   qword[rdi+16], 1          ; Set bitmask for standard input
        xor   r8, r8                    ; Timeout indefinite
        xor   rdx, rdx                  ; No outputs
        lea   rsi, [rdi+16]             ; Address of input bitmask
        mov   rdi, 1                    ; Monitor only one input

        strinselectm

        bt    rax, 63                   ; Test for interrupt
        jnc   prer2                     ; Branch if none

        btr   qword[flgs0], 31          ; Test/clear SIGWINCH flag
        jc    swch0                     ; If flag was set, handle SIGWINCH

        jmp   prer0                     ; Loop on any other interrupt

; If freeze flag is set, flush kib and loop.

prer2:  bt    qword[r15], 5             ; Test freeze flag
        jnc   prer3                     ; Branch if clear

        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, [tciflush]

        strinCFCm  tcflush              ; Flush kib

        jmp   prer0                     ; Loop

; Read input into pre-buffer.

prer3:  mov   rdi, [sdin]               ; Standard handle
        mov   rsi, r13                  ; Where to put line
        mov   rdx, 4095                 ; Get the maximum

        strinOSCm  read

        mov   [r13-8], rax              ; Install pre-buffer chr count

; As soon as the number of bytes read is less than 4095, input is finished.
; No need to call select() again.

        cmp   rax, 4095
        jc    prer7

; To avoid buffer overrun, subsequent calls to select() are followed by ioctl()
; with FIONREAD to determine how many characters are in the kib before reading
; them into the pre-buffer.

; Call select() with timeout.

; Clear 16 quads of bitmask at selct0+16.

prer4:  mov   rax, 0
        mov   rcx, 16
        lea   rdi, [selct0]
prer5:  mov   [rdi+rcx*8+8], rax
        sub   rcx, 1
        jnz   prer5

; The select() call blocks until input is available or timeout occurs.

        mov   qword[rdi], 0             ; Set timeout
        mov   qword[rdi+8], 2           ; Try timeout value of 2 microsec

        mov   qword[rdi+16], 1          ; Set bitmask for standard input
        lea   r8, [rdi]                 ; Load address of timeout struct
        xor   rdx, rdx                  ; No outputs
        lea   rsi, [rdi+16]             ; Address of input bitmask
        mov   rdi, 1                    ; Monitor only one input

        strinselectm                    ; select

        cmp   rax, 0                    ; See if timeout occurred
        jz    prer7                     ; If so, finished with input

        bt    rax, 63                   ; Loop on SIGWINCH
        jc    prer4

; Determine how many bytes are in the keyboard input buffer.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [fionread]
        lea   rdx, [r15+24]             ; Place for return value

        strinOSCm  ioctl

        mov   rdx, [r15+24]             ; Get bytes available
        mov   rcx, [r13-8]              ; Get count from pre-buffer
        add   rcx, rdx                  ; Add new input
        cmp   rcx, [r13-16]             ; Compare with pre-buffer capacity
        jc    prer6                     ; Branch if room

; If buffer can't accept input, set buffer-full flag, and flush kib.

        bts   qword[r15], 1             ; Set buffer-full flag

        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, [tciflush]

        strinCFCm  tcflush              ; Flush kib

        jmp   prer0                     ; Loop

; Read input into pre-buffer.

prer6:  mov   rdi, [sdin]               ; Standard handle
        mov   rsi, r13                  ; Where to put line
        add   rsi, [r13-8]              ; Add bytes already read

        strinOSCm  read

        add   [r13-8], rax              ; Add to pre-buffer count

; As soon as the number of bytes read is less than 4095, input is finished.
; No need to call select() again.

        cmp   rax, 4095
        jnc   prer4

; See if input is single character.

prer7:  cmp   qword[r13-8], 1
        jz    chdo0                     ; Take action based on character.

; See if input is escape sequence.

prer8:  cmp   byte[r13], 27
        jz    essq0                     ; Process escape sequence

; Test and set 1st pass flag. If flag was not set, clear terminal input buffer.

        bts   qword[r15], 0
        jc    prer9

        lea   rbp, [prer9]              ; Clear buffer
        jmp   clbf0

; See if terminal input buffer can accommodate input string.

prer9:  mov   rcx, [r12-8]              ; Get tib chr count
        add   rcx, [r13-8]              ; Add kib0 count
        cmp   [r12-16], rcx             ; Compare with buffer capacity
        jnc   prer10                    ; Branch if room

; If buffer can't accept input, set buffer-full flag, flush kib, and loop.

        bts   qword[r15], 1             ; Set buffer-full flag

        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, [tciflush]

        strinCFCm  tcflush              ; Flush kib

        jmp   prer0                     ; Loop

; See if cursor is at the end of the line. If not, move the text following
; the cursor to the right by the number of bytes in the newly pasted string.

prer10: mov   rbp, [wdth0]              ; Get window width
        cmp   r10, r9                   ; See if cursor at end of line.
        jc    apnd1                     ; If so, append

; Insert text into current line.
; The insert is limited to the editable window. If the text won't fit,
; the operation is disallowed by looping.

; If the cursor is in the top row of the line, or the second row if the
; big-line flag is set, and line y is equal to the window height,
; the insertion may produce a scroll.
; If the line scrolls, the cursor will move into the undisplayable portion
; of the line if cursor x is not greater than the difference between the
; remainder of dividing the length of the inserted text by the window width
; and the window width -  cx > W - mod(L/W). If this condition is not met,
; the insertion is disallowed by looping. However, if cursor x is only one
; more than W - mod(L/W), the inserted text won't be visible in the window.
; Likewise in the special case of a zero remainder with the cursor in column 1.
; Nothing appears to have happened, except in the first case the cursor has
; moved to column 1. Both these case are disallowed.
; The other choice would be to move the cursor to the end of the line,
; but this would be jarring to the user.

        bt    qword[r15], 6             ; Test big-line flag
        jnc   insx1                     ; Branch if clear

        cmp   qword[cury0], 2           ; See if cursor y is 2
        jnz   insx4                     ; Branch if not

        jmp   insx2

insx1:  cmp   qword[cury0], 1           ; See if cursor y is 1
        jnz   insx4                     ; Branch if not

insx2:  mov   rcx, [hght0]              ; Get window height
        cmp   rcx, [liny0]              ; Compare line y to height
        jnz   insx4                     ; Branch if not equal

; See if line will scroll.

        mov   rcx, rbp                  ; Copy window width
        sub   rcx, [linx0]              ; Subtract line x

        cmp   rcx, [r13-8]              ; Compare input length
        jnc   insx4                     ; Branch if no scroll

; Calculate W - mod(L/W).

        mov   rax, [r13-8]              ; Get length of inserted text
        xor   rdx, rdx                  ; Zero high order dividend
        div   rbp                       ; Divide by window width
        cmp   rdx, 0                    ; See if remainder is zero
        jnz   insx3                     ; Branch if not

        cmp   qword[curx0], 1           ; See if cursor x is 1
        jz    prer0                     ; Loop if so
        jmp   insx4                     ; Else insert

insx3:  lea   rcx, [rbp+1]              ; Load window width + 1
        sub   rcx, rdx                  ; Subtract remainder from window width
        cmp   rcx, [curx0]              ; See if cursor x is greater
        jnc   prer0                     ; Loop if not

; Calculate how many bytes to move.

insx4:  mov   rcx, r10                  ; Get current line length
        sub   rcx, r9                   ; Subtract cursor location
        add   rcx, 1                    ; Add 1 for char under cursor

; Find source and destination starting addresses.

        lea   rsi, [r12+r9-2]           ; Load source address
        mov   rdx, [r13-8]              ; Get number of bytes in input
        lea   rdi, [rsi+rdx]            ; Load destination address

; Move bytes to the right.

insx5:  mov   al, [rsi+rcx]
        mov   [rdi+rcx], al
        sub   rcx, 1                    ; Decrement counter/index
        jnz   insx5                     ; Loop for input char count

        mov   [r15+24], r9              ; Save former cursor location

; Add input string length to line length, cursor pointer,
; and number of characters in buffer.

apnd1:  add   r10, [r13-8]              ; Update line length
        add   r9, [r13-8]               ; Update cursor location
        mov   [r12-8], r10              ; Update tib character count

; Update line specification. Note that in order to make this apply
; to both inserting and appending, we must consider the case
; of the cursor not at the end, and the quotient not being incremented
; as a result.

        mov   rax, r10                  ; Put line length in dividend
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbp                       ; Divide by display width

; If the remainder is not zero, increment the quotient. If the
; remainder is zero, and the cursor is at the end of the line,
; leave the last row length at zero and increment the quotient.
; If the cursor is not at the end of the line, set the last row
; length to the window width and do not increment the quotient.

        cmp   rdx, 0                    ; See if remainder is 0
        jnz   prer11                    ; Branch to increment quotient

        cmp   r10, r9                   ; See if cursor at end of line.
        jc    prer11                    ; Branch to increment quotient

        mov   rdx, rbp                  ; Set last row to window width
        jmp   prer12                    ; Do not increment quotient

prer11: add   rax, 1                    ; Increment quotient

; Install new line specification. If line is too big for display,
; set the big-line flag (#6). If the line is not too big, clear
; the flag.

prer12: mov   [r15+88], rax             ; Install line rows
        mov   [r15+96], rdx             ; Install length of last row
        cmp   [hght0], rax              ; Compare with height
        jnc   prer13                    ; Branch if line fits

        bts   qword[r15], 6             ; Set big-line flag
        jmp   prer14

prer13: btr   qword[r15], 6             ; Clear big-line flag

; Pass pasted text through filter whereby any embedded control characters
; are changed to spaces.

prer14: lea   rdi, [r12+r9-2]           ; Load addr of end of inserted text
        mov   rcx, [r13-8]              ; Get number of input characters
        sub   rdi, rcx                  ; Subtract from end
        xor   rax, rax                  ; Clear byte register
        lea   rsi, [ascf0]              ; Load address of filter table
prer15: mov   al, [r13+rcx-1]           ; Filter input
        mov   al, [rsi+rax]
        mov   [rdi+rcx], al
        sub   rcx, 1
        jnz   prer15

        jmp   rfra0

; Handle escape sequence

; The sequences are contained in a list preceded by the number of elements.
; Each element consists of the sequence followed the offset into the keyboard
; action table, which returns the index into the jump table of action vectors.
; The list is scanned when the 1st character of the input is ASCII 27 (Escape).
; If the sequence is found, its associated routine is executed. If the sequence
; is not found, a loop back to prer0 is done.

; Test for escape sequences.
;
; Delete          - Esc[3~
; Up-arrow        - Esc[A
; Down-arrow      - Esc[B
; Right-arrow     - Esc[C
; Left-arrow      - Esc[D
; Home            - Esc[H
; Alt+Up-arrow    - Esc[1;3A
; Alt+Down-arrow  - Esc[1;3B
; Ctrl+PageUp     - Esc[5;5~
; Ctrl+PageDown   - Esc[6;5~

; Any escape sequence longer than eight bytes is not legitimate and is ignored.

essq0:  cmp   qword[r13-8], 9           ; See if sequence is 8 bytes or less
        jnc   prer0                     ; Loop if not

        btr   qword[r15], 1             ; Test/clear buffer-full flag
        mov   qword[r15+24], 0          ; Initialize scratch area
        mov   rcx, [r13-8]              ; Copy input character count
essq1:  mov   al, [r13+rcx-1]           ; Copy bytes to scratch
        mov   [r15+rcx+23], al
        sub   rcx, 1
        jnz   essq1

        mov   rbx, [r15+24]             ; Copy sequence
        lea   rsi, [kcod0]              ; Get list address
        mov   rcx, [rsi]                ; Get list count
        add   rsi, 8
essq2:  cmp   [rsi], rbx                ; Compare sequences
        jnz   essq3

        mov   r11, [vtof0]              ; Get offset table address
        mov   rbx, [rsi+8]              ; Get assigned ASCII number
        movzx rdx, byte[r11+rbx]        ; Get offset
        lea   r11, [vtbl0]              ; Get vector table address
        jmp   [r11+rdx*8]               ; Jump to proper routine

essq3:  add   rsi, 16                   ; Move to next sequence
        sub   rcx, 1
        jnz   essq2

        jmp   prer0                     ; Loop if not found

; Take action based on single-character input.

chdo0:  mov   r11, [vtof0]              ; Get offset table address
        movzx rbx, byte[r13]            ; Get character
        movzx rdx, byte[r11+rbx]        ; Get offset

; If character is printable ASCII, test if 1st pass flag is set,
; and if not, clear buffer.

        cmp   rdx, 2                    ; See if printable ASCII
        jnz   chdo2                     ; Branch if not

        bts   qword[r15], 0             ; Test/set 1st pass flag
        jc    chdo1                     ; Branch if flag is set

        lea   rbp, [chdo2]              ; Clear buffer
        jmp   clbf0

; Test if buffer is full.

chdo1:  mov   rcx, r10                  ; Copy character count
        add   rcx, 1                    ; Add number of chrs input
        cmp   [r12-16], rcx             ; Compare with buffer size
        jnc   chdo2                     ; Continue if not full

        bts   qword[r15], 1             ; Set buffer-full flag
        jc    prer0                     ; Loop

chdo2:  lea   r11, [vtbl0]              ; Get vector table
        jmp   [r11+rdx*8]               ; Jump to proper routine

; Finish Input.

; Finish if ipt is Enter, else loop.

qend0:  bt    qword[flgs0], 12          ; Test ipt flag
        jnc   fnsh0                     ; Finish if flag is clear
        jmp   prer0                     ; Else loop

; Finish if ipt is Home, else loop.

qend1:  bt    qword[flgs0], 12          ; Test ipt flag
        jc    fnsh0                     ; Finish if flag is set
        jmp   prer0                     ; Else loop

; The following are leaf functions for various processing tasks.

; Clear the Buffer.

; Clear the current terminal input buffer (ctib) if it is not already clear,
; and reset the line counters.

clbf0:  mov   rdi, r12                  ; Clear buffer
        mov   rax, [rdi-8]              ; Get number of characters in buffer
        cmp   rax, 0                    ; See if none
        jz    clbf3                     ; Branch if none

        mov   rcx, rax                  ; Copy character count
        and   rax, 7                    ; See how much to add
        jz    clbf1                     ; Branch if no bytes to add

        neg   rax
        add   rax, 8
        add   rcx, rax                  ; Add rounding bytes

clbf1:  shr   rcx, 3                    ; Convert to quad count
        add   rcx, 1                    ; Add 1 for buffer pointer
clbf2:  mov   qword[rdi+rcx*8-16], 0    ; Null buffer pointer and contents
        sub   rcx, 1                    ; Decrement counter
        jnz   clbf2

clbf3:  xor   r10, r10                  ; Zero line length
        mov   r9, 1                     ; Initialize cursor count

        jmp   rbp                       ; Return

; Append/Insert Character.

; Put character in line.
; See if cursor is at the end of the line. If not, insert character.
; If so, append character.

apns0:  bts   qword[r15], 0             ; Set 1st pass flag
        cmp   r10, r9                   ; If cursor at end of line, append
        jnc   insc0                     ; Else, insert

; Append Character to Current Line.

        mov   [r12+r10], bl             ; Install char in buffer
        add   qword[r12-8], 1           ; Advance buffer pointer
        add   r10, 1                    ; Increment character count
        add   r9, 1                     ; Increment cursor index

; Set new line specification. Note that the fact that we are appending means
; that we don't need to check for the special case of the cursor not at the end.
; The quotient is always incremented.

        mov   rax, r10                  ; Get line length
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by window width
        add   rax, 1                    ; Increment for last row

; Install new line specification. If line is too big for display,
; set the big-line flag (#6).

        mov   [r15+88], rax             ; Install line rows
        mov   [r15+96], rdx             ; Install length of last row
        cmp   [hght0], rax              ; Compare with height
        jnc   rfra0                     ; Branch if line fits

        bts   qword[r15], 6             ; Set big-line flag
        jmp   rfra0

; Insert Character in Line.

; If line y is equal to the window height, and line x is equal to the window
; width, the insertion will cause a transition to big-line format, and if
; cursor y is 1, the new cursor location won't be displayable in the window.
; Likewise, if the big-line flag is already set, and cursor y is 2.
; In these cases insertion is disallowed by looping. The other choice would
; be to move the cursor to the end of the line, but this would be jarring
; to the user. Note that insertion in the last column of the top row would
; not result in the cursor's becomming invisible, however, the inserted
; character would disappear. Therefore, insertion is disallowed for the
; entire top row.

; In this case disallow insertion.

insc0:  mov   r8, [hght0]               ; Get window height
        mov   rbp, [wdth0]              ; Get window width
        bt    qword[r15], 6             ; Test big-line flag
        jnc   insc1                     ; Branch if clear

        cmp   qword[cury0], 2           ; See if cursor y is 2
        jnz   insc3                     ; Branch if not

        jmp   insc2

insc1:  cmp   qword[cury0], 1           ; See if cursor y is 1
        jnz   insc3                     ; Branch if not

insc2:  cmp   r8, [liny0]               ; Compare line y to height
        jnz   insc3                     ; Branch if not equal

        cmp   rbp, [linx0]              ; Compare line x to window width
        jnz   insc3                     ; Branch if not equal

        jmp   prer0                     ; Disallow insert

insc3:  mov   rdx, r10                  ; Copy chr count
        add   rdx, 1                    ; Add 1 for character under cursor
        sub   rdx, r9                   ; Find # of chrs past cursor

        mov   rcx, r10                  ; Copy chr count
insc4:  mov   al, [r12+rcx-1]           ; Move chrs right one place
        mov   [r12+rcx], al
        sub   rcx, 1                    ; Decrement index
        sub   rdx, 1                    ; Decrement loop count
        jnz   insc4                     ; Loop

        mov   [r12+r9-1], bl            ; Install character
        add   qword[r12-8], 1           ; Advance buffer pointer
        add   r10, 1                    ; Increment chr count
        add   r9, 1                     ; Increment cursor pointer

; Update line rows and last row length.
; If remainder of division is zero, increment the quotient.
; If not zero, set last row length to window width and do not
; increment the quotient.

        mov   rax, r10                  ; Get line length
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbp                       ; Divide by window width
        cmp   rdx, 0
        jnz   insc5

; If the remainder is zero, set the last row length to the window
; width, but do not increment quotient.

        mov   rdx, rbp
        jmp   insc6

; If the remainder is not zero, increment the quotient.

insc5:  add   rax, 1                    ; Increment for last row

; Install new line specification. If line is too big for display,
; set the big-line flag (#6).

insc6:  mov   [r15+88], rax             ; Install line rows
        mov   [r15+96], rdx             ; Install length of last row
        cmp   r8, rax                   ; Compare with height
        jnc   insc7                     ; Branch if line fits

        bts   qword[r15], 6             ; Set big-line flag

insc7:  jmp   rfra0                     ; Refresh line

; Backspace.

bksp0:  cmp   r9, 1                     ; Ignore backspace if already
        jz    prer0                     ; at beginning of line

; If cursor is at the origin of screen coordinates, loop.
; If big-line flag is set, origin is at 2,1 instead of 1,1.

        bt    qword[r15], 6             ; Test big-line flag
        jnc   bksp1                     ; Branch if clear

        cmp   qword[cury0], 2           ; See if y-coordinate is 2
        jnz   bksp3                     ; Branch if not

        jmp   bksp2

bksp1:  cmp   qword[cury0], 1
        jnz   bksp3

bksp2:  cmp   qword[curx0], 1
        jz    prer0

bksp3:  sub   r10, 1                    ; Decrement line length
        sub   r9, 1                     ; Decrement cursor pointer
        mov   [r12-8], r10              ; Update buffer chr count
        mov   rbp, [wdth0]              ; Get window width

        cmp   r10, r9                   ; See if cursor at end
        jnc   bksp4                     ; Branch if not

; Replace last character with null, and check to see if there are any
; characters in the line. If line is empty, decrement line x and cursor x
; and go overwrite the character remaining.

        mov   byte[r12+r9-1], 0

; Update line specification.
; Since the cursor is always at the end of the line, don't need to check
; if it's not. Increment the quotient.

        mov   rax, r10                  ; Get line length
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by window width
        add   rax, 1                    ; Increment for last row

; Install new line specification. If line is too big for window,
; the big line flag will have been set, leave it set. If line
; fits, clear the flag.

        mov   [r15+88], rax             ; Install line rows
        mov   [r15+96], rdx             ; Install length of last row
        cmp   [hght0], rax              ; Compare with height
        jc    rfra0                     ; Refresh line if too big

        btr   qword[r15], 6             ; Else clear big-line flag

        jmp   rfra0                     ; Refresh line

; If cursor not at end of line, move characters left one place
; to the cursor location and replace last character with null.

bksp4:  bts   qword[r15], 4             ; Set rewrite flag

; Find number of characters past cursor.

        mov   rdx, r10                  ; Copy character count
        sub   rdx, r9                   ; Subtract cursor pointer
        add   rdx, 1                    ; Add 1 for decrement

; Subtract 1 from cursor location for index, since cursor is one more
; than the line length

        mov   rcx, r9                   ; Use new cursor location for index
        sub   rcx, 1                    ; One less
bksp5:  mov   al, [r12+rcx+1]           ; Move chrs left one place
        mov   [r12+rcx], al
        add   rcx, 1                    ; Increment index
        sub   rdx, 1                    ; Decrement count
        jnz   bksp5                     ; Loop for count
        mov   byte[r12+rcx], 0          ; Replace last chr with null

; Update the line specification. It's not necessary to check whether
; the cursor is at the end. Only if the remainder is zero, meaning that
; we want to Backspace to the row above. In which case the last Backspace
; will have left the correct line specification for the cursor at the end,
; and now we want to Backspace over the last character in the row above
; and put the cursor there.
; If remainder of division is zero, increment the quotient.
; If not zero, set last row length to window width and do not
; increment the quotient.

        mov   rax, r10                  ; Get line length
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by window width
        cmp   rdx, 0
        jnz   bksp6

; If the remainder is zero, set the last row length to the window
; width, but do not increment quotient.

        mov   rdx, [wdth0]
        jmp   bksp7

; If the remainder is not zero, increment the quotient.

bksp6:  add   rax, 1                    ; Increment for last row

; Install new line specification. If line is too big for display,
; set the big-line flag (#6).

bksp7:  mov   [r15+88], rax             ; Install line rows
        mov   [r15+96], rdx             ; Install length of last row
        cmp   [hght0], rax              ; Compare with height
        jc    rfra0                     ; Refresh line if too big

        btr   qword[r15], 6             ; Else clear big-line flag

        jmp   rfra0                     ; Refresh line

; Delete.

dlet0:  cmp   r10, r9                   ; Ignore if cursor
        jc    prer0                     ; at end of line

; Cursor over last character is special case.

        jnz   dlet1

        sub   r10, 1                    ; Decrement character count
        mov   byte[r12+r10], 0          ; Install null
        jmp   dlet3

dlet1:  sub   r10, 1                    ; Decrement char count
        mov   rdx, r10                  ; One copy for count
        mov   rcx, r9                   ; One copy for index
        sub   rcx, 1                    ; Back up
        sub   rdx, rcx                  ; Subtract for count
dlet2:  mov   al, [r12+rcx+1]           ; Move chrs left one place
        mov   [r12+rcx], al
        add   rcx, 1                    ; Increment index
        sub   rdx, 1                    ; Decrement count
        jnz   dlet2                     ; Loop for count
        mov   byte[r12+rcx], 0          ; Replace last chr with null

; Update line specification.
; If remainder of division is zero, increment the quotient.
; If not zero, set last row length to window width and do not
; increment the quotient.

dlet3:  mov   rax, r10                  ; Get line length
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by window width
        cmp   rdx, 0
        jnz   dlet4

; If the remainder is zero, set the last row length to the window
; width, but do not increment quotient.

        mov   rdx, [wdth0]
        jmp   dlet5

; If the remainder is not zero, increment the quotient.

dlet4:  add   rax, 1                    ; Increment for last row

; Install new line specification. If line is too big for display,
; set the big-line flag (#6).

dlet5:  mov   [r15+88], rax             ; Install line rows
        mov   [r15+96], rdx             ; Install length of last row
        cmp   [hght0], rax              ; Compare with height
        jc    rfra0                     ; Refresh line if too big

        btr   qword[r15], 6             ; Else clear big-line flag

        jmp   rfra0                     ; Refresh line

; Move Cursor Back.

crbk0:  cmp   r9, 1                     ; Ignore if cursor already
        jz    prer0                     ; at beginning of line

        mov   rcx, [cury0]              ; Get cursor y

; If cursor is at the origin of screen coordinates, loop.
; If big-line flag is set, origin is at 2,1 instead of 1,1.

        bt    qword[r15], 6             ; Test big-line flag
        jnc   crbk2                     ; Branch if clear

; If the big-line flag is set, and the last row contains only the cursor,
; the line should scroll down one row.

        cmp   rcx, [hght0]              ; Compare window height
        jnz   crbk1                     ; Branch if not equal

        cmp   qword[r15+96], 0          ; See if last row is 0
        jnz   crbk1                     ; Branch if not

        sub   r9, 1                     ; Decrement cursor pointer
        sub   qword[r15+88], 1          ; Decrement line rows
        mov   rcx, [wdth0]              ; Get window width
        mov   [r15+96], rcx             ; Set last row length to window width
        mov   rcx, [hght0]              ; Get window height
        cmp   rcx, [r15+88]             ; Compare line rows
        jc    rfra0                     ; Rewrite line

        btr   qword[r15], 6             ; Clear big-line flag

        jmp   rfra0                     ; Rewrite line

crbk1:  cmp   rcx, 2                    ; See if cursor y is 2
        jnz   crbk4                     ; Branch if not

        jmp   crbk3

crbk2:  cmp   rcx, 1                    ; See if cursor y is 1
        jnz   crbk4                     ; Branch if not

crbk3:  cmp   qword[curx0], 1           ; Check cursor x
        jz    prer0                     ; Loop if both are 1

crbk4:  sub   r9, 1                     ; Decrement cursor pointer
        cmp   qword[curx0], 1           ; See if cursor x is 1
        jz    crbk5                     ; Branch if so

        sub   qword[curx0], 1           ; Decrement cursor x

        mov   rdi, [sdout]              ; Move cursor back
        lea   rsi, [csrb]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

        jmp   prer0                     ; Loop

; When the cursor x-coordinate is 1, the new cursor x-coordinate is set
; to the window width, and the cursor y-coordinate and cursor pointer are
; decremented.

crbk5:  sub   qword[cury0], 1           ; Decrement cursor y
        mov   rcx, [wdth0]              ; Get window width
        mov   [curx0], rcx              ; Set cursor x to window width

        lea   rbp, [prer0]              ; Place the cursor and loop
        lea   r11, [cury0]              ; Address of coordinates
        jmp   pcxy0

; Move Cursor Forward.

; If cursor x is equal to window width and cursor y is equal
; to the window height, determine if the line is now too big
; for the window. If not, output a linefeed and relocate
; the cursor. If so, set the big-line flag and refresh the line.

crfd0:  cmp   r10, r9                   ; See if cursor is past end of line
        jc    prer0                     ; Loop if so

        add   r9, 1                     ; Advance cursor pointer
        mov   rcx, [wdth0]              ; Get window width
        cmp   rcx, [curx0]              ; See if cursor x is equal to width
        jz    crfd1                     ; Branch if so

        add   qword[curx0], 1           ; Increment cursor x

        mov   rdi, [sdout]              ; Move cursor forward
        lea   rsi, [csrf]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

        jmp   prer0                     ; Loop

crfd1:  mov   qword[curx0], 1           ; Set cursor x to 1
        mov   rcx, [hght0]              ; Get window height
        cmp   rcx, [cury0]              ; Compare cursor y
        jz    crfd2                     ; Branch if equal

        add   qword[cury0], 1           ; Increment cursor y
        jmp   crfd3                     ; Branch to place cursor

; If linefeed needed, see if anchor row is 1, and if so,
; set the big-line flag and refresh the line.
; Otherwise decrement line y, decrement the anchor row,
; and output the linefeed.

crfd2:  cmp   qword[ancy0], 1           ; See if anchor y is 1
        jz    crfd4                     ; Branch if so

        sub   qword[ancy0], 1           ; Else decrement anchor y
        sub   qword[liny0], 1           ; Decrement line y

        mov   rdi, [sdout]              ; Output linefeed
        lea   rsi, [linfd]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

crfd3:  lea   rbp, [prer0]              ; Place the cursor and loop
        lea   r11, [cury0]
        jmp   pcxy0

crfd4:  add   qword[r15+88], 1          ; Increment line rows
        mov   qword[r15+96], 0          ; Set last row length to 0
        bts   qword[r15], 6             ; Set big-line flag
        jmp   rfra0                     ; Refresh the line

; Move Cursor Up.

; If cursor is in the last row by itself and the line is too big
; for the window, scroll the line down one row.

crup0:  bt    qword[r15], 0             ; Test 1st pass flag
        jnc   prer0                     ; Loop if clear

; If cursor is in top row, loop.
; If big-line flag is set, the top row is at 2, instead of 1.

        mov   rcx, [cury0]              ; Get cursor y
        bt    qword[r15], 6             ; Test big line flag
        jnc   crup2                     ; Branch if clear

; If the big-line flag is set, and the last row contains only the cursor,
; the line should scroll down one row.

        cmp   rcx, [hght0]              ; Compare with height
        jnz   crup1                     ; Branch if not equal

        cmp   qword[r15+96], 0          ; See if last row is 0
        jnz   crup1                     ; Branch if not

        mov   rcx, [wdth0]              ; Get window width
        sub   r9, rcx                   ; Subtract from cursor pointer
        sub   qword[r15+88], 1          ; Decrement line rows
        mov   [r15+96], rcx             ; Set last row length to window width
        mov   rcx, [hght0]              ; Get window height
        cmp   rcx, [r15+88]             ; Compare line rows
        jc    rfra0                     ; Rewrite line

        btr   qword[r15], 6             ; Clear big-line flag

        jmp   rfra0                     ; Rewrite line

crup1:  cmp   rcx, 2                    ; See if in 2nd row
        jz    prer0                     ; Can't go up from there

crup2:  cmp   rcx, [ancy0]              ; Subtract anchor y
        jna   prer0                     ; Loop if cursor can't move up

        sub   qword[cury0], 1           ; Decrement cursor y
        sub   r9, [wdth0]               ; Subtract width from cursor pointer

        lea   rbp, [prer0]              ; Place the cursor and loop
        lea   r11, [cury0]
        jmp   pcxy0

; Move Cursor Down.

; This function must check to see how many characters are
; in the last row and not move down past the end of the line.
; If the last row is the same width as the window, the cursor
; must be relocated to column 1 of the next row. If that row
; is below the bottom of the window a linefeed must be output
; first.

crdn0:  bt    qword[r15], 0             ; Test 1st pass flag
        jnc   prer0                     ; Loop if clear

        mov   rbx, [liny0]              ; Get line y
        sub   rbx, [cury0]              ; Subtract cursor y
        ja    crdn4                     ; Branch if cursor y is less
        jnz   prer0                     ; Loop if negative

        mov   rdx, [wdth0]              ; Get window width
        cmp   rdx, [linx0]              ; Compare line x
        jne   prer0                     ; Loop if not equal

        mov   rcx, [hght0]              ; Get window height
        cmp   rcx, [liny0]              ; Compare line y
        jz    crdn1                     ; Branch if equal

        add   qword[cury0], 1           ; Increment cursor y
        jmp   crdn3

; If linefeed needed, see if anchor row is 1, and if so,
; set the big-line flag and refresh the line.
; Otherwise decrement line y, decrement the anchor row,
; and output the linefeed.

crdn1:  cmp   qword[ancy0], 1           ; See if anchor y is 1
        jnz   crdn2                     ; Branch if not

        lea   r9, [r10+1]               ; Load new cursor pointer
        add   qword[r15+88], 1          ; Increment line rows
        mov   qword[r15+96], 0          ; Set last row length to 0
        bts   qword[r15], 6             ; Set big-line flag
        jmp   rfra0                     ; Refresh the line

crdn2:  sub   qword[liny0], 1           ; Decrement line y
        sub   qword[ancy0], 1           ; Decrement anchor y

        mov   rdi, [sdout]              ; Output linefeed
        lea   rsi, [linfd]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

crdn3:  mov   qword[curx0], 1           ; Set cursor x to 1
        lea   r9, [r10+1]               ; Load new cursor pointer
        jmp   crdn7                     ; Branch to place cursor

crdn4:  cmp   rbx, 1                    ; See if last row
        jnz   crdn5                     ; Branch if not

        mov   rcx, [linx0]              ; Get line x
        cmp   rcx, [curx0]              ; Compare cursor x
        jnc   crdn5

; If cursor x is past end of line, set cursor pointer to line length plus 1.
; Set new cursor x to line x + 1.

        lea   r9, [r10+1]               ; Set cursor pointer
        add   rcx, 1                    ; Increment line x
        mov   [curx0], rcx              ; Set cursor x
        jmp   crdn6

crdn5:  add   r9, [wdth0]               ; Add width to cursor pointer
crdn6:  add   qword[cury0], 1           ; Increment cursor y

crdn7:  lea   rbp, [prer0]              ; Place the cursor and loop
        lea   r11, [cury0]
        jmp   pcxy0

; Scroll Up.

; Ctrl+Up Arrow/Ctrl+PageUp. Scroll line up one row or 1 page
; if big-line flag is set.
; Note that scrolling can only be initiated by Scroll Up.
; If the big-line flag is set, the top row of the line is replaced
; with an ellipsis. When the line is scrolled up, the bottom row
; is also replaced with an ellipsis to show that the line continues
; below. When the beginning of the line is reached, the top ellipsis
; is replaced by the first line row.
; At the beginning of the scroll, r15+40 is set to the buffer
; address of the last portion of the line which will fit the window.
; With each scroll the window width is subtracted from this address
; until it is equal to the beginning of the buffer.  
; The number of characters to be displayed is equal to the window
; area minus twice the window width. It is kept in r15+48 while
; scrolling is in effect. One window width will be added to this
; value when reaching the top or the bottom of the buffer.
; Scrolling has its own special vector table of keyboard actions,
; which include:

; 1  - finish if entered character is IPT (default Enter)
; 2  - Install character
; 6  - Previous buffer (Alt+Up Arrow)
; 7  - Next buffer (Alt+DownArrow)
; A  - Finish on Home
; D  - Scroll buffer up one line (Ctrl+Up Arrow)
; E  - Scroll buffer down one line (Ctrl+Down Arrow)
; F  - Scroll buffer up one page (Ctrl+PageUp)
; 10 - Scroll buffer down one page (Ctrl+PageDown)

; Any keypresses in the above list, other than Ctrl+Up/Down Arrow,
; terminate scrolling to perform their action.
;  All printable ASCII character input will be placed at the current
; cursor location while editing is resumed on the current line.
;  The Alt+Up/Down arrows function normally to change to the previous
; or following buffer in the circular list.
;  The Enter or Home character will terminate keyboard input,
; and submit the current line to the Interpreter, depending
; on the setting of the IPT (Input Terminator) flag.
; The default is the Enter key.
;  All other keys and combinations are inactive while scrolling.

; Ctrl+PageUp

pgup0:  bt    qword[r15], 6             ; Test big-line flag
        jnc   prer0                     ; Loop if not set

        bts   qword[r15], 11            ; Set page-scroll flag
        jmp   bfup1                     ; Jump to scroll

bfup0:  bt    qword[r15], 6             ; Test big-line flag
        jnc   prer0                     ; Loop if not set

; See if this is the 1st scroll.

bfup1:  bts   qword[r15], 9             ; Test/set scroll flag
        jc    bfup2                     ; Branch if scrolling initialized

        lea   rdi, [tbls1]              ; Set scrolling table address
        mov   [vtof0], rdi
        mov   rax, [area0]              ; Get window area
        sub   rax, [wdth0]              ; Subtract width from area
        sub   rax, [wdth0]              ; Twice for ellipses
        mov   [r15+48], rax             ; Initialize number of chrs
        lea   rdi, [r12+r10]            ; Load address of end of line
        sub   rdi, rax                  ; Subtract displayed chrs
        sub   rdi, [r15+96]             ; Subtract last row

        mov   [r15+32], rdi             ; Initialize buffer location
        mov   [r15+40], rdi             ; Initialize buffer index

; Save cursor location.

        mov   rcx, [cury0]
        mov   [crsy0], rcx
        mov   rcx, [curx0]
        mov   [crsy0+8], rcx

; Hide the cursor.

        mov   rdi, [sdout]
        lea   rsi, [hdcsr]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

        jmp   bfup3

; Loop if at top of buffer (top flag is set).

bfup2:  bt    qword[r15], 7
        jc    prer0

; Move cursor to anchor

bfup3:  lea   rbp, [bfup4]              ; Move cursor to anchor
        lea   r11, [ancy0]
        jmp   pcxy0

; Erase from anchor y to end of screen.

bfup4:  mov   rdi, [sdout]              ; Erase to end of screen
        lea   rsi, [erste]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; See if page-scrolling is in effect.

        btr   qword[r15], 11            ; Test/clear page-scroll flag
        jnc   bfup6                     ; Branch if not set

        mov   rdi, [r15+40]             ; Get buffer address
        sub   rdi, [r15+48]             ; Subtract a page worth
        cmp   rdi, r12
        jna   bfup5                     ; Branch if at top

        mov   rcx, [r15+48]             ; Subtract a page
        sub   [r15+40], rcx             ; From buffer pointer
        jmp   bfup8

bfup5:  mov   [r15+40], r12             ; Set buffer address to beginning
        jmp   bfup7

; Move back to previous row. If at beginning of buffer, set top flag,
; show only bottom ellipsis, and include first line row at the top.

bfup6:  mov   rcx, [wdth0]              ; Get window width
        sub   [r15+40], rcx             ; Subtract from buffer pointer
        cmp   r12, [r15+40]             ; See if at beginning of buffer
        jnz   bfup8                     ; Branch if not

bfup7:  bts   qword[r15], 7             ; Set top flag

; Write visible portion of line

        mov   rdi, [sdout]
        mov   rsi, [r15+40]             ; Where to start
        mov   rdx, [r15+48]             ; Number of characters
        add   rdx, [wdth0]              ; Add another row

        strinOSCm  write

        jmp   bfup9

; Write ellipsis, output linefeed, and place cursor in column1.

bfup8:  mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]
        mov   rbx, 0x44335B1B0A2E2E2E
        mov   [rsi], rbx
        mov   rdx, 8

        strinOSCm  write

; Write visible portion of line

        mov   rdi, [sdout]
        mov   rsi, [r15+40]             ; Where to start
        mov   rdx, [r15+48]             ; Number of characters

        strinOSCm  write

; Write bottom ellipsis.

bfup9:  mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]
        mov   rbx, 0x2E2E2E
        mov   [rsi], rbx
        mov   rdx, 3

        strinOSCm  write

; Restore cursor location.

        lea   rbp, [prer0]              ; Place cursor and loop
        lea   r11, [crsy0]
        jmp   pcxy0

; Scroll Down.

; Ctrl+Down Arrow/Ctrl+PageDown. Scroll line down one row or one page
; if scrolling flag is set.
; The line can be scrolled down as long as there is an ellipsis in
; the bottom row of the line. When the end of the line is reached,
; the bottom ellipsis is replaced with the last row of the line.
; This function is only active if the line has been scrolled up
; so that the scroll flag has been set.

; Ctrl+PageDown

pgdn0:  bt    qword[r15], 9             ; Test scroll flag
        jnc   prer0                     ; Loop if not set

        bts   qword[r15], 11            ; Set page-scroll flag
        jmp   bfdn1                     ; Jump to scroll

bfdn0:  bt    qword[r15], 9             ; Test scroll flag
        jnc   prer0                     ; Loop if not set

bfdn1:  mov   rcx, [wdth0]              ; Get width

; See if pointer is at the beginning of the buffer.

        cmp   r12, [r15+40]             ; See if at beginning of buffer
        jnz   bfdn2                     ; Branch if not

; If at beginning of buffer, clear the top flag, and advance the pointer
; one window width for the top line row.

        btr   qword[r15], 7             ; Clear top flag
        add   [r15+40], rcx             ; Advance pointer

; Test for page-scroll and clear page-scroll flag.

bfdn2:  btr   qword[r15], 11            ; Test/clear page-scroll flag
        jnc   bfdn4                     ; Branch if clear

        mov   rdi, [r15+40]             ; Get buffer address
        add   rdi, [r15+48]             ; Add a page worth
        cmp   [r15+32], rdi             ; Compare with starting point
        jna   bfdn3                     ; Branch if at or past starting point

        mov   rcx, [r15+48]             ; Add a page
        add   [r15+40], rcx             ; to buffer pointer
        jmp   bfdn8                     ; Go write screen

bfdn3:  mov   rdi, [r15+32]             ; Set pointer to start
        mov   [r15+40], rdi
        jmp   bfdn5

bfdn4:  add   [r15+40], rcx             ; Advance pointer
        mov   rdi, [r15+32]             ; Get starting point
        cmp   rdi, [r15+40]             ; Compare pointer
        jnz   bfdn8                     ; Branch if not equal

; End of buffer reached. Rewrite the line, leave scroll mode,
; and restore the cursor,

; Move cursor to anchor.

bfdn5:  lea   rbp, [bfdn6]
        lea   r11, [ancy0]
        jmp   pcxy0

; Erase from anchor y to end of screen.

bfdn6:  mov   rdi, [sdout]
        lea   rsi, [erste]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Write ellipsis (including linefeed)

        mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]
        mov   rbx, 0x44335B1B0A2E2E2E
        mov   [rsi], rbx
        mov   rdx, 8

        strinOSCm  write

; Set up to write last part of line.
; The line is written from the buffer location in r15+32.
; The number of bytes to write is the quantity in r15+48
; plus the length of the last row (which may be 0).

        mov   rdx, [r15+48]             ; Get area0-2*wdth0
        add   rdx, [r15+96]             ; Add length of last row
        mov   rsi, [r15+32]             ; Buffer location

; Write line.

        mov   rdi, [sdout]              ; Standard handle

        strinOSCm  write

        cmp   qword[r15+96], 0          ; See if last row 0

        jnz   bfdn7                     ; Branch if not

        mov   rdi, [sdout]              ; Output linefeed
        lea   rsi, [linfd]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Clear scroll flag, reset `strin` scroll-monitoring stack variables to zero,
; and restore normal offset table address.

bfdn7:  btr   qword[r15], 9             ; Clear scroll flag
        xor   rcx, rcx
        mov   [r15+32], rcx
        mov   [r15+40], rcx
        mov   [r15+48], rcx

        lea   rdi, [tbls0]              ; Restore normal table address
        mov   [vtof0], rdi

; Show the cursor.

        mov   rdi, [sdout]
        lea   rsi, [shcsr]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Place cursor and loop.

        lea   rbp, [prer0]              ; Place cursor and loop
        lea   r11, [crsy0]
        jmp   pcxy0

; Write the next screen of scrolled line text.

bfdn8:  lea   rbp, [bfdn9]              ; Move cursor to anchor
        lea   r11, [ancy0]
        jmp   pcxy0

; Erase from anchor y to end of screen.

bfdn9:  mov   rdi, [sdout]              ; Erase to end of screen
        lea   rsi, [erste]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Write ellipsis, output linefeed, and place cursor in column1.

        mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]
        mov   rbx, 0x44335B1B0A2E2E2E
        mov   [rsi], rbx
        mov   rdx, 8

        strinOSCm  write

; Write visible portion of line

        mov   rdi, [sdout]
        mov   rsi, [r15+40]             ; Where to start
        mov   rdx, [r15+48]             ; Number of characters

        strinOSCm  write

; Write bottom ellipsis.

        mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]
        mov   rbx, 0x2E2E2E
        mov   [rsi], rbx
        mov   rdx, 3

        strinOSCm  write

; Restore cursor location.

        lea   rbp, [prer0]              ; Place cursor and loop
        lea   r11, [crsy0]
        jmp   pcxy0

; Previous/Next Buffer.

; When proceeding to the next buffer, as much of the line as can
; be displayed from anchor y to the bottom of the window is shown,
; and anchor y is displaced upward if necessary until it becomes 1.
; When the window becomes full of the same line, the big line flag
; is set, the top row gives way to an ellipsis, and one less row
; of the line is shown.
; Everything above the anchor row belongs in the scrollback buffer,
; everything in the anchor row and below is editable space that can
; expand to occupy the entire window. So if a line is found to fit
; the window, it is written from the anchor row, scrolling everything
; above into the scrollback buffer. If a line, whether typed,
; pasted, or recalled from a buffer, is too big for the window,
; only the last rows that fit in one less than the window height
; will be displayed. The 1st row will always be the ellipsis.

; Previous Buffer.

prbf0:  bt    qword[r15], 0             ; Test 1st pass flag
        jnc   prbf1                     ; Don't store count if clear

        mov   [r12-8], r10              ; Store count in current buffer

prbf1:  mov   r12, [r12-56]             ; Get link to previous buffer
        jmp   pnxb0

; Next Buffer.

; When Down-arrow is pressed, and the 1st pass flag is not set, display the
; contents of the current buffer, but set the 1st pass flag so that subsequent
; Down-arrow presses will advance the buffer.

nxbf0:  bt    qword[r15], 0             ; Test 1st pass flag
        jnc   pnxb1                     ; Display current line if clear

; Advance to next buffer.

        mov   [r12-8], r10              ; Store count in current buffer

nxbf1:  mov   r12, [r12-48]             ; Get link to following buffer

pnxb0:  mov   [srce0], r12              ; Update src variable
        mov   [ctmb0], r12              ; and ctib

; Set 1st pass flag.

pnxb1:  bts   qword[r15], 0             ; Set 1st pass flag
        mov   r10, [r12-8]              ; Get buffer chr count
        lea   r9, [r10+1]               ; Initialize cursor pointer

; See if scrolling and reset parameters if so.

        btr   qword[r15], 9             ; See if scrolling
        jnc   pnxb2                     ; Branch if not

; Clear top flag (whether or not it was set).

        btr   qword[r15], 7

; Show the cursor.

        mov   rdi, [sdout]
        lea   rsi, [shcsr]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Reset `strin` scroll-monitoring stack variables to zero, and restore normal offset
; table address.

        xor   rcx, rcx
        mov   [r15+32], rcx
        mov   [r15+40], rcx
        mov   [r15+48], rcx

        lea   rdi, [tbls0]              ; Restore normal table address
        mov   [vtof0], rdi

; Erase from anchor y to end of screen.

pnxb2:  lea   rbp, [pnxb3]              ; Move cursor to anchor
        lea   r11, [ancy0]
        jmp   pcxy0

pnxb3:  mov   rdi, [sdout]              ; Erase to end of screen
        lea   rsi, [erste]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; If buffer is empty, reinitialize line parameters, clear big-line
; flag, and loop

        cmp   r10, 0
        jnz   pnxb4

        mov   rcx, [ancy0]              ; Get anchor y
        mov   [cury0], rcx              ; Set cursor y
        mov   [liny0], rcx              ; Set line y
        mov   qword[curx0], 1           ; Set cursor x
        mov   qword[linx0], 0           ; Set line x
        mov   qword[r15+88], 1          ; Set line rows
        mov   qword[r15+96], 0          ; Set length of last row
        btr   qword[r15], 6             ; Clear big-line flag
        jmp   prer0

; Initialize line specification. The cursor is always at the end,
; and the quotient is incremented to include the last row,
; which may be empty except for the cursor. If the remainder is zero,
; the length of the last row will be zero.

pnxb4:  mov   rax, r10                  ; Get line length
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by window width
        add   rax, 1                    ; Increment for last row

; Install new line specification. If line is too big for display,
; set the big-line flag (#6). If the line is not too big, clear
; the flag.

        mov   [r15+88], rax             ; Install line rows
        mov   [r15+96], rdx             ; Install length of last row
        cmp   [hght0], rax              ; Compare with height
        jnc   pnxb5                     ; Branch if line fits

        bts   qword[r15], 6             ; Set big-line flag
        jmp   pnxb6

pnxb5:  btr   qword[r15], 6             ; Clear big-line flag

; Here window should be refreshed.

pnxb6:  jmp   rfra0

; Refresh Line.

; There are two line refresh routines. One for when the cursor is at the end
; of the line, and one for when it is not.

; Write as much of the line as the window can contain from anchor y.
; If the line doen't fit the window, the 1st row will be occupied
; by an ellipsis.

; Line x can be set immediately

rfra0:  mov   rcx, [r15+96]             ; Get length of last row
        cmp   rcx, 0                    ; Test if 0
        jnz   rfra1

        mov   rcx, [wdth0]              ; Set line x to window width
 
rfra1:  mov   [linx0], rcx              ; Install line x

; Check for special case of 1-row line - strictly less than the window
; width.

        cmp   r10, [wdth0]              ; See if line will fit in 1 row
        jnc   rfra3                     ; Branch if not

; Update cursor x.

        mov   [curx0], r9

; Move cursor to beginning of line.

        lea   rbp, [rfra2]              ; Place cursor
        lea   r11, [ancy0]
        jmp   pcxy0

; Erase to end of line.

rfra2:  mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]
        mov   rbx, 0x4B5B1B
        mov   [rsi], rbx
        mov   rdx, 3

        strinOSCm  write

; Write line.

        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r12                  ; Where to start writing
        mov   rdx, [rsi-8]              ; Get string length

        strinOSCm  write

; See if cursor is at the end.

        cmp   r10, r9
        jc    prer0                     ; Return if so

        lea   rbp, [prer0]              ; Else place cursor and return
        lea   r11, [cury0]
        jmp   pcxy0

; Line is more than one row.

rfra3:  lea   rbp, [rfra4]              ; Move cursor to anchor
        lea   r11, [ancy0]
        jmp   pcxy0

; Erase from anchor y to end of screen.

rfra4:  mov   rdi, [sdout]              ; Erase to end of screen
        lea   rsi, [erste]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; If cursor is not at the end of the line, use other routine.

        cmp   r10, r9
        jnc   rfrb1

; See if line will fit window.

        bt   qword[r15], 6              ; Test big-line flag
        jc   rfra8                      ; Branch if set

; See if line can be accommodated in space from anchor y
; to the bottom of the screen.

        mov   rbx, [hght0]              ; Get window height
        mov   rcx, rbx                  ; Make copy
        sub   rcx, [ancy0]              ; Subtract anchor y
        add   rcx, 1                    ; Add 1
        cmp   rcx, [r15+88]             ; Compare line rows
        jc    rfra6                     ; Branch if line won't fit

; Line fits space available. Anchor y remains the same. Set line
; y coordinate, write the line, and set cursor coordinates.

        mov   rcx, [ancy0]              ; Get anchor y
        add   rcx, [r15+88]             ; Add line rows
        sub   rcx, 1                    ; Subtract 1 for anchor row
        mov   [liny0], rcx              ; Set line y
        mov   [cury0], rcx              ; Set cursor y
        mov   rcx, [r15+96]             ; Get last row length
        cmp   rcx, 0                    ; See if 0
        jnz   rfra5                     ; Branch if not

        mov   qword[curx0], 1           ; Set cursor x to 1
        sub   qword[liny0], 1           ; Decrement line y
        bts   qword[r15], 2             ; Set cursor relocation flag

rfra5:  add   rcx, 1                    ; Increment for cursor x
        mov   [curx0], rcx              ; Install cursor x
        mov   rsi, r12                  ; Where to start writing
        mov   rdx, [rsi-8]              ; Get string length
        jmp   rfra12                    ; Go write line

; Anchor y will scroll upward. Reset it, set line and cursor
; coordinates, and branch to write line.

rfra6:  mov   rcx, rbx                  ; Copy window height
        sub   rbx, [r15+88]             ; Subtract line rows
        add   rbx, 1                    ; Anchor contains 1st row of line
        mov   [ancy0], rbx              ; Set new anchor row
        mov   [liny0], rcx              ; Set line y
        mov   [cury0], rcx              ; Set cursor y
        mov   rcx, [r15+96]             ; Get length of last row
        cmp   rcx, 0                    ; See if 0
        jnz   rfra7                     ; Branch if not

        mov   qword[curx0], 1           ; Set cursor x to 1
        sub   qword[liny0], 1           ; Decrement line y
        bts   qword[r15], 3             ; Set linefeed flag
        bts   qword[r15], 2             ; Set cursor relocation flag

rfra7:  add   rcx, 1                    ; Increment for cursor x
        mov   [curx0], rcx              ; Install cursor x
        mov   rsi, r12                  ; Where to start writing
        mov   rdx, [rsi-8]              ; Get string length
        jmp   rfra12                    ; Go write line

; Line is too big for window.
; Set anchor y to 1, set cursor coordinates and line y, write ellipsis,
; and write the line from the line length minus the window area minus
; twice the window width plus the length of the last row (if not 0).

rfra8:  btr   qword[r15], 9             ; Test/clear scroll flag
        jnc   rfra9                     ; Branch if not scrolling

; Clear top flag (whether or not it was set).

        btr   qword[r15], 7

; Show the cursor.

        mov   rdi, [sdout]
        lea   rsi, [shcsr]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Reset `strin` scroll-monitoring stack variables to zero, and restore normal offset
; table address.

        xor   rcx, rcx
        mov   [r15+32], rcx
        mov   [r15+40], rcx
        mov   [r15+48], rcx

        lea   rdi, [tbls0]              ; Restore normal table address
        mov   [vtof0], rdi

rfra9:  mov   qword[ancy0], 1           ; Set anchor y to 1
        mov   rcx, [hght0]              ; Get window height
        mov   [liny0], rcx              ; Set line y
        mov   [cury0], rcx              ; Set cursor y
        mov   rcx, [r15+96]             ; Get last row length
        cmp   rcx, 0                    ; See if 0
        jnz   rfra10                    ; Branch if not

        mov   qword[curx0], 1           ; Set cursor x to 1
        sub   qword[liny0], 1           ; Decrement line y
        bts   qword[r15], 3             ; Set linefeed flag
        bts   qword[r15], 2             ; Set cursor relocation flag

rfra10: add   rcx, 1                    ; Increment for cursor x
        mov   [curx0], rcx              ; Install cursor x

; Write ellipsis.

        mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]
        mov   rbx, 0x44335B1B0A2E2E2E
        mov   [rsi], rbx
        mov   rdx, 8

        strinOSCm  write

; Set up to write last part of line. If the length of the last row
; is equal to the window width, the number of bytes to write is
; A - 2W, the area minus twice the window width. If the length
; is anything else, the number of bytes is A - 2W + lx

        mov   rdx, [area0]              ; Copy window area
        mov   rcx, [wdth0]              ; Get window width
        shl   rcx, 1                    ; Double it
        sub   rdx, rcx                  ; Subtract from area
        cmp   qword[r15+96], 0          ; See if last row length is 0
        jz    rfra11                    ; Branch if so

        add   rdx, [r15+96]             ; Add length of last row

rfra11: lea   rsi, [r12+r10]            ; Address of end of line
        sub   rsi, rdx                  ; Number of bytes to write

; Write line.

rfra12: mov   rdi, [sdout]              ; Standard handle

        strinOSCm  write

        btr   qword[r15], 3             ; Test/clear linefeed flag
        jnc   rfra13                    ; Branch if clear

        mov   rdi, [sdout]              ; Output linefeed
        lea   rsi, [linfd]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

rfra13: btr   qword[r15], 2             ; Test/clear cursor relocation flag
        jnc   prer0                     ; Loop if clear

        lea   rbp, [prer0]              ; Place cursor and return
        lea   r11, [cury0]
        jmp   pcxy0

; Refresh line when cursor is not at the end of the line.

rfrb1:  mov   rbx, [hght0]              ; Get window height

; See if line will fit window.

        bt    qword[r15], 6             ; Test big-line flag
        jc    rfrb4                     ; Branch if set

; See if line can be accommodated in space from anchor y
; to the bottom of the screen.

        mov   rcx, rbx                  ; Copy window height
        sub   rcx, [ancy0]              ; Subtract anchor y
        add   rcx, 1                    ; Add 1
        cmp   rcx, [r15+88]             ; Compare line rows
        jc    rfrb2                     ; Branch if line won't fit

; Line fits space available. Anchor y remains the same. Set line
; y coordinate, write the line, and set cursor coordinates.

        mov   rcx, [ancy0]              ; Get anchor y
        add   rcx, [r15+88]             ; Add line rows
        sub   rcx, 1                    ; Subtract 1 for anchor row
        mov   [liny0], rcx              ; Set line y
        jmp   rfrb3

; Anchor y will scroll upward. Reset it, set line and cursor
; coordinates, and branch to write line.

rfrb2:  mov   [liny0], rbx              ; Set line y
        sub   rbx, [r15+88]             ; Subtract line rows
        add   rbx, 1                    ; Add 1 for anchor row
        mov   [ancy0], rbx              ; Set new anchor row

rfrb3:  mov   rsi, r12                  ; Where to start writing
        mov   rdx, [rsi-8]              ; Get string length

        jmp   rfrb6                     ; Go write line

; Line is too big for window. If scrolling, unhide the cursor,
; clear scrolling registers, and restore vector offset table to normal.
; Set anchor y to 1, set line y, write ellipsis, and write the line
; from the line length minus the window area minus twice the window
; width plus the length of the last row (if not 0).
; Calculate new cursor coordinates and place the cursor.

rfrb4:  btr   qword[r15], 9             ; Test/clear scroll flag
        jnc   rfrb5                     ; Branch if not scrolling

; Clear top flag (whether or not it was set).

        btr   qword[r15], 7

; Show the cursor.

        mov   rdi, [sdout]
        lea   rsi, [shcsr]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Reset `strin` scroll-monitoring stack variables to zero, and restore normal offset
; table address.

        xor   rcx, rcx
        mov   [r15+32], rcx
        mov   [r15+40], rcx
        mov   [r15+48], rcx

        lea   rdi, [tbls0]              ; Restore normal table address
        mov   [vtof0], rdi

rfrb5:  mov   qword[ancy0], 1           ; Set anchor y to 1
        mov   rcx, [hght0]              ; Get window height
        mov   [liny0], rcx              ; Set line y

; Write ellipsis.

        mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]
        mov   rbx, 0x44335B1B0A2E2E2E
        mov   [rsi], rbx
        mov   rdx, 8

        strinOSCm  write

; Set up to write last part of line. The number or characters to write
; will be the window area minus twice the window width plus the length
; of the last row.

        mov   rdx, [area0]              ; Copy window area
        mov   rcx, [wdth0]              ; Get window width
        shl   rcx, 1                    ; Double it
        sub   rdx, rcx                  ; Subtract twice the width
        add   rdx, [r15+96]             ; Add length of last row
        lea   rsi, [r12+r10]            ; Address of end of line
        sub   rsi, rdx                  ; Where to start writing

; Write line.

rfrb6:  mov   rdi, [sdout]              ; Standard handle

        strinOSCm  write

; Calculate new cursor coordinates and place cursor.

        mov   rax, r9                   ; Put cursor pointer in dividend
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by display width

; If remainder is not zero, add 1 for remainder row.

        cmp   rdx, 0
        jz    rfrb7

        add   rax, 1
        jmp   rfrb8

; If remainder is zero, set cursor x to window width.

rfrb7:  mov   rdx, [wdth0]              ; Get window width

rfrb8:  mov   [curx0], rdx              ; Set cursor x

        bt    qword[r15], 6             ; Test big-line flag
        jc    rfrb9                     ; Branch if set

        mov   rcx, [ancy0]              ; Get anchor row
        add   rcx, rax                  ; Add cursor offset
        sub   rcx, 1                    ; Subtract 1
        mov   [cury0], rcx              ; Set cursor y
        jmp   rfrb10

; If big-line flag is set decrement cursor y (just don't add 1)
; to compensate for ellipsis row. Exp.

rfrb9:  mov   rcx, [r15+88]             ; Get line rows
        sub   rcx, rax                  ; Subtract cursor rows
        mov   rbx, [hght0]              ; Get window height
        sub   rbx, rcx                  ; Subtract difference
;        add   rbx, 1                    ; Add 1
        mov   [cury0], rbx              ; Set cursor y

rfrb10: lea   rbp, [prer0]              ; Place cursor and return
        lea   r11, [cury0]
        jmp   pcxy0

; Handle Window Size Change.

; select() SIGWINCH handler. Update cursor coordinates, line coordinates,
; and anchor y if system flag #31 has been set by the main SIGWINCH handler,
; `sigwinch`.

swch0:  lea   rbp, [swch1]              ; Set return address
        jmp   gtcc0                     ; Get cursor coordinates

; See if line length is zero.

swch1:  cmp   r10, 0
        jnz   swch2                     ; Branch if not 0

; If there is no line, set anchor y to cursor y and loop.

        mov   rcx, [cury0]
        mov   [ancy0], rcx
        jmp   prer0

; See if freeze flag set.

swch2:  bt    qword[r15], 5             ; Test freeze flag
        jnc   swch6                     ; Branch if clear

        mov   rcx, [area0]              ; Get current window area
        cmp   rcx, [amax0]              ; Compare with maximized area
        jc    prer0                     ; Loop if less

; On returning from freeze, clear the freeze flag. If scrolling, place cursor
; and loop. Otherwise, determine if big-line flag should still be set, restore
; saved cursor coordinates, and place the cursor.

        btr   qword[r15], 5             ; Clear freeze flag

; Test if scrolling is in progress.

        bt    qword[r15], 9             ; Test scroll flag
        jnc   swch3                     ; Branch if not scrolling

        lea   rbp, [prer0]              ; Place the cursor and loop
        lea   r11, [cury1]
        jmp   pcxy0

swch3:  mov   rcx, [r15+88]             ; Get line rows
        cmp   [hght0], rcx              ; Compare with window height
        jc    swch4                     ; Branch if greater

        btr   qword[r15], 6             ; Clear big-line flag

; If on return from freeze, the line is no longer too big for the window,
; line x is equal to the window width, the cursor is not at the end,
; and line y is one less than the window height, cursor y and anchor y
; should be incremented.

        mov   rbx, [wdth0]              ; Get window width
        cmp   rbx, [linx0]              ; See if line x is equal
        jne   swch4                     ; Branch if not

        mov   rcx, [r15+104]            ; Get saved cursor y

        cmp   r10, r9                   ; See if cursor is at the end.
        jc    swch5                     ; Branch if so

        mov   rbx, [hght0]              ; Get window height
        sub   rbx, 1                    ; Subtract 1
        cmp   rbx, [liny0]              ; Compare line y
        jnz   swch5                     ; Branch if not equal

        add   rcx, 1                    ; Increment cursor y  
        add   qword[ancy0], 1           ; increment anchor y
        jmp   swch5

; It was discovered empirically that if the frozen cursor coordinates are
; the same as the window dimensions and the saved cursor y is equal
; to the window height minus 1, cursor y should be incremented along
; with the anchor row.

swch4:  mov   rcx, [r15+104]            ; Get saved cursor y
        mov   rdx, [cury1]              ; Get frozen cursor y
        cmp   rdx, [hght1]              ; Compare frozen height
        jnz   swch5                     ; Branch if not equal

        mov   rdx, [curx1]              ; Get frozen cursor x
        cmp   rdx, [wdth1]              ; Compare with frozen width
        jnz   swch5                     ; Branch if not equal

        mov   rbx, rcx                  ; Copy saved cursor y
        add   rbx, 1                    ; Add 1
        cmp   rbx, [hght0]              ; Compare height
        jnz   swch5                     ; Branch if not equal

        add   qword[ancy0], 1           ; Else increment anchor y
        mov   rcx, rbx                  ; Install incremented cursor y

swch5:  mov   [cury0], rcx
        mov   rcx, [r15+112]
        mov   [curx0], rcx
        lea   rbp, [prer0]              ; Place the cursor and loop
        lea   r11, [cury0]
        jmp   pcxy0

; See if line is too big for new window and set big-line flag accordingly.
; Note that the flag may have already been set.

swch6:  mov   rcx, [hght0]              ; Get window height
        cmp   rcx, [r15+88]             ; Compare new line rows
        jnc   swch7                     ; Branch if line fits

        bts   qword[r15], 6             ; Set big-line flag
        jmp   swch8

; Test and clear big-line flag.

swch7:  btr   qword[r15], 6             ; Test/clear big-line flag
        jnc   swch10                    ; Branch if already clear

; If it was already set, and the line now fits, there is no need
; to test the winsize flag. The size has increased.
; This is the special case of a window size increase making room
; for a line that was formerly too big. Later the big-line flag
; will be tested to handle this case.

        jmp   swcc1

; See if window size has increased.

swch8:  bt    qword[r15], 8             ; Test winsize flag
        jc    swcc1                     ; Branch if increase

; If window size has decreased, while the line is too big, or has
; become too big, set the freeze flag. Save the previous cursor coordinates
; in the rstack frame and set amax0 to the previous window area.
; Note that setting amax0 to a fixed value is not an option, since that
; assumes a particular font size.

swch9:  mov   rcx, [area1]              ; Get previous area
        mov   [amax0], rcx              ; Set amax0
        mov   rcx, [cury1]              ; Save previous cursor coordinates
        mov   [r15+104], rcx
        mov   rcx, [curx1]
        mov   [r15+112], rcx
        bts   qword[r15], 5             ; Set freeze flag
        jmp   prer0                     ; Loop

; The line fits the new window size.

swch10: mov   rbx, [r15+88]             ; Get line rows

; See if cursor is at the end of the line.

        cmp   r10, r9                   ; See if cursor at end of line
        jc    swcb1                     ; Branch if so

; See if the line is partially obscured, when the cursor is not
; at the end.
; Part of the line is obscured if the number of line rows is greater
; than line y. In order to determine line y, cursor y must be valid.
; If the cursor is in the 1st row of the window, and the cursor
; pointer is not less than or equal to the window width, the cursor
; position is not valid, and part of the line is obscured.
; However, if the cursor pointer is less than or equal to the window
; width, while the the cursor is in the 1st row, there is no way to tell
; if the cursor is valid. So the window is frozen to prevent loss of cursor
; control and corruption of the scrollback buffer.

        cmp   qword[cury0], 1           ; See if cursor is in 1st row
        jz    swch9                     ; Freeze window if so

; Determine line y using ly = cy + (L-C+cx)/W
; Where
;
;   ly = line y
;   cy = cursor y
;   L = line length
;   C = cursor pointer
;   cx = cursor x
;   W = window width

        mov   rax, r10                  ; Put L in dividend
        sub   rax, r9                   ; Subtract C
        add   rax, [curx0]              ; Add cx
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by W
        cmp   rdx, 0                    ; See if remainder is zero
        jnz   swca1

        sub   rax, 1                    ; Decrement quotient

swca1:  add   rax, [cury0]              ; Add cursor y
        cmp   rax, rbx                  ; Compare line rows
        jc    swch9                     ; Branch to freeze if less

; Set line coordinates and anchor y.

        mov   [liny0], rax              ; Set line y
        sub   rax, [r15+88]             ; Subtract line rows
        add   rax, 1
        mov   [ancy0], rax              ; Set anchor y
        mov   rcx, [r15+96]             ; Get last row length
        cmp   rcx, 0                    ; See if 0
        jnz   swca2                     ; Branch if not

        mov   rcx, [wdth0]              ; Set line x to window width

swca2:  mov   [linx0], rcx              ; Install line x
        jmp   prer0                     ; Loop

; See if line is partially obscured when the cursor
; is at the end.

; Part of the line is obscured if the number of line rows is greater
; than cursor y. Freeze window if so.

swcb1:  cmp   [cury0], rbx              ; Compare with cursor y
        jc    swch9                     ; Branch to freeze

; If the line fits the window, see if last row length is zero
; and branch if so.

        mov   rcx, [r15+96]             ; Get last row length
        cmp   rcx, 0                    ; Test if 0
        jz    swcb4                     ; Branch if so

; If cursor x is 1, the cursor will have to be moved up one row
; to the end of the line, and cursor y will be decremented.

        mov   [linx0], rcx              ; Set line x
        cmp   qword[curx0], 1           ; See if cursor x is 1
        jz    swcb3                     ; Branch if so

        mov   rcx, [cury0]              ; Get cursor y
        mov   [liny0], rcx              ; Set line y
        sub   rcx, rbx                  ; Subtract line rows

; Don't increment anchor if transition flag is set.

        btr   qword[r15], 10            ; Test/clear transition flag
        jc    swcb2                     ; Branch if flag was set

        add   rcx, 1                    ; Add 1 for anchor row

swcb2:  mov   [ancy0], rcx              ; Set anchor y
        jmp   prer0                     ; Loop

swcb3:  add   rcx, 1                    ; Add 1 for cursor x
        mov   [curx0], rcx              ; Install cursor x
        sub   qword[cury0], 1           ; Decrement cursor y
        mov   rcx, [cury0]              ; Get cursor y
        mov   [liny0], rcx              ; Set line y
        sub   rcx, rbx                  ; Subtract line rows
        add   rcx, 1                    ; Add 1 for anchor row
        mov   [ancy0], rcx              ; Set anchor y
        jmp   swcb7                     ; Branch to place cursor

; The last row length is 0.

swcb4:  mov   rcx, [wdth0]              ; Get window width
        mov   [linx0], rcx              ; Set line x

; If cursor x is already 1, it won't be necessary to set it
; or place the cursor.

        cmp   qword[curx0], 1           ; See if cursor x already 1
        jnz   swcb5                     ; Branch if not

        mov   rcx, [cury0]              ; Get cursor y
        lea   rdx, [rcx-1]              ; Load cursor y - 1
        mov   [liny0], rdx              ; Set line y
        sub   rcx, rbx                  ; Subtract line rows
        add   rcx, 1                    ; Add 1 for anchor row
        mov   [ancy0], rcx              ; Set anchor y
        jmp   prer0                     ; Loop

; If cursor y is equal to the window height, a linefeed will be
; needed.

swcb5:  mov   rcx, [cury0]              ; Get cursor y
        cmp   rcx, [hght0]              ; Compare window height
        jz    swcb6                     ; Branch if equal

        mov   [liny0], rcx              ; Set line y
        add   rcx, 1                    ; Increment for cursor y
        mov   [cury0], rcx              ; Set cursor y
        sub   rcx, rbx                  ; Subtract line rows
        add   rcx, 1                    ; Add 1 for anchor row
        mov   [ancy0], rcx              ; Set anchor y
        mov   qword[curx0], 1           ; Set cursor x to 1
        jmp   swcb7                     ; Branch to place cursor

; Write linefeed.

swcb6:  mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [linfd]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

        mov   rcx, [cury0]              ; Get cursor y
        lea   rdx, [rcx-1]              ; Load cursor y - 1
        mov   [liny0], rdx              ; Set line y
        mov   qword[curx0], 1           ; Set cursor x to 1
        sub   rcx, rbx                  ; Subtract line rows
        add   rcx, 1                    ; Add 1 for anchor row
        mov   [ancy0], rcx              ; Set anchor y

swcb7:  lea   rbp, [prer0]              ; Place the cursor and loop
        lea   r11, [cury0]
        jmp   pcxy0

; Window size has increased, while the line was too big.
; Test if scrolling, and if so, reset scroll parameters.

swcc1:  bt    qword[r15], 9             ; Test scroll flag
        jnc   swcc2                     ; Branch if not scrolling

; Show the cursor.

        mov   rdi, [sdout]
        lea   rsi, [shcsr]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Reset `strin` scroll-monitoring stack variables to zero, and restore normal
; offset table address.

        xor   rcx, rcx
        mov   [r15+32], rcx
        mov   [r15+40], rcx
        mov   [r15+48], rcx

        lea   rdi, [tbls0]              ; Restore normal table address
        mov   [vtof0], rdi

swcc2:  mov   rbx, [wdth0]              ; Get new window width

; Test if cursor is at end of line, and branch if so.

        cmp   r10, r9                   ; Compare cursor pointer to length
        jc    swcc6                     ; Branch if greater

; Cursor is not at the end of the line.

        btr   qword[r15], 9             ; Test/clear scroll flag
        jnc   swcc5                     ; Branch if not scrolling

        btr   qword[r15], 7             ; Test/clear top flag
        jnc   swcc4                     ; Branch if not set

; If cursor is not at the end, and the top flag is set, there are
; two overlapping methods for finding the new anchor row. The 1st
; works for all but the last characters given by wdth1 - mod(area1/wdth0).
; The 2nd covers the wdth0 - [wdth1 - mod(area1/wdth0)] last characters.
; If the cursor was in the last row in the old window, method 2 will
; be used, otherwise method 1.

; See if cursor was in the last row.

        mov   rcx, [hght1]              ; Get old height
        cmp   rcx, [cury1]              ; Compare cursor y coordinate
        jz    swcc3                     ; Branch to use method2

; Use method 1
; ancy0 = cury0 - {[(cury1 - ancy1) * wdth1 + curx1]/wdth0},
; where 1 is subtracted from the quotient if the remainder
; is zero.

        mov   rax, [cury1]              ; Get cury1
        sub   rax, 1                    ; Subtract previous anchor row
        mul   qword[wdth1]              ; Multiply by previous window width
        add   rax, [curx1]              ; Add curx1
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbx                       ; Divide by new window width
        cmp   rdx, 0                    ; See if remainder is zero
        jnz   swcc10                    ; Branch if not

        sub   rax, 1                    ; Decrement subtrahend
        jmp   swcc10

; Use method2
; ancy0 = cury0 - [(area1 - wdth1 + 3)/wdth0]

swcc3:  mov   rax, [area1]              ; Get area of old window
        sub   rax, [wdth1]              ; Subtract old window width
        add   rax, 3                    ; Add 3 for ellipsis
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbx                       ; Divide by new window width
        jmp   swcc10

; If cursor is not at the end, and the scroll flag is set, the new anchor
; row is calculated from:
; ancy0 = cury0 - {[(cury1 - ancy1 - 1) * wdth1 + curx1)/wdth0] + 1},
; where 1 is added for the ellipsis row.

swcc4:  mov   rax, [cury1]              ; Get previous cursor y

; Subtract 1 for anchor row and 1 for ellipsis.

        sub   rax, 2
        mul   qword[wdth1]              ; Multiply by previous window width
        add   rax, [curx1]              ; Add curx1
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbx                       ; Divide by new window width
        add   rax, 1                    ; Add 1
        jmp   swcc10

; If cursor is not at the end, and scrolling is not in effect,
; the new anchor row is given by:
; ancy0 = cury0 - {[(cury1 - ancy1 - 1) * wdth1 + curx1)/wdth0] + 1},
; where 1 is added for the ellipsis row.

swcc5:  mov   rax, [cury1]              ; Get previous cursor y

; Subtract 1 for anchor row and 1 for ellipsis.

        sub   rax, 2
        mul   qword[wdth1]              ; Multiply by previous window width
        add   rax, [curx1]              ; Add previous cursor x
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbx                       ; Divide by new window width
        add   rax, 1                    ; Increment subtrahend
        jmp   swcc10

; Cursor at end of line.

swcc6:  btr   qword[r15], 9             ; Test/clear scroll flag
        jnc   swcc8                     ; Branch if not scrolling

        btr   qword[r15], 7             ; Test/clear top flag
        jnc   swcc7                     ; Branch if not set

; If cursor is at the end, and the top flag is set, the new anchor
; row is calculated from:
; ancy0 = cury0 - {[(area1 - wdth1 + 3)/wdth0]}

        mov   rax, [area1]              ; Get area of old window
        sub   rax, [wdth1]              ; Subtract old window width
        add   rax, 3                    ; Add 3 for ellipsis
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbx                       ; Divide by new window width
        jmp   swcc10

; If cursor is at the end, and the scroll flag is set, the new anchor
; row is calculated from:
; ancy0 = cury0 - {[(area1 - 2*wdth1 + 3)/wdth0] + 1}

swcc7:  mov   rax, [area1]              ; Get area of old window
        sub   rax, [wdth1]              ; Subtract old window width
        sub   rax, [wdth1]              ; Subtract old window width
        add   rax, 3                    ; Add 3 for ellipsis
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbx                       ; Divide by new window width
        add   rax, 1                    ; Add 1
        jmp   swcc10

; If cursor at the end, scrolling is not in effect,
; and the last row is not empty, the new anchor row
; is given by:
; ancy0 = cury0 - {[(area1 - 2*wdth1 + linx1)/wdth0] + 1},
; where 1 is added for the ellipsis row.

swcc8:  cmp   qword[curx1], 1           ; See if last row is empty
        jz    swcc9                     ; Branch if so

        mov   rax, [area1]              ; Get area
        sub   rax, [wdth1]              ; Subtract previous window width
        sub   rax, [wdth1]              ; twice
        add   rax, [linx1]              ; Add linx1
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbx                       ; Divide by new window width
        add   rax, 1                    ; Increment subtrahend
        jmp   swcc10

; If the last row is empty except for the cursor, the formula becomes:
; ancy0 = cury0 - {[(area1 - 2*wdth1)/wdth0] + 2}
; where 2 is added for the ellipsis row and the cursor row.

swcc9:  mov   rax, [area1]              ; Get area
        sub   rax, [wdth1]              ; Subtract previous window width
        sub   rax, [wdth1]              ; twice
        xor   rdx, rdx                  ; Clear high order dividend
        div   rbx                       ; Divide by new window width
        add   rax, 2                    ; Add 2 to subtrahend

swcc10: mov   rcx, [cury0]
        sub   rcx, rax
        mov   [ancy0], rcx
        jmp   rfra0

; When Ctrl+E is pressed, set amax0 to the current area.

ctre0:  mov   rax, [area0]
        mov   [amax0], rax
        btr   qword[r15], 5             ; Clear freeze flag
        jmp   prer0

; When Esc is pressed, clear current buffer, move to anchor row,
; and erase line.

erln0:  lea   rbp, [erln1]              ; Clear buffer
        jmp   clbf0

erln1:  lea   rbp, [erln2]              ; Move cursor to anchor
        lea   r11, [ancy0]
        jmp   pcxy0

; Erase from anchor y to end of screen.

erln2:  mov   rdi, [sdout]              ; Erase to end of screen
        lea   rsi, [erste]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

        jmp   prer0

; Update Cursor Coordinates.

gtcc0:  mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [gtcrs]              ; Send escape sequence
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Clear 16 quads of bitmask at selct0+16.

gtcc1:  mov   rax, 0
        mov   rcx, 16
        lea   rdi, [selct0]
gtcc2:  mov   [rdi+rcx*8+8], rax
        sub   rcx, 1
        jnz   gtcc2

        mov   qword[rdi+16], 1          ; Set bitmask for standard input
        xor   r8, r8                    ; Timeout indefinite
        xor   rdx, rdx                  ; No outputs
        lea   rsi, [rdi+16]             ; Address of input bitmask
        mov   rdi, 1                    ; Monitor only one input

        strinselectm                    ; select

        bt    rax, 63
        jc    gtcc1

        mov   qword[r15+8], 0           ; Clear I/O buffer
        mov   qword[r15+16], 0

; Read escape sequence.

        mov   rdi, [sdin]               ; Standard handle
        lea   rsi, [r15+8]              ; Where to put result
        mov   rdx, 12

        strinOSCm  read

; Convert ASCII decimal digits to binary.

        mov   r8, 10                    ; Base is 10

        xor   rcx, rcx                  ; Zero count
gtcc3:  cmp   byte[r15+rcx+10], 0x3B    ; Find semicolon
        jz    gtcc4
        add   rcx, 1                    ; Increment count
        jmp   gtcc3

gtcc4:  lea   rdi, [r15+rcx+11]         ; Save address past semicolon

        xor   rax, rax                  ; Zero accumulator
        xor   rsi, rsi                  ; Zero index
gtcc5:  mul   r8                        ; Multiply by base
        movzx rbx, byte[r15+rsi+10]     ; Get first/next byte of y
        sub   rbx, 0x30                 ; Convert from ASCII
        add   rax, rbx                  ; Add to result
        add   rsi, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   gtcc5                     ; Loop if not zero

        mov   [cury0], rax              ; Save y-coordinate

        xor   rcx, rcx                  ; Zero count
gtcc6:  cmp   byte[rdi+rcx], 0x52       ; Find R
        jz    gtcc7
        add   rcx, 1                    ; Increment count
        jmp   gtcc6

gtcc7:  xor   rax, rax                  ; Zero accumulator
        xor   rsi, rsi                  ; Zero index
gtcc8:  mul   r8                        ; Multiply by base
        movzx rbx, byte[rdi+rsi]        ; Get first/next byte of x
        sub   rbx, 0x30                 ; Convert from ASCII
        add   rax, rbx                  ; Add to result
        add   rsi, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   gtcc8                     ; Loop if not zero

        mov   [curx0], rax              ; Save x-coordinate

        jmp   rbp                       ; Return

; Place Cursor.

; Function to place cursor at given coordinates.
; Uses all registers other than r9-r15.

; Place the cursor at the coordinates in two consecutive quads at the address
; passed by the caller in r11. Since we do not know in advance how many digits
; will be generated, they are put in the buffer in reverse order and then
; reordered. The escape sequence is assembled in [r15+8] and [r15+16]
; before being written. Composes <ESC>[{ROW};{COLUMN}H from y and x at the address
; passed by the caller in r11. This routine is rather too complex to use for moving
; the cursor incrementally.

pcxy0:  mov   qword[r15+8], 0           ; Clear I/O buffer
        mov   qword[r15+16], 0

        mov   word[r15+8], 0x5B1B       ; Install Esc[
        mov   rdi, 2                    ; Initialize character count
        mov   r8, 10                    ; Number base is 10

; Process y.

        mov   rax, [r11]                ; Get y
        xor   rcx, rcx                  ; Clear digit count
        xor   rdx, rdx                  ; Clear high order dividend

pcxy1:  cmp   rcx, 4                    ; Limit number of digits to 4
        jz    pcxy3

        div   r8                        ; Divide by base
        add   rdx, 0x30                 ; Convert remainder to ASCII
        mov   [r15+rdi+8], dl           ; Install digit in stack
        add   rdi, 1                    ; Increment character count
        add   rcx, 1                    ; Increment digit count
        test  rax, rax                  ; Test for zero
        jz    pcxy2                     ; Branch if zero
        xor   rdx, rdx                  ; Clear remainder
        jmp   pcxy1                     ; Loop

pcxy2:  cmp   rcx, 4
        jnz   pcxy4

; Reverse 4 bytes.

pcxy3:  mov   al, [r15+10]
        mov   bl, [r15+rdi+7]
        mov   [r15+10], bl
        mov   [r15+rdi+7], al
        mov   al, [r15+11]
        mov   bl, [r15+rdi+6]
        mov   [r15+11], bl
        mov   [r15+rdi+6], al
        jmp   pcxy5

pcxy4:  cmp   rcx, 2
        jc    pcxy5

; Reverse 2 or 3 bytes.

        mov   al, [r15+10]
        mov   bl, [r15+rdi+7]
        mov   [r15+10], bl
        mov   [r15+rdi+7], al

pcxy5:  mov   byte[r15+rdi+8], 0x3B     ; Install semicolon
        add   rdi, 1                    ; Increment character count

; Process x.

        mov   rsi, rdi                  ; Save current character count
        mov   rax, [r11+8]              ; Get x
        xor   rcx, rcx                  ; Clear digit count
        xor   rdx, rdx                  ; Clear high order dividend

pcxy6:  cmp   rcx, 4                    ; Limit number of digits to 4
        jz    pcxy8

        div   r8                        ; Divide by base
        add   rdx, 0x30                 ; Convert to ASCII
        mov   [r15+rdi+8], dl           ; Install digit in stack
        add   rdi, 1                    ; Increment character count
        add   rcx, 1                    ; Increment digit count
        test  rax, rax                  ; Test for zero
        jz    pcxy7                     ; Branch if zero
        xor   rdx, rdx                  ; Clear remainder
        jmp   pcxy6                     ; Loop

pcxy7:  cmp   rcx, 4
        jnz   pcxy9

; Reverse 4 bytes.

pcxy8:  mov   al, [r15+rsi+8]
        mov   bl, [r15+rdi+7]
        mov   [r15+rsi+8], bl
        mov   [r15+rdi+7], al
        mov   al, [r15+rsi+9]
        mov   bl, [r15+rdi+6]
        mov   [r15+rsi+9], bl
        mov   [r15+rdi+6], al
        jmp   pcxy10

pcxy9:  cmp   rcx, 2
        jc    pcxy10

; Reverse 2 or 3 bytes.

        mov   al, [r15+rsi+8]
        mov   bl, [r15+rdi+7]
        mov   [r15+rsi+8], bl
        mov   [r15+rdi+7], al

pcxy10: mov   byte[r15+rdi+8], 0x48     ; Install H
        add   rdi, 1                    ; Increment character count

; Output escape sequence.

        mov   rdx, rdi                  ; Copy character count
        mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]              ; Load buffer address

        strinOSCm  write

        jmp   rbp                       ; Return

; Terminate Keyboard Input.

; Complete line entry if buffer is not empty.

fnsh0:  cmp   r10, 0                    ; See if buffer is empty
        jz    prer0                     ; Loop if so

        mov   [r12-8], r10              ; Install final line length
        mov   [bchc0], r10              ; Install in bcc

; If Enter was pressed while in scroll mode, when the line is too big
; for the window, restore the cursor.

        btr   qword[r15], 9             ; Test/clear scroll flag
        jnc   fnsh1                     ; Finish if not scrolling

; Show the cursor.

        mov   rdi, [sdout]
        lea   rsi, [shcsr]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Write entire line from anchor row.

fnsh1:  lea   rbp, [fnsh2]              ; Move cursor to anchor
        lea   r11, [ancy0]
        jmp   pcxy0

; Erase from anchor y to end of screen.

fnsh2:  mov   rdi, [sdout]              ; Erase to end of screen
        lea   rsi, [erste]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

; Write line

        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r12                  ; Where to start writing
        mov   rdx, [rsi-8]              ; Get string length

        strinOSCm  write

        lea   rbp, [fnsh3]              ; Set return address
        jmp   gtcc0                     ; Get cursor coordinates

fnsh3:  mov   rcx, [curx0]              ; Get cursor x
        cmp   rcx, [wdth0]              ; Compare with window width
        jnz   fnsh6                     ; Branch if not equal

        mov   qword[curx0], 1           ; Set cursor x to 1

        mov   rcx, [hght0]              ; Get window height
        cmp   rcx, [cury0]              ; Compare cursor y
        jz    fnsh4                     ; Branch if equal

        add   qword[cury0], 1           ; Increment cursor y
        jmp   fnsh5

fnsh4:  mov   rdi, [sdout]              ; Output linefeed
        lea   rsi, [linfd]
        mov   rdx, [rsi]
        add   rsi, 8

        strinOSCm  write

fnsh5:  lea   rbp, [fnsh6]              ; Place cursor
        lea   r11, [cury0]
        jmp   pcxy0

fnsh6:  mov   qword[r15+8], 0x20        ; Output a space
        mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [r15+8]
        mov   rdx, 1

        OSCm  write

; Exit raw mode.

; Restore attribute state after flushing with TCSAFLUSH as the second parameter.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        lea   rdx, [trmio0]

        CFCm  tcsetattr

        mov   r12, [r15+56]             ; Restore r12
        mov   r13, [r15+64]             ; Restore r13
        add   r15, 120                  ; Release rstack frame
        btr   qword[flgs0], 18          ; Clear strin flag
        nextm

; Vector Offset Tables
;
; Table entries are:
;
; 0  - Do nothing (loop)
; 1  - finish if entered character is ipt
; 2  - Install character
; 3  - Backspace
; 4  - Ctrl+E
; 5  - Delete
; 6  - Previous buffer
; 7  - Next buffer
; 8  - Cursor forward
; 9  - Cursor back
; A  - Finish on Home
; B  - Cursor up
; C  - Cursor down
; D  - Scroll buffer up one line
; E  - Scroll buffer down one line
; F  - Scroll buffer up one page
; 10 - Scroll buffer down one page
; 11 - Erase current line

; Vector offset table for normal processing

tbls0:  dq  0x0000040000000000, 0x0000010000000000  ; bytes 0-15
        dq  0x0000000000000000, 0x0000000011000000  ; bytes 16-31
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 22-47
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 48-62
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 64-79
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 80-95
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 96-111
        dq  0x0202020202020202, 0x0302020202020202  ; bytes 112-127
        dq  0x0C0B0A0908070605, 0x00000000100F0E0D  ; bytes 128-143
times 7 dq  0x0000000000000000, 0x0000000000000000  ; bytes 144-255

; Vector offset table for scrolling

tbls1:  dq  0x0000000000000000, 0x0000010000000000  ; bytes 0-15
        dq  0x0000000000000000, 0x0000000000000000  ; bytes 16-31
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 22-47
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 48-62
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 64-79
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 80-95
        dq  0x0202020202020202, 0x0202020202020202  ; bytes 96-111
        dq  0x0202020202020202, 0x0002020202020202  ; bytes 112-127
        dq  0x00000A0000070600, 0x00000000100F0E0D  ; bytes 128-143
times 7 dq  0x0000000000000000, 0x0000000000000000  ; bytes 144-255

vtbl0:

; 0
        dq   prer0                      ; Loop
; 1
        dq   qend0                      ; Finish on Enter
; 2
        dq   apns0                      ; Append/Insert
; 3
        dq   bksp0                      ; Backspace
; 4
        dq   ctre0                      ; Ctrl+E
; 5
        dq   dlet0                      ; Delete
; 6
        dq   prbf0                      ; Previous buffer
; 7
        dq   nxbf0                      ; Next buffer
; 8
        dq   crfd0                      ; Cursor Forward
; 9
        dq   crbk0                      ; Cursor Back
; A
        dq   qend1                      ; Finish on Home
; B
        dq   crup0                      ; Cursor up
; C
        dq   crdn0                      ; Cursor down
; D
        dq   bfup0                      ; Scroll buffer up one line
; E
        dq   bfdn0                      ; Scroll buffer down one line
; F
        dq   pgup0                      ; Scroll buffer up one page
; 10
        dq   pgdn0                      ; Scroll buffer down one page
; 11
        dq   erln0                      ; Erase current line

datam

; key - Wait for key press without echo and place result on stack.
; Uses the strin flag to disallow Ctrl+C and Ctrl+Z while waiting.
; Note that it isn't necessary to use tcflush to empty the kib
; after obtaining the keypress, since the last call to tcsetattr does
; this when the 2nd parameter is set to TCSAFLUSH (2).

head    "key", inpo
key:    dq  gkey0
textm
gkey0:  sub   r14, 8                    ; Make room on stack
        mov   qword[r14], 0             ; Initialize it

        bts   qword[flgs0], 18          ; Set strin flag

; Set terminal to raw mode.

        lea   rbx, [trmio0]             ; Address of original structure
        lea   rbp, [trmin0]             ; Address of new structure

; Save attribute state at trmio0.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, rbx

        CFCm  tcgetattr

; Copy attribute state to new structure at trmin0.

        mov   rdi, rbp
        mov   rsi, rbx
        mov   rcx, 8                    ; Save 8 quads
gkey1:  mov   rax, [rsi+rcx*8-8]
        mov   [rdi+rcx*8-8], rax
        sub   rcx, 1
        jnz   gkey1

; Clear c_iflag bits BRKINT, ICRNL, and IXON. The c_iflag bitmask is at offset
; 0 in the termios structure.

        mov   eax, [brkint]             ; Clear BRKINT bit
        not   eax
        and   [rbp], eax

        mov   eax, [icrnl]              ; Clear ICRNL bit
        not   eax
        and   [rbp], eax

        mov   eax, [ixon]               ; Clear IXON bit
        not   eax
        and   [rbp], eax

; Clear c_oflag bit OPOST. The c_oflag bitmask is at offset 4 in the termios
; structure.

        mov   eax, [opost]              ; Clear OPOST bit
        not   eax
        and   [rbp+4], eax

; Set c_cflag for CS8 (default). The c_cflag bitmask is at offset 8
; in the termios structure.

        mov   eax, [cs8]                ; Set CS8 bitmask
        or    [rbp+8], eax

; Clear c_lflag bits ICANON, ECHO, and IEXTEN. Set ISIG (default).
; The ISIG bit controls whether Ctrl+C, Ctrl+Z, and Ctrl+\ are active.
; The c_lflag bitmask is at offset 12 in the termios structure.

        mov   eax, [icanon]             ; Clear ICANON bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [echo]               ; Clear ECHO bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [iexten]             ; Clear IEXTEN bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [isig]               ; Set ISIG bit
        or    [rbp+12], eax

; Variables VMIN and VTIME in the c_cc array should be set to 1 and 0
; respectively, but these are the default settings with ICANON disabled.

; Call to set new attribute state after flushing by setting the second
; parameter to TCSAFLUSH (2).

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        mov   rdx, rbp

        CFCm  tcsetattr

; Use select() to wait for keypress. Structure is at selct0.

; Clear 16 quads of bitmask at selct0+16.

gkey2:  mov   rax, 0
        mov   rcx, 16
        lea   rdi, [selct0]
gkey3:  mov   [rdi+rcx*8+8], rax
        sub   rcx, 1
        jnz   gkey3

; The select() call blocks until input is available. The function is reentered
; if a SIGWINCH signal causes it to return a -1.

        mov   qword[rdi+16], 1          ; Set bitmask for standard input
        xor   r8, r8                    ; Timeout indefinite
        xor   r10, r10                  ; No exceptions
        xor   rdx, rdx                  ; No outputs
        lea   rsi, [rdi+16]             ; Address of input bitmask
        mov   rdi, 1                    ; Monitor only one input

        OSCm  select

        bt    rax, 63
        jc    gkey2

; Read single character.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, r14                  ; Put character on stack
        mov   rdx, 1                    ; Get 1 character

        OSCm  read

; Exit raw mode.

; Restore attribute state after flushing with TCSAFLUSH as the second parameter.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        mov   rdx, rbx

        CFCm  tcsetattr

        btr   qword[flgs0], 18          ; Clear strin flag

        nextm
datam

; escape - Wait for key press without echo and place result on stack. The result
; may be an escape sequence of up to eight characters. This is the same as `key`,
; but if simultaneous key strokes form an escape sequence, this is put on the
; stack. The Ctrl+C and Ctrl+Z combos are disabled while waiting by their
; respective signal handlers.

head    "escape", inpo
escp:   dq  escp0
textm
escp0:  sub   r14, 8                    ; Make room on stack
        mov   qword[r14], 0             ; Initialize it

        bts   qword[flgs0], 18          ; Set strin flag

; Set terminal to raw mode.

        lea   rbx, [trmio0]             ; Address of original structure
        lea   rbp, [trmin0]             ; Address of new structure

; Save attribute state at trmio0.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, rbx

        CFCm  tcgetattr

; Copy attribute state to new structure at trmin0.

        mov   rdi, rbp
        mov   rsi, rbx
        mov   rcx, 8                    ; Save 8 quads
escp1:  mov   rax, [rsi+rcx*8-8]
        mov   [rdi+rcx*8-8], rax
        sub   rcx, 1
        jnz   escp1

; Clear c_iflag bits BRKINT, ICRNL, and IXON. The c_iflag bitmask is at offset
; 0 in the termios structure.

        mov   eax, [brkint]             ; Clear BRKINT bit
        not   eax
        and   [rbp], eax

        mov   eax, [icrnl]              ; Clear ICRNL bit
        not   eax
        and   [rbp], eax

        mov   eax, [ixon]               ; Clear IXON bit
        not   eax
        and   [rbp], eax

; Clear c_oflag bit OPOST. The c_oflag bitmask is at offset 4 in the termios
; structure.

        mov   eax, [opost]              ; Clear OPOST bit
        not   eax
        and   [rbp+4], eax

; Set c_cflag for CS8 (default). The c_cflag bitmask is at offset 8
; in the termios structure.

        mov   eax, [cs8]                ; Set CS8 bitmask
        or    [rbp+8], eax

; Clear c_lflag bits ICANON, ECHO, and IEXTEN. Set ISIG (default).
; The ISIG bit controls whether Ctrl+C, Ctrl+Z, and Ctrl+\ are active.
; The c_lflag bitmask is at offset 12 in the termios structure.

        mov   eax, [icanon]             ; Clear ICANON bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [echo]               ; Clear ECHO bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [iexten]             ; Clear IEXTEN bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [isig]               ; Set ISIG bit
        or    [rbp+12], eax

; Variables VMIN and VTIME in the c_cc array should be set to 1 and 0
; respectively, but these are the default settings with ICANON disabled.

; Call to set new attribute state after flushing by setting the second
; parameter to TCSAFLUSH (2).

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        mov   rdx, rbp

        CFCm  tcsetattr

; Use select() to wait for keypress. Structure is at selct0.

; Clear 16 quads of bitmask at selct0+16.

escp2:  mov   rax, 0
        mov   rcx, 16
        lea   rdi, [selct0]
escp3:  mov   [rdi+rcx*8+8], rax
        sub   rcx, 1
        jnz   escp3

; The select() call blocks until input is available. The function is reentered
; if a SIGWINCH signal causes it to return a -1.

        mov   qword[rdi+16], 1          ; Set bitmask for standard input
        xor   r8, r8                    ; Timeout indefinite
        xor   r10, r10                  ; No exceptions
        xor   rdx, rdx                  ; No outputs
        lea   rsi, [rdi+16]             ; Address of input bitmask
        mov   rdi, 1                    ; Monitor only one input

        OSCm  select

        bt    rax, 63
        jc    escp2

; Read up to eight characters.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, r14                  ; Put character on stack
        mov   rdx, 8                    ; Get up to 8 characters

        OSCm  read

; Exit raw mode.

; Restore attribute state after flushing with TCSAFLUSH as the second parameter.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        mov   rdx, rbx

        CFCm  tcsetattr

        btr   qword[flgs0], 18          ; Clear strin flag

        nextm
datam

; I/O Section

; *** Output Operators

; emit - output a character to the terminal

head    "emit", oupo
emit:   dq  emit0
textm
emit0:  mov   rdi, [sdout]
        mov   rsi, r14                  ; String address
        mov   rdx, 1                    ; One character

        OSCm  write

        add   r14, 8                    ; Pop stack
        mov   rbx, [curx0]              ; Get cursor position
        cmp   [wdth0], rbx              ; Compare with terminal width
        jz    emit1                     ; Branch if equal
        add   qword[curx0], 1           ; Increment cursor position
        jmp   emit2                     ; Exit

emit1:  mov   qword[curx0], 1           ; Reset curcol to 1st position

        mov   rbx, [cury0]              ; Get current row
        cmp   rbx, [hght0]              ; Compare with screen height
        jz    emit2                     ; Branch if equal

        add   qword[cury0], 1           ; Else increment row

emit2:  nextm
datam

; cr - Output a linefeed. Update cursor column and row.

head    "cr", oupo
cr:     dq  crtn0
textm
crtn0:  sub   r15, 8                    ; Create cell on return stack
        mov   qword[r15], 10            ; Install newline character
        mov   rdi, [sdout]
        mov   rsi, r15                  ; String address
        mov   rdx, 1                    ; One character

        OSCm  write

        add   r15, 8                    ; Restore stack
        mov   qword[curx0], 1           ; Reset cursor column
        mov   rbx, [cury0]              ; Get current row
        cmp   rbx, [hght0]              ; Compare with screen height
        jz    crtn1                     ; Branch if equal

        add   qword[cury0], 1           ; Else increment row

crtn1:  nextm
datam

; strout - ( addr cnt --- ) Output string of length cnt at addr. Update cursor
; coordinates.

head    "strout", oupo
strout: dq  stro0
textm
stro0:  mov   rbx, [r14]                ; Get string length
        add   rbx, [curx0]              ; Add cursor x
        cmp   [wdth0], rbx              ; Compare with terminal width
        jnc   stro3                     ; Branch if not larger

        mov   rax, rbx                  ; Copy curcol + string length
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by terminal width
        mov   rbx, rdx                  ; Copy new cursor position
        mov   rbp, rax                  ; Save number of lines

        mov   rax, [cury0]              ; Get current row
        add   rax, rbp                  ; Add number of new lines
        cmp   [hght0], rax              ; Compare with screen height
        jnc   stro2                     ; Branch if not larger

        mov   rax, [hght0]              ; Use height for y-coordinate

stro2:  mov   [cury0], rax              ; Install new y-coordinate

stro3:  mov   [curx0], rbx              ; Install new x-coordinate

; Write string.

        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, [r14+8]              ; Address of string
        mov   rdx, [r14]                ; Length of string

        OSCm  write

        add   r14, 16                   ; Pop stack
        nextm
datam

; ?strout - This word is the same as strout above, but if the cursor
; is too close to the end of the line to accommodate the word,
; a carriage return is output first. Throws 70 if a string is too big
; for a single line. The purpose is to prevent words from being broken
; across a newline. Words may not be longer than the terminal width.

head    "?strout", oupo
qstout: dq  qsou0
textm
qsou0:  mov   rbp, [r14]                ; Get string length
        cmp   [wdth0], rbp              ; Compare with teminal width
        jc    qsou2                     ; Error if greater

        mov   rbx, [curx0]              ; Get cursor position
        add   rbx, rbp                  ; Add string length
        cmp   [wdth0], rbx              ; Compare with terminal width
        jg    qsou3                     ; Branch if not greater

; Output newline.

        sub   r15, 8                    ; Make room on return stack
        mov   qword[r15], 10            ; Install newline character
        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r15                  ; Address of string
        mov   rdx, 1                    ; One character

        OSCm  write

        add   r15, 8                    ; Pop return stack

        mov   rcx, [cury0]              ; Get cursor row
        add   rcx, 1                    ; Add 1 for newline
        cmp   [hght0], rcx              ; Compare with screen height
        jnc   qsou1                     ; Branch if not larger

        mov   rcx, [hght0]              ; Use height for current row

qsou1:  mov   [cury0], rcx              ; Update row

        mov   rbx, rbp                  ; Set to update
        add   rbx, 1                    ; cursor column

        jmp   qsou3

qsou2:  mov   qword[curx0], 1           ; Reset cursor position
        add   r14, 16                   ; Pop stack

        throwm 70                       ; Throw error

qsou3:  mov   rdi, [sdout]              ; Standard handle
        mov   rsi, [r14+8]              ; Address of string
        mov   rdx, [r14]                ; Length of string

        OSCm  write

        mov   [curx0], rbx              ; Install new cursor position
        add   r14, 16                   ; Pop stack
        nextm
datam

; padchrs - ( n --- ) output n pad characters at cursor position. Does nothing
; if n is not greater than zero.

head    "padchrs", oupo
padcs:  dq  padc0
textm

padc0:  cmp   qword[r14], 0             ; Do nothing unless count is >0
        jle   padc4

        mov   rbp, [r14]                ; Get number of characters
        mov   rbx, rbp                  ; Make copy
        add   rbx, [curx0]              ; Add current cursor x-coordinate
        cmp   [wdth0], rbx              ; Compare with terminal width
        jnc   padc2                     ; Branch if not larger

        mov   rax, rbx                  ; Copy curcol + string length
        xor   rdx, rdx                  ; Clear high order dividend
        div   qword[wdth0]              ; Divide by terminal width
        mov   rbx, rdx                  ; Copy new cursor position
        add   rax, [cury0]              ; Add current row to new lines
        cmp   [hght0], rax              ; Compare with screen height
        jnc   padc1                     ; Branch if not larger

        mov   rax, [hght0]              ; Use height for y-coordinate

padc1:  mov   [cury0], rax              ; Install new y-coordinate

padc2:  mov   [curx0], rbx              ; Install new x-coordinate

        lea   rsi, [pdch0]              ; Load character address
padc3:  mov   rdi, [sdout]              ; Standard handle
        mov   rdx, 1                    ; Length 1

        OSCm  write

        sub   rbp, 1                    ; Decrement count
        jnz   padc3                     ; Loop

padc4:  add   r14, 8                    ; Pop stack
        nextm
datam

; ?spaces - Output the number of spaces passed on the stack, or the number of
; spaces left in the current line.

head    "?spaces", oupo
qspacs: dq  qspc0
textm
qspc0:  mov   rbx, [r14]                ; Get number of spaces
        cmp   rbx, 0                    ; See if zero or negative
        jle   qspc4                     ; Exit if so

        cmp   qword[curx0], 1           ; See if curcol is 1
        jz    qspc4                     ; Do nothing if so

        mov   r9, [wdth0]               ; Get terminal width
        mov   qword[r14], 32            ; Put space on stack
        sub   r9, [curx0]               ; Subtract cursor position
        cmp   r9, rbx                   ; Compare number of spaces
        jg    qspc2                     ; Branch if room for spaces

; If no room for spaces on current line or just enough room, output newline
; and reset cursor position.

        mov   qword[r14], 10            ; Install newline character
        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r14                  ; Address of string
        mov   rdx, 1                    ; One character

        OSCm  write

        mov   rcx, [cury0]              ; Get cursor row
        add   rcx, 1                    ; Add 1 for newline
        cmp   [hght0], rcx              ; Compare with screen height
        jnc   qspc1                     ; Branch if not larger

        mov   rcx, [hght0]              ; Use height for current row

qspc1:  mov   [cury0], rcx              ; Update row

        mov   qword[curx0], 1           ; Reset cursor position
        jmp   qspc4

qspc2:  add   [curx0], rbx              ; Add number of spaces to curcol

qspc3:  mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r14                  ; Copy character address
        mov   rdx, 1                    ; Length 1

        OSCm  write

        sub   rbx, 1                    ; Decrement count
        jnz   qspc3                     ; Loop

qspc4:  add   r14, 8

        nextm
datam

; .ascii - Output the top stack quad as an ASCII string. Non-printable characters
; are replaced with the byte preceding the code field - default 0x2e (.).
; Note: This version does nothing with the curctl variables. I will see what effect
; this may have.

head    ".ascii"
dotasc: dq  dtas0
        dq  0x2e
textm
dtas0:  lea   rdi, [dstack0]            ; Make sure there is a value
        cmp   rdi, r14                  ; on the stack
        jnz   dtas1

        throwm 69

dtas1:  mov   rdx, [r11+8]              ; Get substitute char

        mov   rcx, 8
dtas2:  cmp   byte[r14+rcx-1], 0x21
        jc    dtas3
        cmp   byte[r14+rcx-1], 0x7f
        jc    dtas4
dtas3:  mov   [r14+rcx-1], dl
dtas4:  sub   rcx, 1
        jnz   dtas2

        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r14                  ; String address
        mov   rdx, 8                    ; Eight characters

        OSCm  write

        add   r14, 8                    ; Pop stack
        nextm
datam

; *.ascii - ( i*x n --- j*x ) Output n quads on the stack as an ASCII string.
; Non-printable characters are replaced with the byte preceding the code field -
; default 0x2e (.). As a practical matter a maximum of 4096 quads are allowed.
; Throws error if the requested number of items is not between 1 and 4096 inclusive,
; or if the requested number of items is not actually present.
; Note: This version does nothing with the curctl variables. I will see what effect
; this may have.

head    "*.ascii"
stdta:  dq  stda0
        dq  0x2e
textm
stda0:  mov   rbx, [r14]                ; Get item count
        add   rbx, 1                    ; Add 1 for count

; Make sure there are enough items on the stack.

        lea   rdi, [dstack0]            ; Get initial stack pointer
        sub   rdi, r14                  ; Subtract current stack pointer
        shr   rdi, 3                    ; Convert to byte count
        cmp   rdi, rbx                  ; Compare items needed
        jnc   stda1                     ; Branch if sufficient

        throwm 69

stda1:  add   r14, 8                    ; Pop stack
        sub   rbx, 1                    ; Subtract count
        cmp   rbx, 4096                 ; Error if > 4096
        jnc   stda2

        cmp   rbx, 1                    ; Error if < 1
        jnc   stda3

stda2: throwm 13

stda3:  shl   rbx, 3                    ; Convert quads to byte count
        mov   rcx, rbx                  ; Make copy
        mov   rdx, [r11+8]              ; Get substitute char
stda4:  cmp   byte[r14+rcx-1], 0x21
        jc    stda5
        cmp   byte[r14+rcx-1], 0x7f
        jc    stda6
stda5:  mov   [r14+rcx-1], dl
stda6:  sub   rcx, 1
        jnz   stda4

        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r14                  ; String address
        mov   rdx, rbx                  ; Copy # bytes to write

        OSCm  write

        add   r14, rbx                  ; Pop stack
        nextm
datam

; .flags ( rFLAGS-quadword --- ) - Output flags quad in table format.
; The flags are shown in the order, CZSOAPTID, with the Carry, Zero, Sign,
; and Overflow flags on the left. The remaining flags are less relevant
; to coding.

head    ".flags",oupo
dtfg:   dq  dtfg0
textm
dtfg0:  lea   rdi, [dstack0]            ; Make sure there is a value
        cmp   rdi, r14                  ; on the stack
        jnz   dtfg1

        throwm 69

dtfg1:  mov   rbx, [r14]                ; Get flags quad
        add   r14, 8

        mov   rcx, 0x30435B1B           ; Load sequence for 0 bit
        mov   rdx, 0x31435B1B           ; Load sequence for 1 bit

; Assemble output string in sflgs1 area.

        lea   rdi, [sflgs1]

        bt    rbx, 0                    ; Test Carry bit
        jc    dtfg2                     ; Branch if set
        mov   dword[rdi], ecx           ; Install 0 sequence
        jmp   dtfg3                     ; Branch to test next flag
dtfg2:  mov   dword[rdi], edx           ; Install 1 sequence

dtfg3:  bt    rbx, 6                    ; Test Zero bit
        jc    dtfg4
        mov   dword[rdi+4], ecx
        jmp   dtfg5
dtfg4:  mov   dword[rdi+4], edx

dtfg5:  bt    rbx, 7                    ; Test Sign bit
        jc    dtfg6
        mov   dword[rdi+8], ecx
        jmp   dtfg7
dtfg6:  mov   dword[rdi+8], edx

dtfg7:  bt    rbx, 11                   ; Test Overflow bit
        jc    dtfg8
        mov   dword[rdi+12], ecx
        jmp   dtfg9
dtfg8:  mov   dword[rdi+12], edx

dtfg9:  bt    rbx, 4                    ; Auxiliary Carry bit
        jc    dtfg10
        mov   dword[rdi+16], ecx
        jmp   dtfg11
dtfg10: mov   dword[rdi+16], edx

dtfg11: bt    rbx, 2                    ; Test Parity bit
        jc    dtfg12
        mov   dword[rdi+20], ecx
        jmp   dtfg13
dtfg12: mov   dword[rdi+20], edx

dtfg13: bt    rbx, 8                    ; Test Trap bit
        jc    dtfg14
        mov   dword[rdi+24], ecx
        jmp   dtfg15
dtfg14: mov   dword[rdi+24], edx

dtfg15: bt    rbx, 9                    ; Test Interrupt bit
        jc    dtfg16
        mov   dword[rdi+28], ecx
        jmp   dtfg17
dtfg16: mov   dword[rdi+28], edx

dtfg17: bt    rbx, 10                   ; Test Direction bit
        jc    dtfg18
        mov   dword[rdi+32], ecx
        jmp   dtfg19
dtfg18: mov   dword[rdi+32], edx

; Write entire string in one go.

dtfg19: mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [sflgs0+8]           ; Address of string
        mov   rdx, [rsi-8]              ; Length of string

        OSCm  write

        nextm
datam

; .bits ( quadword --- ) - Display a table of bit numbers and values
; for the top stack quad.

head    ".bits", oupo
dtbits: dq  dtbt0
textm
dtbt0:  lea   rdi, [dstack0]            ; Make sure there is a value
        cmp   rdi, r14                  ; on the stack
        jnz   dtbt1

        throwm 69

dtbt1:  mov   rbx, [r14]                ; Get quad
        add   r14, 8
        mov   r8, 0x3020435B1B          ; Load sequence for 0 bit
        mov   r9, 0x3120435B1B          ; Load sequence for 1 bit

        cmp   qword[wdth0], 49
        jnc   dtbt2

        throwm 102

dtbt2:  cmp   qword[wdth0], 97
        jc    dtbb0

; Install 1st 32 bit-values.

        lea   rdi, [sbtsa1]             ; Get address of data area

        mov   rcx, 32                   ; Set count
        xor   rdx, rdx                  ; Zero address offset

dtba1:  shl   rbx, 1                    ; Shift operand and
        jc    dtba2                     ; branch if bit set
        mov   [rdi+rdx], r8             ; Install 0-bit sequence
        jmp   dtba3
dtba2:  mov   [rdi+rdx], r9             ; Install 1-bit sequence
dtba3:  add   rdx, 5                    ; Advance address offset
        sub   rcx, 1
        jnz   dtba1

; Install 2nd 32 bit-values.

        lea   rdi, [sbtsa2]             ; Get address of data area

        mov   rcx, 32                   ; Set count
        xor   rdx, rdx                  ; Zero address offset

dtba4:  shl   rbx, 1                    ; Shift operand and
        jc    dtba5                     ; branch if bit set
        mov   [rdi+rdx], r8             ; Install 0-bit sequence
        jmp   dtba6
dtba5:  mov   [rdi+rdx], r9             ; Install 1-bit sequence
dtba6:  add   rdx, 5                    ; Advance address offset
        sub   rcx, 1
        jnz   dtba4

        lea   rsi, [sbtsa0+8]           ; Address of string
        jmp   dtbt3

; Install 1st 16 bit-values.

dtbb0:  lea   rdi, [sbtsb1]             ; Get address of data area

        mov   rcx, 16                   ; Set count
        xor   rdx, rdx                  ; Zero address offset

dtbb1:  shl   rbx, 1                    ; Shift operand and
        jc    dtbb2                     ; branch if bit set
        mov   [rdi+rdx], r8             ; Install 0-bit sequence
        jmp   dtbb3
dtbb2:  mov   [rdi+rdx], r9             ; Install 1-bit sequence
dtbb3:  add   rdx, 5                    ; Advance address offset
        sub   rcx, 1
        jnz   dtbb1

; Install 2nd 16 bit-values.

        lea   rdi, [sbtsb2]             ; Get address of data area

        mov   rcx, 16                   ; Set count
        xor   rdx, rdx                  ; Zero address offset

dtbb4:  shl   rbx, 1                    ; Shift operand and
        jc    dtbb5                     ; branch if bit set
        mov   [rdi+rdx], r8             ; Install 0-bit sequence
        jmp   dtbb6
dtbb5:  mov   [rdi+rdx], r9             ; Install 1-bit sequence
dtbb6:  add   rdx, 5                    ; Advance address offset
        sub   rcx, 1
        jnz   dtbb4

; Install 3rd 16 bit-values.

        lea   rdi, [sbtsb3]             ; Get address of data area

        mov   rcx, 16                   ; Set count
        xor   rdx, rdx                  ; Zero address offset

dtbb7:  shl   rbx, 1                    ; Shift operand and
        jc    dtbb8                     ; branch if bit set
        mov   [rdi+rdx], r8             ; Install 0-bit sequence
        jmp   dtbb9
dtbb8:  mov   [rdi+rdx], r9             ; Install 1-bit sequence
dtbb9:  add   rdx, 5                    ; Advance address offset
        sub   rcx, 1
        jnz   dtbb7

; Install 4th 16 bit-values.

        lea   rdi, [sbtsb4]             ; Get address of data area

        mov   rcx, 16                   ; Set count
        xor   rdx, rdx                  ; Zero address offset

dtbb10: shl   rbx, 1                    ; Shift operand and
        jc    dtbb11                    ; branch if bit set
        mov   [rdi+rdx], r8             ; Install 0-bit sequence
        jmp   dtbb12
dtbb11: mov   [rdi+rdx], r9             ; Install 1-bit sequence
dtbb12: add   rdx, 5                    ; Advance address offset
        sub   rcx, 1
        jnz   dtbb10

        lea   rsi, [sbtsb0+8]           ; Address of string

; Write entire string in one go.

dtbt3:  mov   rdi, [sdout]              ; Standard handle
        mov   rdx, [rsi-8]              ; Length of string

        OSCm  write

        nextm
datam

; gpid - Return the process id of forthx to the stack.

head    "gpid", hsto
gpid:   dq  gpid0
textm
gpid0:  sub   r14, 8

        OSCm  getpid

        mov   [r14], rax
        nextm
datam

; shell" - ( --- ) Execute shell command from inside Forthx64.
; A useful example of a precompiled shell" command (ascii) follows.
; Normally, control doesn't return to Forthx64 until the command completes.
; This means that if you open another program using shell", Forthx64 won't regain
; control until that program is closed. To open a program and return control to
; Forthx64, append the ampersand (&) to the command. For example,
;
;   shell" gedit &"
;
; will open gedit, while Forthx64 will still be available.

head    'shell"', -hlfo
shellq: dq  docl0
        dq  stat,nzbran,shlq1
        dq  axbn,dbqt,dlmwrd
        dq  shell,bran,shlq2
shlq1:  dq  pcomp,pshlq,dbqt,azword,drop
shlq2:  dq  semis
pshlq:  dq  shel0
textm
shel0:  mov   rdi, r12                  ; Copy r12
        add   rdi, 16                   ; Advance to string
        add   r12, [r12]                ; Advance IP past string

        CFCErrm system                  ; Call system

        nextm
datam

; The following two pass-through commands may not be installed in your distro.
; To install them use:

; Ubuntu,

;    sudo apt install ascii cpuid

; Fedora,

;    sudo dnf install ascii cpuid

; Arch,

;    sudo pacman -S ascii cpuid

; openSUSE

;    sudo zypper install ascii cpuid

; This can be done from within Forthx64 using, for example:

;    shell" sudo apt-get install ascii cpuid"

; ascii - Display the ASCII table. The ascii shell command must be installed
; in the host OS.

; : ascii   shell" ascii" ;

head    "ascii", hlfo
ascii:  dq  docl0
        dq  cr,pshlq
        dq  24
        casczm "ascii"
        dq  semis

; lscpu - Display information about the CPU.

; : lscpu   shell" lscpu" ;

head    "lscpu", hlfo
lscpu:  dq  docl0
        dq  cr,pshlq
        dq  24
        casczm "lscpu"
        dq  semis

; cpuid - Display detailed information about the CPU. The cpuid shell command
; must be installed in the host OS.
; Note that this produces a lot of information, and it will duplicate this
; information for each core in a multicore system. Therefore it is passed
; the parameter, -1, to limit the output to one core only.

; : cpuid   shell" cpuid" ;

head    "cpuid", hlfo
cpuinf: dq  docl0
        dq  cr,pshlq
        dq  32
        casczm "cpuid -1"
        dq  semis

; Low-level file I/O

; Return read/write access method.

head    "r/w"
rdwrt:  dq  rdwr0
textm
rdwr0:  mov   rdx, [o_rdwr]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; Return read-only access method.

head    "r/o"
rdonly: dq  rdon0
textm
rdon0:  mov   rdx, [o_rdonly]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; Return write-only access method.

head    "w/o"
wtonly: dq  wton0
textm
wton0:  mov   rdx, [o_wronly]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; Return o_creat access method.

head    "o_creat"
ocreat: dq  ocre0
textm
ocre0: mov   rdx, [o_creat]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; Return o_trunc access method.

head    "o_trunc"
otrunc: dq  otnc0
textm
otnc0: mov   rdx, [o_trunc]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; Return o_append access method.

head    "o_append"
oapnd:  dq  oapd0
textm
oapd0:  mov   rdx, [o_append]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; create-file ( c-addr fam permissions --- fileid )
; This function does not return an I/O result code, since it either returns
; a fileid or throws an error.

head    "create-file", hsto
creatf: dq  cref0
textm
cref0:  mov   rdi, [r14+16]             ; Get address of path string
        mov   rsi, [r14+8]              ; Get file access method
        mov   rdx, [r14]                ; Get permissions
        add   r14, 16                   ; Pop two stack items

        OSCErrm open

        mov   [r14], rax                ; Return fileid
        nextm
datam

; open-file ( c-addr fam --- fileid )
; This function does not return an I/O result code, since it either returns
; a fileid or throws an error.

head    "open-file", hsto
openf:  dq  opnf0
textm
opnf0:  mov   rdi, [r14+8]              ; Get address of pathname
        mov   rsi, [r14]                ; Get file access method
        xor   rdx, rdx                  ; Null mode
        add   r14, 8                    ; Pop one stack item

        OSCErrm open

        mov   [r14], rax                ; Return fileid
        nextm
datam

; close-file ( fileid --- ) If this function fails, it throws an error.

head    "close-file", hsto
closef: dq  clsf0
textm
clsf0:  mov   rdi, [r14]                ; Get file descriptor
        add   r14, 8                    ; Pop the stack

        OSCErrm close

        nextm
datam

; reposition-file  ( u fileid --- ior ) Either returns the new file position
; or throws a file I/O error.

head    "reposition-file", hsto
repof:  dq  repf0
textm
repf0: mov   rdi, [r14]                 ; Get fileid
        mov   rsi, [r14+8]              ; Get new position
        add   r14, 8                    ; Pop one stack item
        mov   rdx, [seek_set]           ; Set whence to 0

        OSCErrm lseek

        mov   [r14], rax                ; Return result

        nextm
datam

; read-file ( c-addr u1 fileid --- u2 ) Either returns the number of bytes
; actually read or throws a file I/O error. If file position pointer is at
; the end of the file, u2 will be zero.

head    "read-file", inpo
readf:  dq  redf0
textm
redf0:  mov   rdi, [r14]                ; Get fileid
        mov   rdx, [r14+8]              ; Get number of characters to read
        mov   rsi, [r14+16]             ; Get buffer address
        add   r14, 16                   ; Pop two stack items

        OSCErrm read

        mov   [r14], rax                ; Return number of bytes read
        nextm
datam

; write-file ( c-addr u fileid --- ) Write u bytes at c-addr to file whose descriptor
; is fileid.

head    "write-file", oupo
writf:  dq  wrtf0
textm
wrtf0:  mov   rdi, [r14]                ; Get fileid
        mov   rdx, [r14+8]              ; Get number of characters to write
        mov   rsi, [r14+16]             ; Get buffer address
        add   r14, 24                   ; Pop stack

        OSCErrm write

        nextm
datam

; read-line ( c-addr u1 fileid --- u2 )

head    "read-line", inpo
readl:  dq  rdln0
textm
rdln0:  mov   rdi, [r14+16]             ; Get fileid
        mov   rsi, [r14]                ; Get buffer address
        mov   rdx, [r14+8]              ; Get maximum line length

        OSCErrm read

        mov   [r14], rax
        nextm
datam

; write-line ( c-addr u fileid --- )

head    "write-line", oupo
writl:  dq  wrln0
textm
wrln0:  mov   rdi, [r14]                ; Get fileid
        mov   rdx, [r14+8]              ; Get number of characters to write
        mov   rsi, [r14+16]             ; Get buffer address
        mov   byte[rsi+rdx], 10         ; Append line-feed
        add   rdx, 1                    ; Add 1 to number of chrs to write
        add   r14, 24                   ; Pop stack

        OSCErrm write

        nextm
datam

; delete-file ( c-addr --- ) Delete the file with path at c-addr. Either
; returns nothing or throws a file I/O error.

head    "delete-file", hsto
dletf:  dq  dltf0
textm
dltf0:  mov   rdi, [r14]                ; Get address of pathname
        add   r14, 8                    ; Pop the stack

        OSCErrm unlink

        nextm
datam

; flush-file - This is currently a noop. Low-level file I/O is buffered
; by the kernel, and there is no direct way to flush these buffers.
; The C-library fflush function which would conform to the ANSI standard
; flush-file, merely flushes the stdio buffers to the kernel buffers.
; To force a particulary file to be flushed, the file has to be opened
; with O_SYNC option. Therefore the flush-file operator is left out.

; head    "flush-file", oupo
; flshf   dq  flsf0
; textm
; flsf0:  nextm
; datam

; rename-file ( c-addr1 c-addr2 --- ) Rename the file whose name is at
; c-addr1 to the name given at c-addr2. Either returns nothing or throws
; a file I/O error.
; Note: Renaming and moving a file are functionally the same.

head    "rename-file", hsto
rnmf:   dq  rnmf0
textm
rnmf0:  mov   rdi, [r14+8]              ; Get old-name string
        mov   rsi, [r14]                ; Get new-name string
        add   r14, 16                   ; Pop stack

        OSCErrm rename

        nextm
datam

; resize-file ( u fileid --- ) Either returns nothing or throws file I/O
; error.

head    "resize-file", hsto
rszf:   dq  rszf0

textm
rszf0:  mov   rdi, [r14]                ; Get fileid
        mov   rsi, [r14+8]              ; Get new position
        add   r14, 16                   ; Pop the stack

        OSCErrm ftruncate

        nextm
datam

; file-position - given the file-id, return the file position pointer

head    "file-position", hsto
flpos:  dq  flpo0
textm
flpo0:  mov   rdi, [r14]                ; Get fileid
        xor   rsi, rsi                  ; Set offset to zero
        mov   rdx, [seek_cur]           ; Set whence to 1

        OSCErrm lseek

        mov   [r14], rax                ; Return current position pointer
        nextm
datam

; file-size - given the file-id, return the size of the file.
; This function requires the file position pointer to be read,
; saved, and restored.

head    "file-size", hsto
flsize: dq  flsz0
textm

flsz0:  mov   rdi, [r14]                ; Get fileid
        xor   rsi, rsi                  ; Set offset to zero
        mov   rdx, [seek_cur]           ; Set whence to 1

        OSCErrm lseek

        mov   rbx, rax                  ; Save current pp
        mov   rdi, [r14]                ; Get fileid
        xor   rsi, rsi                  ; Set offset to zero
        mov   rdx, [seek_end]           ; Set whence to 2

        OSCErrm lseek

        mov   rdi, [r14]                ; Get fileid
        mov   [r14], rax                ; Return size of file
        mov   rsi, rbx                  ; Reset to previous value
        mov   rdx, [seek_set]           ; Set whence to 0

        OSCErrm lseek

        nextm
datam

; file-status - ( c-addr --- addr ) Return the file status structure
; of the file whose path is at c-addr to the special buffer, stsbuf,
; and leave the buffer address on the stack.
; This is an experimental non-standard version.

head    "file-status", hsto
flsts:  dq  fsts0
textm
fsts0:  mov   rdi, [r14]                ; Get address of file path
        mov   rsi, [stsb0]              ; Get stsbuf address
        mov   [r14], rsi                ; Return buffer address

        OSCErrm stat

        nextm
datam

; getfile - ( buffer fd ---  )
; Special version of readf that reads the entire file into the buffer
; and installs the number of bytes read in the buffer header. Throws
; error if buffer is too small for file.
; The file must be open and the fileid known.

head    "getfile", inpo
getfl:  dq  gtfl0
textm
gtfl0:  mov   rdi, [r14]                ; Get fileid
        xor   rsi, rsi                  ; Set offset to zero
        mov   rdx, [seek_end]           ; Set whence to 2

        OSCErrm lseek

        mov   r9, rax                   ; Copy file size
        mov   rdi, [r14]                ; Get fileid
        xor   rsi, rsi                  ; Set offset to zero
        mov   rdx, [seek_set]           ; Set whence to zero

        OSCErrm lseek

        mov   rdi, [r14]                ; Get fileid
        mov   rsi, [r14+8]              ; Get buffer address
        add   r14, 16                   ; Pop stack
        cmp   [rsi-16], r9              ; Compare file size with buffer size
        jnc   gtfl1                     ; Branch if buffer not too small

        throwm 60                       ; Else throw error

gtfl1:  mov   rdx, r9                   ; Copy file size

        OSCErrm read

        mov   [rsi-8], rax              ; Install # bytes read in buffer

        nextm
datam

; putfile - ( buffer fd ---  )
; Special version of writf that writes the entire contents of a buffer
; to the end of the file. The file must be open and the fileid known.
; The buffer must conform to the standard layout with the character
; count at buffer-8. Nothing will be written if the character count
; is zero.

head    "putfile", oupo
putfl:  dq  ptfl0
textm
ptfl0:  mov   rdi, [r14]                ; Get fileid
        mov   rsi, [r14+8]              ; Get buffer address
        mov   rdx, [rsi-8]              ; Get number of characters to write
        add   r14, 16                   ; Pop stack
        cmp   rdx, 0                    ; Check if buffer is empty
        jz    ptfl1                     ; Exit if so

        OSCErrm write

ptfl1:  nextm
datam

; outfile - ( addr n fd ---  )
; Special version of writf that appends the given number of bytes at addr
; to the end of the file. The file must be open and the fileid known.
; Nothing will be written if the character count is zero or less.

head    "outfile", oupo
outfl:  dq  otfl0
textm
otfl0:  mov   rdi, [r14]                ; Get fileid
        mov   rdx, [r14+8]              ; Get number of characters
        mov   rsi, [r14+16]             ; Get buffer address
        add   r14, 24                   ; Pop stack
        cmp   rdx, 0                    ; Check if count is <=0
        jna   otfl1                     ; Exit if so

        OSCErrm write

otfl1:  nextm
datam

; loadfile - ( addr fd ---  u )
; This function reads a file into the memory location passed on the stack
; and returns the number of bytes read. The file must be open
; and the fileid known. Used by `file,`.

head    "loadfile", inpo
lodfl:  dq  ldfl0
textm
ldfl0:  mov   rbx, [r14]                ; Get fileid
        add   r14, 8                    ; Pop stack item
        mov   rdi, rbx                  ; Set fileid
        xor   rsi, rsi                  ; Set offset to zero
        mov   rdx, [seek_end]           ; Set whence to 2

        OSCErrm lseek

        mov   rbp, rax                  ; Copy file size
        mov   rdi, rbx                  ; Set fileid
        xor   rsi, rsi                  ; Set offset to zero
        mov   rdx, [seek_set]           ; Set whence to zero

        OSCErrm lseek

        mov   rdi, rbx                  ; Set fileid
        mov   rsi, [r14]                ; Get destination address
        mov   rdx, rbp                  ; Copy file size

        OSCErrm read

        mov   [r14], rax                ; Return bytes read

        nextm
datam

; load-file  <filename> Place the contents of the file, preceded
; by the number of bytes read, in the current file input buffer.
;
; : load-file   axb0 bufword r/o open-file dup >a next-fib
;              swap getfile a> close-file prev-fib ;

head    "load-file", hlfo
ldfile: dq  docl0
        dq  axbn,bufwrd
        dq  rdonly,openf,dupl,toa
        dq  nxtfib,swp,getfl
        dq  froma,closef,prvfib,semis

; save-file  <filename>  ( addr n --- ) Append n bytes from address
; to the end of the file, filename. If the file does not exist, create
; it with r/w access and 0775o permissions. Close the file when
; the write operation is finished.
;
; : save-file   axb0 bufword r/w o_create o_append or or
;              509 create-file dup >a outfile a> close-file ;

head    "save-file", hlfo
svfile: dq  docl0
        dq  axbn,bufwrd
        dq  rdwrt,ocreat,oapnd,orf,orf
        dq  lit,0x1FD,creatf,dupl,toa
        dq  outfl,froma,closef,semis

; file>buffer  <filename> ( addr --- ) Place the contents of the file,
; preceded by the number of bytes read, in the buffer whose address is
; passed on the stack.
;
; : file>buffer   axb0 bufword r/o open-file dup >a
;                getfile a> close-file prev-fib ;

head    "file>buffer", hlfo
fltbf:  dq  docl0
        dq  axbn,bufwrd,rdonly
        dq  openf,dupl,toa,getfl
        dq  froma,closef,prvfib,semis

; stack>file  <filename>  ( --- ) Append the binary stack contents
; to the end of the file, filename. If the file does not exist, create
; it with r/w access and 0775o permissions. Close the file when
; the write operation is finished. The stack remains as it was.
;
; : stack>file   depth 8* sp@ 8+ swap save-file ;

head    "stack>file", hlfo
stkfl:  dq  docl0
        dq  depth,estar,spat,eighp,swp,svfile,semis


; file>stack  <filename>  ( --- ) Copy the binary contents of the file
; directly to the stack. The filesize is converted from bytes to quads
; and rounded up to the next higher number of quads.
;

; : file>stack   axb0 bufword r/o open-file dup >a
;               file-size rnd>8 8/ qsz@ >a qsz! 0 sq>in a>
;               qsz! sp@ a@ loadfile drop a> close-file ;

head    "file>stack", hlfo
flstk:  dq  docl0
        dq  axbn,bufwrd
        dq  rdonly,openf,dupl,toa,flsize,rute
        dq  eslsh,qszat,toa,qszsto,zero,sqtin
        dq  froma,qszsto,spat,aat,lodfl,drop
        dq  froma,closef,semis

; show-file <filename> ( --- ) Display the file in the console.

; : show-file   load-file cfib @ dup 8- @ cr cr strout ;

head    "show-file", hlfo
shfile: dq  docl0
        dq  ldfile,cfib,qat,dupl,eighm,qat,cr,cr,strout,semis

; Miscellaneous System Functions

; alloc ( u --- a-addr ior ) - Allocate u bytes of memory. If successful,
; return the address of the memory and an I/O result code of zero.

head    "allocate"
alloc:  dq  aloc0
textm
aloc0:  mov   rdi, [r14]

        CFCm  malloc

        mov   [r14], rax
        nextm
datam

; free ( a-addr --- ior ) - Free memory at a-addr and return result code.

head    "free"
mfree:  dq  mfre0
textm
mfre0:  mov   rdi, [r14]

        CFCm  free

        mov   [r14], rax
        nextm
datam

; resize ( a-addr1 u --- a-addr2 ior ) - Resize memory at a-addr1 to u bytes
; return a-addr2 and result code. This simply frees the memory at a-addr1
; and allocates u bytes through a new call to malloc.

head    "resize"
rszm:   dq  rszm0
textm
rszm0:  mov   rdi, [r14]
        add   r14, 8

        CFCm  free

        mov   rdi, [r14]

        CFCm  malloc

        mov   [r14], rax
        nextm
datam

; sleep - ( seconds --- )

head    "sleep", hsto
xsleep: dq  slep0
textm
slep0:  mov   rdi, [r14]
        add   r14, 8

        CFCm  sleep

        nextm
datam

; rand64 - Obtain a 64-bit random number on the stack.

head    "rand64", hsto
randsf: dq  rnsf0
textm
rnsf0:  sub   r14, 8
        mov   rdi, r14                  ; Use stack for buffer
        mov   rsi, 8                    ; Get 8 bytes
        xor   rdx, rdx                  ; Set no flags

        OSCm  getrandom

        nextm
datam

; gtime - This system call returns two values - the seconds since 00:00:00,
; 1 Jan 1970 UTC, and the number of additional microseconds. According to
; Kerrisk, microsecond accuracy is attainable on systems with the Timestamp
; Counter register. But this seems to depend on whether the system call
; itself uses that register. I have found that in Ubuntu on an Intel i7,
; microsecond granularity is not available. Direct reading of the tsc
; register, however, gives the desired accuracy for benchmarking. So I'm
; arranging that this function return only the seconds value.

head    "gtime", hsto
gtime:  dq  gtim0
textm
gtim0:  mov   rdi, [gtod0]
        mov   rbx, rdi                  ; Copy address of time data

        OSCm  gettimeofday

        mov   rdx, [rbx]
        sub   r14, 8
        mov   [r14], rdx
        nextm
datam

; getwinxy - Get the row and column dimensions of the screen.

head    "getwinxy", hsto
getwxy: dq  gwxy0
textm
gwxy0:  sub   r14,8
        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tiocgwinsz]
        mov   rdx, r14

        OSCm  ioctl

        movzx rax, word[r14]
        movzx rbx, word[r14+2]
        mov   [r14], rbx
        sub   r14, 8
        mov   [r14], rax

        nextm
datam

; shclr - Clear the screen. Example of precompiled `shell"` .

; : shclr   shell" clear" ;

head    "shclr", hlfo
shclr:  dq  docl0
        dq  pshlq
        dq  24
        casczm "clear"
        dq  semis

; clear - Clear the screen by outputting Escape sequence.

head    "clear", oupo
clear:  dq  cler0
textm
cler0:  mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [clscr]
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

        mov   qword[curx0], 1           ; Set cursor col and row to origin
        mov   qword[cury0], 1
        nextm
datam

; reset-term - Reset the terminal device. This clears the scrollback buffer
; and places the cursor at 1, 1. It's probably not necessary to set
; the global cursor coordinates, but this is done anyway.

head    "reset-term", oupo
rsett:  dq  rset0
textm
rset0:  mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [rset]
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

        mov   qword[curx0], 1           ; Set cursor col and row to origin
        mov   qword[cury0], 1
        nextm
datam

; Cursor control words.

; save-cursor - Output escape sequence to save the cursor position
; and attributes - Esc[s

head    "save-cursor", oupo
savcsr: dq  scsr0
textm
scsr0:  mov   rdi, [sdout]
        lea   rsi, [scrat]
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

        nextm
datam

; restore-cursor - Output escape sequence to restore the cursor position
; and attributes - Esc[u

head    "restore-cursor", oupo
rstcsr: dq  rcsr0
textm
rcsr0:  mov   rdi, [sdout]
        lea   rsi, [rcrat]
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

        nextm
datam

; hide-cursor - Output escape sequence to hide the cursor - Esc[?25l

head    "hide-cursor", oupo
hidcsr: dq  hdcr0
textm
hdcr0:  mov   rdi, [sdout]
        lea   rsi, [hdcsr]
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

        nextm
datam

; show-cursor - Output escape to show the cursor - Esc[?25h

head    "show-cursor", oupo
shwcsr: dq  shcr0
textm
shcr0:  mov   rdi, [sdout]
        lea   rsi, [shcsr]
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

        nextm
datam

; gotoxy - Move the cursor to the specified location. <ESC>[{ROW};{COLUMN}H
; ( x y --- )
; Allow four digits for each of rows and columns. This should be enough for even
; 2K monitors. Then the total string can be as many as 12 bytes.
; The coordinates are treated as unsigned integers. A coordinate of 0 is
; converted to 1. A coordinate larger than the screen width or height is
; converted to the screen width or height.

head    "gotoxy", oupo
gtoxy:  dq  goxy0
textm
goxy0:  mov   rax, [r14]                ; Get y
        mov   qword[r14], 0             ; Clear stack entry

        cmp   rax, 0                    ; Test if 0
        jnz   goxy1                     ; Branch if not

        mov   rax, 1                    ; Else set to 1
        jmp   goxy2

goxy1:  cmp   [hght0], rax              ; Test if <= height
        jnc   goxy2                     ; Branch if so

        mov   rax, [hght0]              ; Else set to height

goxy2:  mov   [cury0], rax              ; Update currow

        mov   r11, [r14+8]              ; Get x
        mov   qword[r14+8], 0           ; Clear stack entry

        cmp   r11, 0                    ; Test if 0
        jnz   goxy3                     ; Branch if not

        mov   r11, 1                    ; Else set to 1
        jmp   goxy4

goxy3:  cmp   [wdth0], r11              ; Test if <= width
        jnc   goxy4                     ; Branch if so

        mov   r11, [wdth0]              ; Else set to width

goxy4:  mov   [curx0], r11              ; Update curcol

        mov   rdi, 2                    ; Initialize character count
        mov   rsi, 2                    ; Initialize buffer index

        mov   word[r14], 0x5B1B         ; Install Esc[

        mov   r8, 10                    ; Number base is 10
        xor   rcx, rcx                  ; Clear digit count
        xor   rdx, rdx                  ; Clear high order dividend

; Process y.

goxy5:  cmp   rcx, 4                    ; Limit number of digits to 4
        jz    goxy7

        div   r8                        ; Divide by base
        add   rdx, 0x30                 ; Convert to ASCII
        mov   [r14+rsi], dl             ; Install digit in stack
        add   rdi, 1                    ; Increment character count
        add   rcx, 1                    ; Increment digit count
        add   rsi, 1                    ; Increment buffer pointer
        test  rax, rax                  ; Test for zero
        jz    goxy6                     ; Branch if zero
        xor   rdx, rdx                  ; Clear remainder
        jmp   goxy5                     ; Loop

goxy6:  cmp   rcx, 4
        jnz   goxy8

; Reverse 4 bytes.

goxy7:  mov   al, [r14+2]
        mov   bl, [r14+rsi-1]
        mov   [r14+2], bl
        mov   [r14+rsi-1], al
        mov   al, [r14+3]
        mov   bl, [r14+rsi-2]
        mov   [r14+3], bl
        mov   [r14+rsi-2], al
        jmp   goxy9

goxy8:  cmp   rcx, 2
        jc    goxy9

; Reverse 2 or 3 bytes.

        mov   al, [r14+2]
        mov   bl, [r14+rsi-1]
        mov   [r14+2], bl
        mov   [r14+rsi-1], al

goxy9:  mov   byte[r14+rsi], 0x3B       ; Install semicolon
        add   rdi, 1                    ; Increment character count
        add   rsi, 1                    ; Increment buffer pointer

; Process x.

        mov   rax, r11                  ; Get x
        mov   r11, rdi                  ; Save current character count
        xor   rcx, rcx                  ; Clear digit count
        xor   rdx, rdx                  ; Clear high order dividend

goxy10: cmp   rcx, 4                    ; Limit number of digits to 4
        jz    goxy12

        div   r8                        ; Divide by base
        add   rdx, 0x30                 ; Convert to ASCII
        mov   [r14+rsi], dl             ; Install digit in stack
        add   rdi, 1                    ; Increment character count
        add   rcx, 1                    ; Increment digit count
        add   rsi, 1                    ; Increment buffer pointer
        test  rax, rax                  ; Test for zero
        jz    goxy11                    ; Branch if zero
        xor   rdx, rdx                  ; Clear remainder
        jmp   goxy10                    ; Loop

goxy11: cmp   rcx, 4
        jnz   goxy13

; Reverse 4 bytes.

goxy12: mov   al, [r14+r11]
        mov   bl, [r14+rsi-1]
        mov   [r14+r11], bl
        mov   [r14+rsi-1], al
        mov   al, [r14+r11+1]
        mov   bl, [r14+rsi-2]
        mov   [r14+r11+1], bl
        mov   [r14+rsi-2], al
        jmp   goxy14

goxy13: cmp   rcx, 2
        jc    goxy14

; Reverse 2 or 3 bytes.

        mov   al, [r14+r11]
        mov   bl, [r14+rsi-1]
        mov   [r14+r11], bl
        mov   [r14+rsi-1], al

goxy14: mov   byte[r14+rsi], 0x48       ; Install H
        add   rdi, 1                    ; Increment character count

; Output escape sequence.

        mov   rdx, rdi                  ; Copy character count
        mov   rdi, [sdout]              ; Standard handle
        mov   rsi, r14                  ; Copy buffer address

        OSCm  write

        add   r14, 16                   ; Pop stack
        nextm
datam

; get-xy - Get cursor coordinates. This version uses only functions that are
; safe for signal handling. It does not enter raw mode, it only changes the
; ICANON and ECHO bits.

head    "get-xy", oupo
gtcxy:  dq  gcxy0
textm
gcxy0:  lea   rbp, [trmio0]             ; Address of original structure

; Get attribute state.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, rbp

        CFCm  tcgetattr

; Clear c_lflag bits - ICANON and ECHO.

        mov   eax, [icanon]             ; Clear ICANON bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [echo]               ; Clear ECHO bit
        not   eax
        and   [rbp+12], eax

; Set new attribute state.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        mov   rdx, rbp

        CFCm  tcsetattr

; Get cursor position. Send: <ESC>[6n     Receive: <ESC>[{ROW};{COLUMN}R
; Return packet can be up to 12 characters.

        mov   rdi, [sdout]              ; Standard handle
        lea   rsi, [gtcrs]              ; Get cursor
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

; Use select() to determine when input is ready. Note that in this case we do
; not use ioctl() with FIONREAD to find the number of characters waiting.
; Passing the argument of 12 to read guarantees that the maximum Escape
; sequence will be received.

; Clear 16 quads of bitmask at selct0+16.

gcxy1:  mov   rax, 0
        mov   rcx, 16
        lea   rdi, [selct0]
gcxy2:  mov   [rdi+rcx*8+8], rax
        sub   rcx, 1
        jnz   gcxy2

        mov   qword[rdi+16], 1          ; Set bitmask for standard input
        xor   r8, r8                    ; Timeout indefinite
        xor   r10, r10                  ; No exceptions
        xor   rdx, rdx                  ; No outputs
        lea   rsi, [rdi+16]             ; Address of input bitmask
        mov   rdi, 1                    ; Monitor only one input

        OSCm  select

        bt    rax, 63
        jc    gcxy1

; Read Escape sequence.

        sub   r14, 16                   ; Create space on stack
        mov   qword[r14], 0             ; Clear buffer quads
        mov   qword[r14+8], 0

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, r14                  ; Where to put result
        mov   rdx, 12                   ; Get up to 12 characters

        OSCm  read

; Convert ASCII decimal digits to binary.

        mov   r8, 10                    ; Base is 10

        xor   rcx, rcx                  ; Zero count
gcxy3:  cmp   byte[r14+rcx+2], 0x3B     ; Find semicolon
        jz    gcxy4
        add   rcx, 1                    ; Increment count
        jmp   gcxy3

gcxy4:  lea   rdi, [r14+rcx+3]          ; Save address past semicolon

        xor   rax, rax                  ; Zero accumulator
        xor   rsi, rsi                  ; Zero index
gcxy5:  mul   r8                        ; Multiply by base
        movzx rbx, byte[r14+rsi+2]      ; Get first/next byte of y
        sub   rbx, 0x30                 ; Convert from ASCII
        add   rax, rbx                  ; Add to result
        add   rsi, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   gcxy5                     ; Loop if not zero

        mov   r9, rax                   ; Save y-coordinate

        xor   rcx, rcx                  ; Zero count
gcxy6:  cmp   byte[rdi+rcx], 0x52       ; Find R
        jz    gcxy7
        add   rcx, 1                    ; Increment count
        jmp   gcxy6

gcxy7:  xor   rax, rax                  ; Zero accumulator
        xor   rsi, rsi                  ; Zero index
gcxy8:  mul   r8                        ; Multiply by base
        movzx rbx, byte[rdi+rsi]        ; Get first/next byte of x
        sub   rbx, 0x30                 ; Convert from ASCII
        add   rax, rbx                  ; Add to result
        add   rsi, 1                    ; Increment index
        sub   rcx, 1                    ; Decrement count
        jnz   gcxy8                     ; Loop if not zero

        mov   [r14+8], rax              ; Return x-coordinate
        mov   [r14], r9                 ; Return y-coordinate

; Reset ICANON and ECHO bits.

        mov   eax, [icanon]             ; Set ICANON bit
        or    [rbp+12], eax

        mov   eax, [echo]               ; Set ECHO bit
        or   [rbp+12], eax

; Restore attribute state.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        mov   rdx, rbp

        CFCm  tcsetattr

        nextm
datam

; scroll-up ( n --- ) Scroll the display up n lines.

head    "scroll-up", oupo
scrlup: dq  scup0
textm
scup0:  mov   rbp, [r14]                ; Get line count
        add   r14, 8                    ; Pop stack
scup1:  mov   rdi, [sdout]
        lea   rsi, [scrup]
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

        sub   rbp, 1
        jnz   scup1
        nextm
datam

; scroll-down ( n --- ) Scroll the display down n lines.

head    "scroll-down", oupo
scrldn: dq  scdn0
textm
scdn0:  mov   rbp, [r14]                ; Get line count
        add   r14, 8                    ; Pop stack
scdn1:  mov   rdi, [sdout]
        lea   rsi, [scrdn]
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

        sub   rbp, 1
        jnz   scdn1
        nextm
datam

; getcurseq - Special function to get the cursor location in the form
; of an escape sequence which can then be sent to the terminal to place
; the cursor. The sequence occupies 2 quads on the stack. Subsequently invoking
; escout will return the cursor to where is was.

head    "getcurseq", oupo
gtcsq:  dq  gcsq0
textm

gcsq0:  lea   rbp, [trmio0]             ; Address of original structure

; Get attribute state.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, rbp

        CFCm  tcgetattr

; Clear c_lflag bits - ICANON and ECHO.

        mov   eax, [icanon]             ; Clear ICANON bit
        not   eax
        and   [rbp+12], eax

        mov   eax, [echo]               ; Clear ECHO bit
        not   eax
        and   [rbp+12], eax

; Set new attribute state.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        mov   rdx, rbp

        CFCm  tcsetattr

; Get cursor position. Send: <ESC>[6n     Receive: <ESC>[{ROW};{COLUMN}R
; Return packet can be up to 10 characters.

        mov   rdi, [sdout]
        lea   rsi, [gtcrs]              ; Get cursor
        mov   rdx, [rsi]
        add   rsi, 8

        OSCm  write

        sub   r14, 16
        mov   qword[r14], 0
        mov   qword[r14+8], 0

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, r14                  ; Where to put result
        mov   rdx, 10                   ; Get up to 10 characters

        OSCm  read

; Replace the R with H.

        mov   byte[r14+rax-1], 0x48

; Reset ICANON and ECHO bits.

        mov   eax, [icanon]             ; Set ICANON bit
        or    [rbp+12], eax

        mov   eax, [echo]               ; Set ECHO bit
        or   [rbp+12], eax

; Restore attribute state.

        mov   rdi, [sdin]               ; Standard handle
        mov   rsi, [tcsaflush]
        mov   rdx, rbp

        CFCm  tcsetattr

        nextm
datam

; escout - Send an escape sequence to the terminal. Regardless of the number
; of bytes in the sequence (never more than 12), it occupies 16 bytes
; on the stack and is followed by a null.

head    "escout", oupo
escout: dq  esco0
textm
esco0:

; Do nothing if 1st byte is not Esc.

        cmp   byte[r14], 27
        jnz   esco3

; Find number of bytes in sequence.

        mov   rcx, 15
esco1:  cmp   byte[r14+rcx], 0
        jnz   esco2
        sub   rcx, 1
        jnz   esco1

esco2:  add   rcx, 1

        mov   rdi, [sdout]
        mov   rsi, r14
        mov   rdx, rcx

        OSCm  write

        add   r14, 16                   ; Pop the stack

esco3:  nextm
datam

; attrib ( n --- ) Set font display attribute. Throw error if attribute number
; is out of bounds.
; Escape sequence: Esc[{n}m , where n is the attribute number, one of:
;
; 0 Reset all attributes
; 1 Bright
; 2 Dim
; 3 Italic
; 4 Underscore
; 5 Blink
; 7 Reverse
; 8 Hidden
; 9 Strikeout

head    "attrib", oupo
attrib: dq  atrb0
textm
atrb0:  mov   rbx, [r14]                ; Get attribute number

; See if attribute is within bounds.

        cmp   rbx, 10
        jnc   atrb1
        cmp   rbx, 0
        jc    atrb1

        add   rbx, 48                   ; Convert to ASCII
        xor   rax, rax
        mov   [r14], rax                ; Clear stack entry
        mov   ax, 0x5B1B                ; Install Esc[
        mov   [r14], ax
        mov   [r14+2], bl               ; Install attribute number
        mov   al, 0x6D                  ; Install m
        mov   [r14+3], al

        mov   rdi, [sdout]
        mov   rsi, r14
        mov   rdx, 4

        OSCm  write

        add   r14, 8                    ; Pop the stack
        jmp   atrb2

atrb1:  add   r14, 8

        throwm 14

atrb2:  nextm
datam

; kill - ( pid sig --- result ) Send a signal to a process.

head    "kill"
ssig:   dq  ssig0
textm
ssig0:  mov   rdi, [r14+8]
        mov   rsi, [r14]

        OSCm  kill

        add   r14, 8
        mov   [r14], rax
        nextm
datam

; Include external modules here.

%include  "udis86.asm"
%include  "FPUmath.asm"
%include  "math.asm"
%include  "quadmath.asm"
%include  "ptrace.asm"

; To include the Marsenne Twister, uncomment the %include statement below
; and use:

;    yasm -f elf64 forthx.asm && gcc -no-pie -o forthx forthx.o forthx.c
;        twister64/twister64.c -ludis86 -lm -lquadmath

; %include  "twister64/twister64.asm"

; eobss - Return the address of the end of the bss section.

head    "eobss", stko
ebss:   dq  ebss0
textm
ebss0:  lea   rdi, [eom0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam

; end - Return the address of the end of the precompiled dictionary.

lasthead "end", 1, end1, lastlnk
endd:   dq  endd0
txtlst
endd0:  lea   rdi, [dctnd0]
        sub   r14, 8
        mov   [r14], rdi
        nextm
datam
end1:

dsp0:   times dictsz dq 0

; End-of-dictionary Marker

dctnd0:

; Uninitialized data is put in the .bss segment.
;

; ******* bss

section .bss

align 16

; Number I/O Buffers
; Reserve 2 additional quads for bic#

nib0:   resq nibsz+2
nob0:   resq nobsz+2

; Hold area for numeric output
; Reserve 2 additional quads for bic#

hld0:   resq    hldsz+2

; Return Stack
; Return stack and hold buffer bic# are the same.
; If there is a collision of the hld buffer and
; the return stack, the user will have to determine
; which is causing the problem, or enlarge both.

        resq    rstksz
rstack0:                                ; Top of return stack

; Data Stack

        resq    dstksz
dstack0:                                ; Top of data stack
guard0: resq    2                       ; Data stack quard quads

; Auxiliary Stack

        resq   dstksz
astack0:
quard0: resq   2

; End of Forthx64 memory

eom0:
